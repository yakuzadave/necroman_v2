/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ProgressBar
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var ProgressBar = class extends import_obsidian.Plugin {
  // settings: ProgressBarSettings;
  async onload() {
    this.registerMarkdownCodeBlockProcessor("progressbar", (source, el, ctx) => {
      const cfg = (0, import_obsidian.parseYaml)(source);
      if (!cfg.kind && !cfg.value) {
        newError(el, "No kind specified");
        return;
      }
      if (cfg.kind === "day-custom" && !cfg.min && !cfg.max) {
        newError(el, "Must specify min and max for day-custom");
        return;
      }
      createProgressBar(el, cfg);
    });
  }
  onunload() {
  }
  // async loadSettings() {
  //   this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  // }
  //
  // async saveSettings() {
  //   await this.saveData(this.settings);
  // }
};
function newError(el, msg) {
  el.createEl("div", { text: "ProgressBarError: " + msg });
}
function createProgressBar(el, bar) {
  switch (bar.kind) {
    case "day-year":
      return newDayYearProgressBar(el, bar);
    case "day-month":
      return newDayMonthProgressBar(el, bar);
    case "month":
      return newMonthProgressBar(el, bar);
    case "day-week":
      return newDayWeekProgressBar(el, bar);
    case "day-custom":
      return newDayCustomProgressBar(el, bar);
    default:
      return newProgressBar(el, bar, bar);
  }
}
function daysIntoYear(date) {
  return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - Date.UTC(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
}
function newDayWeekProgressBar(el, bar) {
  bar.max = 7;
  bar.value = new Date().getDay() === 0 ? 7 : new Date().getDay();
  newProgressBar(el, bar, bar);
}
function newMonthProgressBar(el, bar) {
  bar.max = 12;
  bar.value = new Date().getMonth() + 1;
  newProgressBar(el, bar, bar);
}
function newDayMonthProgressBar(el, bar) {
  const now = new Date();
  bar.max = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
  bar.value = now.getDate();
  newProgressBar(el, bar, bar);
}
function newDayYearProgressBar(el, bar) {
  bar.max = new Date().getFullYear() % 4 == 0 ? 366 : 365;
  bar.value = daysIntoYear(new Date());
  newProgressBar(el, bar, bar);
}
function newDayCustomProgressBar(el, bar) {
  let val = {
    min: daysIntoYear(new Date(bar.min)),
    max: daysIntoYear(new Date(bar.max)),
    value: daysIntoYear(new Date())
  };
  val.max = val.max - val.min;
  val.value = val.value - val.min;
  newProgressBar(el, bar, val);
}
function applyTemplate(template, data) {
  const pattern = /{\s*(\w+?)\s*}/g;
  return template.replace(pattern, (_, token) => data[token] || "{" + token + "}");
}
function newProgressBar(el, bar, val) {
  const labelName = bar.name ? bar.name : bar.kind + "({percentage})";
  const value = (Math.floor(bar.value * 10) / 10).toString();
  const message = applyTemplate(labelName, {
    min: bar.min,
    max: bar.max,
    value,
    percentage: Math.round(val.value / val.max * 100) + "%"
  });
  const label = el.createEl("label", { text: message + ": " });
  const progressbar = label.createEl("progress");
  progressbar.value = val.value;
  progressbar.max = val.max;
  if (bar.width) {
    progressbar.style.width = bar.width;
  }
}
