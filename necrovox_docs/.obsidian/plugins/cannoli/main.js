/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  HttpTemplateEditorModal: () => HttpTemplateEditorModal,
  RunPriceAlertModal: () => RunPriceAlertModal,
  default: () => Cannoli
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/canvas.ts
var Canvas = class {
  constructor(canvasFile, subCanvasGroupId) {
    this.canvasFile = canvasFile;
    this.subCanvasGroupId = subCanvasGroupId;
    this.editQueue = Promise.resolve();
  }
  getCanvasData() {
    return this.canvasData;
  }
  async fetchData() {
    const fileContent = await this.canvasFile.vault.cachedRead(
      this.canvasFile
    );
    const parsedContent = JSON.parse(fileContent);
    for (const node of parsedContent.nodes) {
      if (node.type === "group" && (node.label === "cannoli" || node.label === "Cannoli")) {
        this.subCanvasGroupId = node.id;
        break;
      }
    }
    this.canvasData = parsedContent;
    if (this.subCanvasGroupId) {
      const subCanvasGroup = parsedContent.nodes.find(
        (node) => node.id === this.subCanvasGroupId
      );
      if (!subCanvasGroup) {
        throw new Error(
          `Group with id ${this.subCanvasGroupId} not found.`
        );
      }
      const { nodeIds, edgeIds } = this.getNodesAndEdgesInGroup(subCanvasGroup);
      parsedContent.nodes = parsedContent.nodes.filter(
        (node) => nodeIds.includes(node.id)
      );
      parsedContent.edges = parsedContent.edges.filter(
        (edge) => edgeIds.includes(edge.id)
      );
      this.canvasData = parsedContent;
    }
  }
  getNodesAndEdgesInGroup(group) {
    const groupRectangle = this.createRectangle(
      group.x,
      group.y,
      group.width,
      group.height
    );
    const nodeIds = [];
    const edgeIds = [];
    for (const node of this.canvasData.nodes) {
      if (node.id === group.id)
        continue;
      const nodeRectangle = this.createRectangle(
        node.x,
        node.y,
        node.width,
        node.height
      );
      if (this.encloses(groupRectangle, nodeRectangle)) {
        nodeIds.push(node.id);
      } else if (this.overlaps(groupRectangle, nodeRectangle)) {
        throw new Error(
          `Invalid layout: Node with id ${node.id} overlaps with the group but is not fully enclosed. Nodes should be fully inside or outside of each group.`
        );
      }
    }
    for (const edge of this.canvasData.edges) {
      if (nodeIds.includes(edge.fromNode) && nodeIds.includes(edge.toNode)) {
        edgeIds.push(edge.id);
      }
    }
    return { nodeIds, edgeIds };
  }
  createRectangle(x, y, width, height) {
    return {
      x,
      y,
      width,
      height,
      x_right: x + width,
      y_bottom: y + height
    };
  }
  encloses(a, b) {
    return a.x <= b.x && a.y <= b.y && a.x_right >= b.x_right && a.y_bottom >= b.y_bottom;
  }
  overlaps(a, b) {
    const horizontalOverlap = a.x < b.x_right && a.x_right > b.x;
    const verticalOverlap = a.y < b.y_bottom && a.y_bottom > b.y;
    const overlap = horizontalOverlap && verticalOverlap;
    return overlap && !this.encloses(a, b) && !this.encloses(b, a);
  }
  async readCanvasData() {
    const fileContent = await this.canvasFile.vault.read(this.canvasFile);
    return JSON.parse(fileContent);
  }
  async writeCanvasData(data) {
    const newContent = JSON.stringify(data);
    const onEdit = (data2) => {
      return newContent;
    };
    await this.canvasFile.vault.process(this.canvasFile, onEdit);
  }
  changeNodeColor(data, nodeId, newColor) {
    const node = data.nodes.find((node2) => node2.id === nodeId);
    if (node) {
      node.color = newColor;
    }
    return data;
  }
  addErrorNode(data, nodeId, error) {
    const node = data.nodes.find((node2) => node2.id === nodeId);
    const nodeCenterY = node ? node.y + node.height / 2 : 0;
    if (node) {
      const newNodeId = this.generateNewId();
      const errorNode = {
        id: newNodeId,
        x: node.x + node.width + 50,
        y: nodeCenterY - 75,
        width: 500,
        height: 150,
        color: "1",
        text: `<u>Error:</u>
` + error,
        type: "text"
        // Add the 'type' property
      };
      const newEdge = {
        id: this.generateNewId(),
        fromNode: nodeId,
        fromSide: "right",
        toNode: newNodeId,
        toSide: "left",
        fromEnd: "none",
        toEnd: "none",
        color: "1"
        // red color
      };
      data.nodes.push(errorNode);
      data.edges.push(newEdge);
    }
    return data;
  }
  addWarningNode(data, nodeId, error) {
    const node = data.nodes.find((node2) => node2.id === nodeId);
    const nodeCenterY = node ? node.y + node.height / 2 : 0;
    if (node) {
      const newNodeId = this.generateNewId();
      const errorNode = {
        id: newNodeId,
        x: node.x + node.width + 50,
        y: nodeCenterY - 75,
        width: 500,
        height: 150,
        color: "1",
        text: `<u>Warning:</u>
` + error,
        type: "text"
        // Add the 'type' property
      };
      const newEdge = {
        id: this.generateNewId(),
        fromNode: nodeId,
        fromSide: "right",
        toNode: newNodeId,
        toSide: "left",
        fromEnd: "none",
        toEnd: "none",
        color: "1"
        // red color
      };
      const existingWarningNode = data.nodes.find(
        (node2) => node2.x === errorNode.x && node2.y === errorNode.y && node2.width === errorNode.width && node2.height === errorNode.height && node2.text === errorNode.text
      );
      if (existingWarningNode) {
        return null;
      }
      data.nodes.push(errorNode);
      data.edges.push(newEdge);
    }
    return data;
  }
  removeAllErrorNodes(data) {
    const errorNodes = data.nodes.filter(
      (node) => {
        var _a2, _b;
        return node.color === "1" && (((_a2 = node.text) == null ? void 0 : _a2.startsWith("<u>Error:</u>\n")) || ((_b = node.text) == null ? void 0 : _b.startsWith("<u>Warning:</u>\n")));
      }
    );
    const errorEdgeIds = /* @__PURE__ */ new Set();
    errorNodes.forEach((node) => {
      data.edges.forEach((edge) => {
        if (edge.fromNode === node.id || edge.toNode === node.id) {
          errorEdgeIds.add(edge.id);
        }
      });
    });
    data.edges = data.edges.filter((edge) => !errorEdgeIds.has(edge.id));
    data.nodes = data.nodes.filter((node) => !errorNodes.includes(node));
    return data;
  }
  changeNodeText(data, nodeId, newText) {
    const node = data.nodes.find((node2) => node2.id === nodeId);
    if (node) {
      node.text = newText;
    }
    return data;
  }
  async enqueueChangeNodeColor(nodeId, newColor) {
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.changeNodeColor(data, nodeId, newColor);
      await this.writeCanvasData(newData);
    });
    return this.editQueue;
  }
  async enqueueAddErrorNode(nodeId, message) {
    if (nodeId.includes("-")) {
      nodeId = nodeId.split("-")[0];
    }
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.addErrorNode(data, nodeId, message);
      await this.writeCanvasData(newData);
    });
    return this.editQueue;
  }
  async enqueueAddWarningNode(nodeId, message) {
    if (nodeId.includes("-")) {
      nodeId = nodeId.split("-")[0];
    }
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.addWarningNode(data, nodeId, message);
      if (newData) {
        await this.writeCanvasData(newData);
      }
    });
    return this.editQueue;
  }
  async enqueueChangeNodeText(nodeId, newText) {
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.changeNodeText(data, nodeId, newText);
      await this.writeCanvasData(newData);
    });
    return this.editQueue;
  }
  async enqueueRemoveAllErrorNodes() {
    this.editQueue = this.editQueue.then(async () => {
      const data = await this.readCanvasData();
      const newData = this.removeAllErrorNodes(data);
      await this.writeCanvasData(newData);
    });
    return this.editQueue;
  }
  generateNewId() {
    return v4_default().replace(/-/g, "").substring(0, 16);
  }
};

// src/models/object.ts
var CannoliObject = class extends EventTarget {
  constructor(data) {
    super();
    this.id = data.id;
    this.text = data.cannoliData.text;
    this.status = data.cannoliData.status;
    this.dependencies = data.cannoliData.dependencies;
    this.originalObject = data.cannoliData.originalObject;
    this.kind = data.cannoliData.kind;
    this.type = data.cannoliData.type;
    this.canvasData = data;
  }
  setRun(run) {
    this.run = run;
  }
  setGraph(graph, cannoliGraph) {
    this.graph = graph;
    this.cannoliGraph = cannoliGraph;
  }
  setupListeners() {
    for (const dependency of this.dependencies) {
      this.graph[dependency].addEventListener(
        "update",
        (event) => {
          this.dependencyUpdated(
            event.detail.obj,
            event.detail.status
          );
        }
      );
    }
  }
  getAllDependencies() {
    const dependencies = [];
    for (const dependency of this.dependencies) {
      dependencies.push(this.graph[dependency]);
    }
    return dependencies;
  }
  dependencyUpdated(dependency, status) {
    if (this.run.isStopped) {
      return;
    }
    switch (status) {
      case "complete" /* Complete */:
        this.dependencyCompleted(dependency);
        break;
      case "rejected" /* Rejected */:
        this.dependencyRejected(dependency);
        break;
      case "executing" /* Executing */:
        this.dependencyExecuting(dependency);
        break;
      default:
        break;
    }
  }
  allDependenciesComplete() {
    const dependencies = this.getAllDependencies();
    for (const dependency of dependencies) {
      if (dependency.status !== "complete" /* Complete */) {
        if (this.cannoliGraph.isEdge(dependency) && dependency.type !== "logging" /* Logging */) {
          let redundantComplete = false;
          for (const otherDependency of dependencies) {
            if (this.cannoliGraph.isEdge(otherDependency) && otherDependency.text === dependency.text && otherDependency.type === dependency.type && otherDependency.status === "complete" /* Complete */) {
              redundantComplete = true;
              break;
            }
          }
          if (!redundantComplete) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
    return true;
  }
  allEdgeDependenciesComplete() {
    const dependencies = this.getAllDependencies();
    for (const dependency of dependencies) {
      if (!this.cannoliGraph.isEdge(dependency)) {
        continue;
      }
      if (dependency.status !== "complete" /* Complete */) {
        if (this.cannoliGraph.isEdge(dependency) && dependency.type !== "logging" /* Logging */) {
          let redundantComplete = false;
          for (const otherDependency of dependencies) {
            if (this.cannoliGraph.isEdge(otherDependency) && otherDependency.text === dependency.text && otherDependency.status === "complete" /* Complete */) {
              redundantComplete = true;
              break;
            }
          }
          if (!redundantComplete) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
    return true;
  }
  executing() {
    this.status = "executing" /* Executing */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "executing" /* Executing */ }
    });
    this.dispatchEvent(event);
  }
  completed() {
    this.status = "complete" /* Complete */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "complete" /* Complete */ }
    });
    this.dispatchEvent(event);
  }
  pending() {
    this.status = "pending" /* Pending */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "pending" /* Pending */ }
    });
    this.dispatchEvent(event);
  }
  reject() {
    this.status = "rejected" /* Rejected */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "rejected" /* Rejected */ }
    });
    this.dispatchEvent(event);
  }
  tryReject() {
    const shouldReject = this.getAllDependencies().every((dependency) => {
      if (dependency.status === "rejected" /* Rejected */) {
        if (this.cannoliGraph.isEdge(dependency)) {
          let redundantNotRejected = false;
          for (const otherDependency of this.getAllDependencies()) {
            if (this.cannoliGraph.isEdge(otherDependency) && otherDependency.text === dependency.text && otherDependency.status !== "rejected" /* Rejected */) {
              redundantNotRejected = true;
              break;
            }
          }
          if (redundantNotRejected) {
            return true;
          }
        }
        return false;
      }
      return true;
    });
    if (!shouldReject) {
      this.reject();
    }
  }
  ensureStringLength(str3, maxLength) {
    if (str3.length > maxLength) {
      return str3.substring(0, maxLength - 3) + "...";
    } else {
      return str3;
    }
  }
  reset() {
    this.status = "pending" /* Pending */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "pending" /* Pending */ }
    });
    this.dispatchEvent(event);
  }
  dependencyRejected(dependency) {
    this.tryReject();
  }
  dependencyCompleted(dependency) {
  }
  dependencyExecuting(dependency) {
  }
  async execute() {
  }
  logDetails() {
    let dependenciesString = "";
    for (const dependency of this.dependencies) {
      dependenciesString += `	"${this.graph[dependency].text}"
`;
    }
    return `Dependencies:
${dependenciesString}
`;
  }
  validate() {
  }
};
var CannoliVertex = class extends CannoliObject {
  // Sorted from immediate parent to most distant
  constructor(vertexData) {
    super(vertexData);
    this.outgoingEdges = vertexData.cannoliData.outgoingEdges;
    this.incomingEdges = vertexData.cannoliData.incomingEdges;
    this.groups = vertexData.cannoliData.groups;
  }
  getOutgoingEdges() {
    return this.outgoingEdges.map(
      (edge) => this.graph[edge]
    );
  }
  getIncomingEdges() {
    return this.incomingEdges.map(
      (edge) => this.graph[edge]
    );
  }
  getGroups() {
    return this.groups.map((group) => this.graph[group]);
  }
  createRectangle(x, y, width, height) {
    return {
      x,
      y,
      width,
      height,
      x_right: x + width,
      y_bottom: y + height
    };
  }
  encloses(a, b) {
    return a.x <= b.x && a.y <= b.y && a.x_right >= b.x_right && a.y_bottom >= b.y_bottom;
  }
  overlaps(a, b) {
    const horizontalOverlap = a.x < b.x_right && a.x_right > b.x;
    const verticalOverlap = a.y < b.y_bottom && a.y_bottom > b.y;
    const overlap = horizontalOverlap && verticalOverlap;
    return overlap && !this.encloses(a, b) && !this.encloses(b, a);
  }
  error(message) {
    this.status = "error" /* Error */;
    const event = new CustomEvent("update", {
      detail: {
        obj: this,
        status: "error" /* Error */,
        message
      }
    });
    this.dispatchEvent(event);
    console.error(message);
  }
  warning(message) {
    this.status = "warning" /* Warning */;
    const event = new CustomEvent("update", {
      detail: {
        obj: this,
        status: "warning" /* Warning */,
        message
      }
    });
    this.dispatchEvent(event);
    console.error(message);
  }
  validate() {
    super.validate();
  }
};

// src/models/group.ts
var CannoliGroup = class extends CannoliVertex {
  constructor(groupData) {
    var _a2, _b;
    super(groupData);
    this.members = groupData.cannoliData.members;
    this.maxLoops = (_a2 = groupData.cannoliData.maxLoops) != null ? _a2 : 1;
    this.currentLoop = (_b = groupData.cannoliData.currentLoop) != null ? _b : 0;
  }
  getMembers() {
    return this.members.map(
      (member) => this.graph[member]
    );
  }
  getCrossingAndInternalEdges() {
    const crossingInEdges = [];
    const crossingOutEdges = [];
    const internalEdges = [];
    for (const member of this.members) {
      const memberObject = this.graph[member];
      if (this.cannoliGraph.isNode(memberObject) || this.cannoliGraph.isGroup(memberObject)) {
        for (const edge of memberObject.incomingEdges) {
          const edgeObject = this.graph[edge];
          if (this.cannoliGraph.isEdge(edgeObject)) {
            if (edgeObject.crossingInGroups.includes(this.id)) {
              crossingInEdges.push(edgeObject);
            } else {
              internalEdges.push(edgeObject);
            }
          }
        }
        for (const edge of memberObject.outgoingEdges) {
          const edgeObject = this.graph[edge];
          if (this.cannoliGraph.isEdge(edgeObject)) {
            if (edgeObject.crossingOutGroups.includes(this.id)) {
              crossingOutEdges.push(edgeObject);
            } else {
              internalEdges.push(edgeObject);
            }
          }
        }
      }
    }
    return {
      crossingInEdges,
      crossingOutEdges,
      internalEdges
    };
  }
  allMembersCompleteOrRejected() {
    for (const member of this.members) {
      if (this.graph[member].status !== "complete" /* Complete */ && this.graph[member].status !== "rejected" /* Rejected */) {
        return false;
      }
    }
    return true;
  }
  allDependenciesCompleteOrRejected() {
    for (const dependency of this.dependencies) {
      if (this.graph[dependency].status !== "complete" /* Complete */ && this.graph[dependency].status !== "rejected" /* Rejected */) {
        return false;
      }
    }
    return true;
  }
  async execute() {
    this.status = "complete" /* Complete */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "complete" /* Complete */ }
    });
    this.dispatchEvent(event);
  }
  membersFinished() {
  }
  dependencyCompleted(dependency) {
    if (this.status === "executing" /* Executing */) {
      if (this.allDependenciesCompleteOrRejected()) {
        this.membersFinished();
      }
    }
  }
  dependencyExecuting(dependency) {
    if (this.status === "pending" /* Pending */) {
      this.execute();
    }
  }
  dependencyRejected(dependency) {
    if (this.noEdgeDependenciesRejected()) {
      return;
    } else {
      this.reject();
    }
  }
  noEdgeDependenciesRejected() {
    for (const dependency of this.dependencies) {
      if (this.graph[dependency].kind === "edge") {
        if (this.graph[dependency].status === "rejected" /* Rejected */) {
          return false;
        }
      }
    }
    return true;
  }
  anyReflexiveEdgesComplete() {
    for (const edge of this.incomingEdges) {
      const edgeObject = this.graph[edge];
      if (edgeObject.isReflexive && edgeObject.status === "complete" /* Complete */) {
        return true;
      }
    }
    return false;
  }
  logDetails() {
    let groupsString = "";
    groupsString += `Groups: `;
    for (const group of this.groups) {
      groupsString += `
	-"${this.ensureStringLength(
        this.graph[group].text,
        15
      )}"`;
    }
    let membersString = "";
    membersString += `Members: `;
    for (const member of this.members) {
      membersString += `
	-"${this.ensureStringLength(
        this.graph[member].text,
        15
      )}"`;
    }
    let incomingEdgesString = "";
    incomingEdgesString += `Incoming Edges: `;
    for (const edge of this.incomingEdges) {
      incomingEdgesString += `
	-"${this.ensureStringLength(
        this.graph[edge].text,
        15
      )}"`;
    }
    let outgoingEdgesString = "";
    outgoingEdgesString += `Outgoing Edges: `;
    for (const edge of this.outgoingEdges) {
      outgoingEdgesString += `
	-"${this.ensureStringLength(
        this.graph[edge].text,
        15
      )}"`;
    }
    return `[::] Group ${this.id} Text: "${this.text}"
${incomingEdgesString}
${outgoingEdgesString}
${groupsString}
${membersString}
` + super.logDetails();
  }
  checkOverlap() {
    const currentGroupRectangle = this.createRectangle(
      this.canvasData.x,
      this.canvasData.y,
      this.canvasData.width,
      this.canvasData.height
    );
    for (const objectKey in this.graph) {
      const object = this.graph[objectKey];
      if (object instanceof CannoliVertex) {
        if (object === this)
          continue;
        const objectRectangle = this.createRectangle(
          object.canvasData.x,
          object.canvasData.y,
          object.canvasData.width,
          object.canvasData.height
        );
        if (this.overlaps(objectRectangle, currentGroupRectangle)) {
          this.error(
            `This group overlaps with another object. Please ensure objects fully enclose their members.`
          );
          return;
        }
      }
    }
  }
  validateExitingAndReenteringPaths() {
    const visited = /* @__PURE__ */ new Set();
    const dfs = (vertex, hasLeftGroup) => {
      visited.add(vertex);
      for (const edge of vertex.getOutgoingEdges()) {
        const targetVertex = edge.getTarget();
        const isTargetInsideGroup = targetVertex.getGroups().includes(this);
        if (hasLeftGroup && isTargetInsideGroup) {
          this.error(
            `A path leaving this group and re-enters it, this would cause deadlock.`
          );
          return;
        }
        if (!visited.has(targetVertex)) {
          dfs(targetVertex, hasLeftGroup || !isTargetInsideGroup);
        }
      }
    };
    const members = this.getMembers();
    for (const member of members) {
      if (!visited.has(member)) {
        dfs(member, false);
      }
    }
  }
  validate() {
    super.validate();
    this.validateExitingAndReenteringPaths();
    this.checkOverlap();
  }
};
var ForEachGroup = class extends CannoliGroup {
  constructor(forEachData) {
    super(forEachData);
  }
  logDetails() {
    return super.logDetails() + `Type: ForEach
Index: ${this.currentLoop}
`;
  }
  async execute() {
    this.status = "executing" /* Executing */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "executing" /* Executing */ }
    });
    this.dispatchEvent(event);
  }
  dependencyCompleted(dependency) {
    if (this.status === "executing" /* Executing */) {
      if (this.allMembersCompleteOrRejected()) {
        this.completed();
      }
    }
  }
  validate() {
    super.validate();
  }
};
var RepeatGroup = class extends CannoliGroup {
  constructor(groupData) {
    var _a2, _b;
    super(groupData);
    this.currentLoop = (_a2 = groupData.cannoliData.currentLoop) != null ? _a2 : 0;
    this.maxLoops = (_b = groupData.cannoliData.maxLoops) != null ? _b : 1;
  }
  async execute() {
    this.status = "executing" /* Executing */;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: "executing" /* Executing */ }
    });
    this.dispatchEvent(event);
  }
  resetMembers() {
    for (const member of this.getMembers()) {
      member.reset();
      for (const edge of member.outgoingEdges) {
        const edgeObject = this.graph[edge];
        if (edgeObject.getTarget() !== this) {
          edgeObject.reset();
        }
      }
    }
  }
  membersFinished() {
    if (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this.currentLoop < this.maxLoops - 1 && this.allEdgeDependenciesComplete()
    ) {
      this.currentLoop++;
      if (!this.run.isMock) {
        setTimeout(() => {
          this.resetMembers();
          this.executeMembers();
        }, 20);
      } else {
        this.resetMembers();
        this.executeMembers();
      }
    } else {
      this.status = "complete" /* Complete */;
      const event = new CustomEvent("update", {
        detail: { obj: this, status: "complete" /* Complete */ }
      });
      this.dispatchEvent(event);
    }
  }
  executeMembers() {
    for (const member of this.getMembers()) {
      member.dependencyCompleted(this);
    }
  }
  reset() {
    super.reset();
    this.currentLoop = 0;
  }
  logDetails() {
    return super.logDetails() + `Type: Repeat
Max Loops: ${this.maxLoops}
`;
  }
  validate() {
    super.validate();
    if (this.maxLoops === null) {
      this.error(
        `Repeat groups loops must have a valid number in their label. Please ensure the label is a positive integer.`
      );
    }
    const listOrCategoryEdges = this.incomingEdges.filter(
      (edge) => this.graph[edge].type === "list" /* List */ || this.graph[edge].type === "category" /* Category */
    );
    if (listOrCategoryEdges.length !== 0) {
      this.error(
        `Repeat groups can't have incoming edges of type list or category.`
      );
    }
    if (this.outgoingEdges.length !== 0) {
      this.error(`Repeat groups can't have any outgoing edges.`);
    }
  }
};

// src/models/edge.ts
var CannoliEdge = class extends CannoliObject {
  constructor(edgeData) {
    super(edgeData);
    this.source = edgeData.fromNode;
    this.target = edgeData.toNode;
    this.crossingInGroups = edgeData.cannoliData.crossingInGroups;
    this.crossingOutGroups = edgeData.cannoliData.crossingOutGroups;
    this.isReflexive = edgeData.cannoliData.isReflexive;
    this.addMessages = edgeData.cannoliData.addMessages;
    this.vaultModifier = edgeData.cannoliData.vaultModifier ? edgeData.cannoliData.vaultModifier : null;
    this.content = edgeData.cannoliData.content ? edgeData.cannoliData.content : null;
    this.messages = edgeData.cannoliData.messages ? edgeData.cannoliData.messages : null;
    if (this.type === "chat" /* Chat */ || this.type === "system-message" /* SystemMessage */ || this.type === "chat-response" /* ChatResponse */ || this.type === "chat-converter" /* ChatConverter */) {
      this.addMessages = true;
    }
  }
  getSource() {
    return this.graph[this.source];
  }
  getTarget() {
    return this.graph[this.target];
  }
  load({
    content,
    request
  }) {
    this.content = content !== null && content !== void 0 ? content : null;
    if (this.addMessages) {
      this.messages = request && request.messages ? request.messages : null;
    }
  }
  async execute() {
    this.completed();
  }
  dependencyCompleted(dependency) {
    if (this.allDependenciesComplete() && this.status === "pending" /* Pending */) {
      this.execute();
    }
  }
  logDetails() {
    var _a2, _b, _c;
    let crossingGroupsString = "";
    crossingGroupsString += `Crossing Out Groups: `;
    for (const group of this.crossingOutGroups) {
      crossingGroupsString += `
	-"${this.ensureStringLength(
        this.graph[group].text,
        15
      )}"`;
    }
    crossingGroupsString += `
Crossing In Groups: `;
    for (const group of this.crossingInGroups) {
      crossingGroupsString += `
	-"${this.ensureStringLength(
        this.graph[group].text,
        15
      )}"`;
    }
    return `--> Edge ${this.id} Text: "${(_a2 = this.text) != null ? _a2 : "undefined string"}"
"${this.ensureStringLength(
      (_b = this.getSource().text) != null ? _b : "undefined string",
      15
    )}--->"${this.ensureStringLength(
      (_c = this.getTarget().text) != null ? _c : "undefined string",
      15
    )}"
${crossingGroupsString}
isReflexive: ${this.isReflexive}
Type: ${this.type}
` + super.logDetails();
  }
  reset() {
    if (!this.isReflexive) {
      super.reset();
    }
  }
};
var ChatConverterEdge = class extends CannoliEdge {
  load({
    content,
    request
  }) {
    const format = this.run.cannoli.settings.chatFormatString;
    const messageString = "";
    let messages = [];
    if (content && format) {
      messages = this.stringToArray(content, format);
    } else {
      throw new Error(
        "Chat converter edge was loaded without a content or messages"
      );
    }
    this.content = messageString;
    this.messages = messages;
  }
  stringToArray(str3, format) {
    const rolePattern = format.replace("{{role}}", "(System|User|Assistant)").replace("{{content}}", "").trim();
    const regex = new RegExp(rolePattern, "g");
    let match;
    let messages = [];
    let lastIndex = 0;
    let firstMatch = true;
    while ((match = regex.exec(str3)) !== null) {
      const [, role] = match;
      if (firstMatch && match.index > 0) {
        messages.push({
          role: "user",
          content: str3.substring(0, match.index).trim()
        });
      }
      firstMatch = false;
      const start = regex.lastIndex;
      let end;
      const nextMatch = regex.exec(str3);
      if (nextMatch) {
        end = nextMatch.index;
      } else {
        end = str3.length;
      }
      regex.lastIndex = start;
      const content = str3.substring(start, end).trim();
      const uncapRole = role.charAt(0).toLowerCase() + role.slice(1);
      messages.push({
        role: uncapRole,
        content
      });
      lastIndex = end;
    }
    if (messages.length === 0) {
      messages.push({
        role: "user",
        content: str3.trim()
      });
      return messages;
    }
    if (lastIndex < str3.length - 1) {
      messages.push({
        role: "user",
        content: str3.substring(lastIndex).trim()
      });
    }
    if (this.text.length > 0) {
      messages = this.limitMessages(messages);
    }
    return messages;
  }
  limitMessages(messages) {
    let isTokenBased = false;
    let originalText = this.text;
    if (originalText.startsWith("#")) {
      isTokenBased = true;
      originalText = originalText.substring(1);
    }
    const limitValue = Number(originalText);
    if (isNaN(limitValue) || limitValue < 0) {
      return messages;
    }
    let outputMessages;
    if (isTokenBased) {
      const maxCharacters = limitValue * 4;
      let totalCharacters = 0;
      let index = 0;
      for (let i = messages.length - 1; i >= 0; i--) {
        const message = messages[i];
        if (message.content) {
          totalCharacters += message.content.length;
        }
        if (totalCharacters > maxCharacters) {
          index = i + 1;
          break;
        }
      }
      outputMessages = messages.slice(index);
    } else {
      outputMessages = messages.slice(-Math.max(limitValue, 1));
    }
    if (outputMessages.length === 0 && messages.length > 0) {
      outputMessages = [messages[messages.length - 1]];
    }
    return outputMessages;
  }
};
var ChatResponseEdge = class extends CannoliEdge {
  constructor() {
    super(...arguments);
    this.beginningOfStream = true;
  }
  load({
    content,
    request
  }) {
    const format = this.run.cannoli.settings.chatFormatString;
    if (!format) {
      throw new Error(
        "Chat response edge was loaded without a format string"
      );
    }
    if (content && typeof content === "string") {
      if (!this.beginningOfStream) {
        if (content === "END OF STREAM") {
          const userTemplate = format.replace("{{role}}", "User").replace("{{content}}", "");
          this.content = "\n\n" + userTemplate;
        } else {
          this.content = content;
        }
      } else {
        const assistantTemplate = format.replace("{{role}}", "Assistant").replace("{{content}}", content);
        this.content = "\n\n" + assistantTemplate;
        this.beginningOfStream = false;
      }
      this.execute();
    }
  }
};
var SystemMessageEdge = class extends CannoliEdge {
  load({
    content,
    request
  }) {
    if (content) {
      this.messages = [
        {
          role: "system",
          content
        }
      ];
    }
  }
};
var LoggingEdge = class extends CannoliEdge {
  load({
    content,
    request
  }) {
    let configString = null;
    let messages = [];
    if (request) {
      configString = this.getConfigString(request);
      messages = request.messages ? request.messages : [];
    } else {
      throw new Error(
        "Logging edge was loaded without a request, this should never happen"
      );
    }
    let logs = "";
    const repeatLoopNumbers = this.getLoopNumbers();
    const loopHeader = this.formatLoopHeader(repeatLoopNumbers);
    const forEachVersionNumbers = this.getForEachVersionNumbers();
    const versionHeader = this.formatVersionHeader(forEachVersionNumbers);
    if (repeatLoopNumbers.length > 0) {
      logs = `${loopHeader}
`;
    }
    if (forEachVersionNumbers.length > 0) {
      logs = `${logs}${versionHeader}
`;
    }
    if (messages !== void 0) {
      logs = `${logs}${this.formatInteractionHeaders(messages)}`;
    }
    if (configString !== null) {
      logs = `${logs}
#### Config
${configString}
`;
    }
    if (this.content !== null) {
      this.content = `${this.content}
${logs}`;
    } else {
      this.content = logs;
    }
  }
  getConfigString(request) {
    let configString = "";
    for (const key in request) {
      if (key !== "messages" && request[key]) {
        configString += `${key}: ${request[key]}
`;
      }
    }
    return configString;
  }
  getLoopNumbers() {
    const repeatLoopNumbers = [];
    this.crossingOutGroups.forEach((group) => {
      const groupObject = this.graph[group];
      if (groupObject instanceof RepeatGroup) {
        repeatLoopNumbers.push(groupObject.currentLoop);
      }
    });
    repeatLoopNumbers.reverse();
    return repeatLoopNumbers;
  }
  getForEachVersionNumbers() {
    const forEachVersionNumbers = [];
    this.crossingOutGroups.forEach((group) => {
      const groupObject = this.graph[group];
      if (groupObject instanceof ForEachGroup) {
        forEachVersionNumbers.push(groupObject.currentLoop);
      }
    });
    forEachVersionNumbers.reverse();
    return forEachVersionNumbers;
  }
  formatInteractionHeaders(messages) {
    let formattedString = "";
    messages.forEach((message) => {
      const role = message.role;
      let content = message.content;
      if ("function_call" in message && message.function_call) {
        content = `Function Call: **${message.function_call.name}**
Arguments:
\`\`\`json
${message.function_call.arguments}
\`\`\``;
      }
      formattedString += `#### <u>${role.charAt(0).toUpperCase() + role.slice(1)}</u>:
${content}
`;
    });
    return formattedString.trim();
  }
  formatLoopHeader(loopNumbers) {
    let loopString = "# Loop ";
    loopNumbers.forEach((loopNumber) => {
      loopString += `${loopNumber + 1}.`;
    });
    return loopString.slice(0, -1);
  }
  formatVersionHeader(versionNumbers) {
    let versionString = "# Version ";
    versionNumbers.forEach((versionNumber) => {
      versionString += `${versionNumber}.`;
    });
    return versionString.slice(0, -1);
  }
  dependencyCompleted(dependency) {
    if (this.getSource().status === "complete" /* Complete */ && // If all forEach type groups being crossed are complete
    this.crossingOutGroups.every(
      (group) => !(this.graph[group] instanceof ForEachGroup) || this.graph[group].status === "complete" /* Complete */
    )) {
      this.execute();
    }
  }
};

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix2;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix2 = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix2)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix2 = decodeURIComponent(prefix2);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix2);
    }
    state.tagMap[handle] = prefix2;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str3) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str3)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix2 = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix2 + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// src/llm.ts
var import_obsidian = require("obsidian");

// node_modules/openai/version.mjs
var VERSION = "4.24.1";

// node_modules/openai/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request2 = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/openai/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/openai/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/openai/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/openai/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  OpenAIError: () => OpenAIError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError
});
var OpenAIError = class extends Error {
};
var APIError = class extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    const data = error;
    this.error = data;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError = class extends APIError {
};

// node_modules/openai/streaming.mjs
var Stream = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    const decoder = new SSEDecoder();
    async function* iterMessages() {
      if (!response.body) {
        controller.abort();
        throw new OpenAIError(`Attempted to iterate over a response with no body`);
      }
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse)
            yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, void 0);
            }
            yield data;
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a2;
        await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
      }
    });
  }
};
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition(str3, delimiter) {
  const index = str3.indexOf(delimiter);
  if (index !== -1) {
    return [str3.substring(0, index), delimiter, str3.substring(index + delimiter.length)];
  }
  return [str3, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/openai/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options = {}) {
  var _a2, _b, _c;
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    return new File2([blob], name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!options.type) {
    const type2 = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type2 === "string") {
      options = { ...options, type: type2 };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  if (contentType == null ? void 0 : contentType.includes("application/json")) {
    const json2 = await response.json();
    debug("response", response.status, response.url, response.headers, json2);
    return json2;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch != null ? overridenFetch : fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 })));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = {
      ...contentLength && { "Content-Length": contentLength },
      ...this.defaultHeaders(options),
      ...headers
    };
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["Content-Type"];
    }
    Object.keys(reqHeaders).forEach((key) => reqHeaders[key] === null && delete reqHeaders[key]);
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) != null ? _f : null
    };
    this.validateHeaders(reqHeaders, headers);
    return { req, url, timeout };
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
    }
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      debug("response", response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (query) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    let timeoutMillis;
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader) {
      const timeoutSeconds = parseInt(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!timeoutMillis || !Number.isInteger(timeoutMillis) || timeoutMillis <= 0 || timeoutMillis > 60 * 1e3) {
      const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo) {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryResponse: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d;
  if (typeof process !== "undefined") {
    return (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) != null ? _b : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_d = (_c = Deno.env) == null ? void 0 : _c.get) == null ? void 0 : _d.call(_c, env);
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`OpenAI:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};

// node_modules/openai/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2;
    const data = this.getPaginatedItems();
    if (!data.length) {
      return null;
    }
    const id = (_a2 = data[data.length - 1]) == null ? void 0 : _a2.id;
    if (!id) {
      return null;
    }
    return { params: { after: id } };
  }
};

// node_modules/openai/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/chat/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};
(function(Completions4) {
})(Completions || (Completions = {}));

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
(function(Chat3) {
  Chat3.Completions = Completions;
})(Chat || (Chat = {}));

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  /**
   * Generates audio from the input text.
   */
  create(body, options) {
    return this._client.post("/audio/speech", { body, ...options, __binaryResponse: true });
  }
};
(function(Speech2) {
})(Speech || (Speech = {}));

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  /**
   * Transcribes audio into the input language.
   */
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Transcriptions2) {
})(Transcriptions || (Transcriptions = {}));

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  /**
   * Translates audio into English.
   */
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Translations2) {
})(Translations || (Translations = {}));

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
(function(Audio2) {
  Audio2.Transcriptions = Transcriptions;
  Audio2.Translations = Translations;
  Audio2.Speech = Speech;
})(Audio || (Audio = {}));

// node_modules/openai/resources/beta/assistants/files.mjs
var Files = class extends APIResource {
  /**
   * Create an assistant file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to an
   * [assistant](https://platform.openai.com/docs/api-reference/assistants).
   */
  create(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}/files`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves an AssistantFile.
   */
  retrieve(assistantId, fileId, options) {
    return this._client.get(`/assistants/${assistantId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(assistantId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(assistantId, {}, query);
    }
    return this._client.getAPIList(`/assistants/${assistantId}/files`, AssistantFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete an assistant file.
   */
  del(assistantId, fileId, options) {
    return this._client.delete(`/assistants/${assistantId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
};
var AssistantFilesPage = class extends CursorPage {
};
(function(Files4) {
  Files4.AssistantFilesPage = AssistantFilesPage;
})(Files || (Files = {}));

// node_modules/openai/resources/beta/assistants/assistants.mjs
var Assistants = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
  }
  /**
   * Create an assistant with a model and instructions.
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves an assistant.
   */
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies an assistant.
   */
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete an assistant.
   */
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
};
var AssistantsPage = class extends CursorPage {
};
(function(Assistants2) {
  Assistants2.AssistantsPage = AssistantsPage;
  Assistants2.Files = Files;
  Assistants2.AssistantFilesPage = AssistantFilesPage;
})(Assistants || (Assistants = {}));

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
var isFunctionMessage = (message) => {
  return (message == null ? void 0 : message.role) === "function";
};
var isToolMessage = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_connectedPromise;
var _AbstractChatCompletionRunner_resolveConnectedPromise;
var _AbstractChatCompletionRunner_rejectConnectedPromise;
var _AbstractChatCompletionRunner_endPromise;
var _AbstractChatCompletionRunner_resolveEndPromise;
var _AbstractChatCompletionRunner_rejectEndPromise;
var _AbstractChatCompletionRunner_listeners;
var _AbstractChatCompletionRunner_ended;
var _AbstractChatCompletionRunner_errored;
var _AbstractChatCompletionRunner_aborted;
var _AbstractChatCompletionRunner_catchingPromiseCreated;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionCall;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_handleError;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class {
  constructor() {
    _AbstractChatCompletionRunner_instances.add(this);
    this.controller = new AbortController();
    _AbstractChatCompletionRunner_connectedPromise.set(this, void 0);
    _AbstractChatCompletionRunner_resolveConnectedPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_rejectConnectedPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_endPromise.set(this, void 0);
    _AbstractChatCompletionRunner_resolveEndPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_rejectEndPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_listeners.set(this, {});
    this._chatCompletions = [];
    this.messages = [];
    _AbstractChatCompletionRunner_ended.set(this, false);
    _AbstractChatCompletionRunner_errored.set(this, false);
    _AbstractChatCompletionRunner_aborted.set(this, false);
    _AbstractChatCompletionRunner_catchingPromiseCreated.set(this, false);
    _AbstractChatCompletionRunner_handleError.set(this, (error) => {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_errored, true, "f");
      if (error instanceof Error && error.name === "AbortError") {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof OpenAIError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const openAIError = new OpenAIError(error.message);
        openAIError.cause = error;
        return this._emit("error", openAIError);
      }
      return this._emit("error", new OpenAIError(String(error)));
    });
    __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_handleError, "f"));
    }, 0);
  }
  _addChatCompletion(chatCompletion) {
    var _a2;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] || (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] || (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_endPromise, "f");
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_ended, true, "f");
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(completions, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(chatCompletion);
  }
  async _runChatCompletion(completions, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(completions, params, options);
  }
  async _runFunctions(completions, params, options) {
    var _a2;
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && (function_call == null ? void 0 : function_call.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(completions, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message = (_a2 = chatCompletion.choices[0]) == null ? void 0 : _a2.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call)
        return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(completions, params, options) {
    var _a2, _b;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && ((_a2 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a2.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.tools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? params.tools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(completions, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${tools.map((f) => JSON.stringify(f.function.name)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_connectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_endPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_listeners = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_ended = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_errored = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_aborted = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_handleError = /* @__PURE__ */ new WeakMap(), _AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  var _a2;
  return (_a2 = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content) != null ? _a2 : null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  var _a2;
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      return { ...message, content: (_a2 = message.content) != null ? _a2 : null };
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  var _a2, _b;
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && (message == null ? void 0 : message.function_call)) {
      return message.function_call;
    }
    if (isAssistantMessage(message) && ((_a2 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a2.length)) {
      return (_b = message.tool_calls.at(-1)) == null ? void 0 : _b.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isFunctionMessage(message) && message.content != null) {
      return message.content;
    }
    if (isToolMessage(message) && message.content != null && this.messages.some((x) => {
      var _a2;
      return x.role === "assistant" && ((_a2 = x.tool_calls) == null ? void 0 : _a2.some((y) => y.type === "function" && y.id === message.tool_call_id));
    })) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class extends AbstractChatCompletionRunner {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(completions, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(completions, params, opts));
    return runner;
  }
  static runTools(completions, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(completions, params, opts));
    return runner;
  }
  _addMessage(message) {
    super._addMessage(message);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/lib/ChatCompletionStream.mjs
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _ChatCompletionStream_instances;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class extends AbstractChatCompletionRunner {
  constructor() {
    super(...arguments);
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(completions, params, options) {
    const runner = new ChatCompletionStream();
    runner._run(() => runner._runChatCompletion(completions, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(completions, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    var _a2, _b, _c;
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    const delta = (_b = (_a2 = chunk.choices[0]) == null ? void 0 : _a2.delta) == null ? void 0 : _b.content;
    const snapshot = (_c = completion.choices[0]) == null ? void 0 : _c.message;
    if (delta != null && (snapshot == null ? void 0 : snapshot.role) === "assistant" && (snapshot == null ? void 0 : snapshot.content)) {
      this._emit("content", delta, snapshot.content);
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    return finalizeChatCompletion(snapshot);
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a3, _b2, _c2, _d;
    var _a2, _b, _c;
    let snapshot = __classPrivateFieldGet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        snapshot.choices[index] = { finish_reason, index, message: delta, logprobs, ...other };
        continue;
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = logprobs;
        } else if (logprobs.content) {
          (_a3 = (_a2 = choice.logprobs).content) != null ? _a3 : _a2.content = [];
          choice.logprobs.content.push(...logprobs.content);
        }
      }
      if (finish_reason)
        choice.finish_reason = finish_reason;
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, function_call, role, tool_calls } = delta;
      if (content)
        choice.message.content = (choice.message.content || "") + content;
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_b2 = (_b = choice.message.function_call).arguments) != null ? _b2 : _b.arguments = "";
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type: type2, function: fn } of tool_calls) {
          const tool_call = (_c2 = (_c = choice.message.tool_calls)[index2]) != null ? _c2 : _c[index2] = {};
          if (id)
            tool_call.id = id;
          if (type2)
            tool_call.type = type2;
          if (fn)
            (_d = tool_call.function) != null ? _d : tool_call.function = { arguments: "" };
          if (fn == null ? void 0 : fn.name)
            tool_call.function.name = fn.name;
          if (fn == null ? void 0 : fn.arguments)
            tool_call.function.arguments += fn.arguments;
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader(void 0);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve) => readQueue.push(resolve)).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot) {
  const { id, choices, created, model } = snapshot;
  return {
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs }) => {
      if (!finish_reason)
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      const { content = null, function_call, tool_calls } = message;
      const role = message.role;
      if (!role)
        throw new OpenAIError(`missing role for choice ${index}`);
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null)
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        if (!name)
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        return {
          message: { content, function_call: { arguments: args, name }, role },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          index,
          finish_reason,
          logprobs,
          message: {
            role,
            content,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type: type2, id: id2 } = tool_call;
              const { arguments: args, name } = fn || {};
              if (id2 == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str2(snapshot)}`);
              if (type2 == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str2(snapshot)}`);
              if (name == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str2(snapshot)}`);
              if (args == null)
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str2(snapshot)}`);
              return { id: id2, type: type2, function: { name, arguments: args } };
            })
          }
        };
      }
      return { message: { content, role }, finish_reason, index, logprobs };
    }),
    created,
    model,
    object: "chat.completion"
  };
}
function str2(x) {
  return JSON.stringify(x);
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(completions, params, options) {
    const runner = new ChatCompletionStreamingRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(completions, params, opts));
    return runner;
  }
  static runTools(completions, params, options) {
    const runner = new ChatCompletionStreamingRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(completions, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/beta/chat/completions.mjs
var Completions2 = class extends APIResource {
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(this._client.chat.completions, body, options);
    }
    return ChatCompletionRunner.runFunctions(this._client.chat.completions, body, options);
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client.chat.completions, body, options);
    }
    return ChatCompletionRunner.runTools(this._client.chat.completions, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client.chat.completions, body, options);
  }
};

// node_modules/openai/resources/beta/chat/chat.mjs
var Chat2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
(function(Chat3) {
  Chat3.Completions = Completions2;
})(Chat2 || (Chat2 = {}));

// node_modules/openai/resources/beta/threads/messages/files.mjs
var Files2 = class extends APIResource {
  /**
   * Retrieves a message file.
   */
  retrieve(threadId, messageId, fileId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, messageId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, messageId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages/${messageId}/files`, MessageFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
};
var MessageFilesPage = class extends CursorPage {
};
(function(Files4) {
  Files4.MessageFilesPage = MessageFilesPage;
})(Files2 || (Files2 = {}));

// node_modules/openai/resources/beta/threads/messages/messages.mjs
var Messages = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files2(this._client);
  }
  /**
   * Create a message.
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieve a message.
   */
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a message.
   */
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages`, ThreadMessagesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
};
var ThreadMessagesPage = class extends CursorPage {
};
(function(Messages2) {
  Messages2.ThreadMessagesPage = ThreadMessagesPage;
  Messages2.Files = Files2;
  Messages2.MessageFilesPage = MessageFilesPage;
})(Messages || (Messages = {}));

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
  /**
   * Retrieves a run step.
   */
  retrieve(threadId, runId, stepId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
};
var RunStepsPage = class extends CursorPage {
};
(function(Steps2) {
  Steps2.RunStepsPage = RunStepsPage;
})(Steps || (Steps = {}));

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  /**
   * Create a run.
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/runs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a run.
   */
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a run.
   */
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   */
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * When a run has the `status: "requires_action"` and `required_action.type` is
   * `submit_tool_outputs`, this endpoint can be used to submit the outputs from the
   * tool calls once they're all completed. All outputs must be submitted in a single
   * request.
   */
  submitToolOutputs(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
};
var RunsPage = class extends CursorPage {
};
(function(Runs2) {
  Runs2.RunsPage = RunsPage;
  Runs2.Steps = Steps;
  Runs2.RunStepsPage = RunStepsPage;
})(Runs || (Runs = {}));

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Retrieves a thread.
   */
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Modifies a thread.
   */
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Delete a thread.
   */
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Create a thread and run it in one request.
   */
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v1", ...options == null ? void 0 : options.headers }
    });
  }
};
(function(Threads2) {
  Threads2.Runs = Runs;
  Threads2.RunsPage = RunsPage;
  Threads2.Messages = Messages;
  Threads2.ThreadMessagesPage = ThreadMessagesPage;
})(Threads || (Threads = {}));

// node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
};
(function(Beta2) {
  Beta2.Chat = Chat2;
  Beta2.Assistants = Assistants;
  Beta2.AssistantsPage = AssistantsPage;
  Beta2.Threads = Threads;
})(Beta || (Beta = {}));

// node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};
(function(Completions4) {
})(Completions3 || (Completions3 = {}));

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   */
  create(body, options) {
    return this._client.post("/embeddings", { body, ...options });
  }
};
(function(Embeddings2) {
})(Embeddings || (Embeddings = {}));

// node_modules/openai/resources/edits.mjs
var Edits = class extends APIResource {
  /**
   * Creates a new edit for the provided input, instruction, and parameters.
   *
   * @deprecated The Edits API is deprecated; please use Chat Completions instead.
   *
   * https://openai.com/blog/gpt-4-api-general-availability#deprecation-of-the-edits-api
   */
  create(body, options) {
    return this._client.post("/edits", { body, ...options });
  }
};
(function(Edits2) {
})(Edits || (Edits = {}));

// node_modules/openai/resources/files.mjs
var Files3 = class extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. The size of all the
   * files uploaded by one organization can be up to 100 GB.
   *
   * The size of individual files can be a maximum of 512 MB or 2 million tokens for
   * Assistants. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) to
   * learn more about the types of files supported. The Fine-tuning API only supports
   * `.jsonl` files.
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, { ...options, __binaryResponse: true });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/json", ...options == null ? void 0 : options.headers }
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
var FileObjectsPage = class extends Page {
};
(function(Files4) {
  Files4.FileObjectsPage = FileObjectsPage;
})(Files3 || (Files3 = {}));

// node_modules/openai/resources/fine-tunes.mjs
var FineTunes = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/legacy-fine-tuning)
   */
  create(body, options) {
    return this._client.post("/fine-tunes", { body, ...options });
  }
  /**
   * Gets info about the fine-tune job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/legacy-fine-tuning)
   */
  retrieve(fineTuneId, options) {
    return this._client.get(`/fine-tunes/${fineTuneId}`, options);
  }
  /**
   * List your organization's fine-tuning jobs
   */
  list(options) {
    return this._client.getAPIList("/fine-tunes", FineTunesPage, options);
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuneId, options) {
    return this._client.post(`/fine-tunes/${fineTuneId}/cancel`, options);
  }
  listEvents(fineTuneId, query, options) {
    var _a2;
    return this._client.get(`/fine-tunes/${fineTuneId}/events`, {
      query,
      timeout: 864e5,
      ...options,
      stream: (_a2 = query == null ? void 0 : query.stream) != null ? _a2 : false
    });
  }
};
var FineTunesPage = class extends Page {
};
(function(FineTunes2) {
  FineTunes2.FineTunesPage = FineTunesPage;
})(FineTunes || (FineTunes = {}));

// node_modules/openai/resources/fine-tuning/jobs.mjs
var Jobs = class extends APIResource {
  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   */
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   */
  cancel(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
};
var FineTuningJobsPage = class extends CursorPage {
};
var FineTuningJobEventsPage = class extends CursorPage {
};
(function(Jobs2) {
  Jobs2.FineTuningJobsPage = FineTuningJobsPage;
  Jobs2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(Jobs || (Jobs = {}));

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.jobs = new Jobs(this._client);
  }
};
(function(FineTuning2) {
  FineTuning2.Jobs = Jobs;
  FineTuning2.FineTuningJobsPage = FineTuningJobsPage;
  FineTuning2.FineTuningJobEventsPage = FineTuningJobEventsPage;
})(FineTuning || (FineTuning = {}));

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image.
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   */
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
};
(function(Images2) {
})(Images || (Images = {}));

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model, options) {
    return this._client.delete(`/models/${model}`, options);
  }
};
var ModelsPage = class extends Page {
};
(function(Models2) {
  Models2.ModelsPage = ModelsPage;
})(Models || (Models = {}));

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text violates OpenAI's Content Policy
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};
(function(Moderations2) {
})(Moderations || (Moderations = {}));

// node_modules/openai/index.mjs
var _a;
var OpenAI = class extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = ((_a2) => (_a2 = readEnv("OPENAI_ORG_ID")) != null ? _a2 : null)(), ...opts } = {}) {
    var _a3;
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      organization,
      ...opts,
      baseURL: baseURL != null ? baseURL : `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: (_a3 = options.timeout) != null ? _a3 : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.edits = new Edits(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files3(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.fineTunes = new FineTunes(this);
    this.beta = new Beta(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
var { OpenAIError: OpenAIError2, APIError: APIError2, APIConnectionError: APIConnectionError2, APIConnectionTimeoutError: APIConnectionTimeoutError2, APIUserAbortError: APIUserAbortError2, NotFoundError: NotFoundError2, ConflictError: ConflictError2, RateLimitError: RateLimitError2, BadRequestError: BadRequestError2, AuthenticationError: AuthenticationError2, InternalServerError: InternalServerError2, PermissionDeniedError: PermissionDeniedError2, UnprocessableEntityError: UnprocessableEntityError2 } = error_exports;
(function(OpenAI2) {
  OpenAI2.toFile = toFile;
  OpenAI2.fileFromPath = fileFromPath;
  OpenAI2.Page = Page;
  OpenAI2.CursorPage = CursorPage;
  OpenAI2.Completions = Completions3;
  OpenAI2.Chat = Chat;
  OpenAI2.Edits = Edits;
  OpenAI2.Embeddings = Embeddings;
  OpenAI2.Files = Files3;
  OpenAI2.FileObjectsPage = FileObjectsPage;
  OpenAI2.Images = Images;
  OpenAI2.Audio = Audio;
  OpenAI2.Moderations = Moderations;
  OpenAI2.Models = Models;
  OpenAI2.ModelsPage = ModelsPage;
  OpenAI2.FineTuning = FineTuning;
  OpenAI2.FineTunes = FineTunes;
  OpenAI2.FineTunesPage = FineTunesPage;
  OpenAI2.Beta = Beta;
})(OpenAI || (OpenAI = {}));
var openai_default = OpenAI;

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind2, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: kind2,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind2, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: kind2,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema2, params) => {
  return new ZodArray({
    type: schema2,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema2) {
  if (schema2 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema2.shape) {
      const fieldSchema = schema2.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema2._def,
      shape: () => newShape
    });
  } else if (schema2 instanceof ZodArray) {
    return new ZodArray({
      ...schema2._def,
      type: deepPartialify(schema2.element)
    });
  } else if (schema2 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodTuple) {
    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
  } else {
    return schema2;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b, _c, _d;
          const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema2) {
    return this.augment({ [key]: schema2 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type2) => {
  if (type2 instanceof ZodLazy) {
    return getDiscriminator(type2.schema);
  } else if (type2 instanceof ZodEffects) {
    return getDiscriminator(type2.innerType());
  } else if (type2 instanceof ZodLiteral) {
    return [type2.value];
  } else if (type2 instanceof ZodEnum) {
    return type2.options;
  } else if (type2 instanceof ZodNativeEnum) {
    return Object.keys(type2.enum);
  } else if (type2 instanceof ZodDefault) {
    return getDiscriminator(type2._def.innerType);
  } else if (type2 instanceof ZodUndefined) {
    return [void 0];
  } else if (type2 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type2 of options) {
      const discriminatorValues = getDiscriminator(type2.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type2);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema2 = this._def.items[itemIndex] || this._def.rest;
      if (!schema2)
        return null;
      return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema2, params) => {
  return new ZodPromise({
    type: schema2,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema2, effect, params) => {
  return new ZodEffects({
    schema: schema2,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
  return new ZodEffects({
    schema: schema2,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type2, params) => {
  return new ZodOptional({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type2, params) => {
  return new ZodNullable({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type2, params) => {
  return new ZodDefault({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type2, params) => {
  return new ZodCatch({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type2, params) => {
  return new ZodReadonly({
    innerType: type2,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a2 = p.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/llm.ts
ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
  const reader = this.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        return;
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
};
var OllamaConfigSchema = z.object({
  model: z.string(),
  role: z.enum(["system", "user", "assistant"]).optional(),
  options: z.object({
    microstat: z.number().optional().nullable(),
    microstat_eta: z.number().optional().nullable(),
    microstat_tau: z.number().optional().nullable(),
    num_ctx: z.number().optional().nullable(),
    num_gqa: z.number().optional().nullable(),
    num_gpu: z.number().optional().nullable(),
    num_thread: z.number().optional().nullable(),
    repeat_last_n: z.number().optional().nullable(),
    repeat_penalty: z.number().optional().nullable(),
    temperature: z.number().optional().nullable(),
    seed: z.number().optional().nullable(),
    stop: z.union([
      z.array(z.string()),
      z.string().optional().nullable()
    ]),
    tfs_z: z.number().optional().nullable(),
    num_predict: z.number().optional().nullable(),
    top_k: z.number().optional().nullable(),
    top_p: z.number().optional().nullable()
  }).optional()
});
var FlattenedOllamaConfigSchema = OllamaConfigSchema.transform(
  ({ options, ...s }) => ({
    ...s,
    ...options
  })
);
var OpenAIConfigSchema = z.object({
  model: z.string(),
  role: z.enum(["system", "user", "assistant"]).optional(),
  frequency_penalty: z.number().optional().nullable(),
  presence_penalty: z.number().optional().nullable(),
  stop: z.union([z.array(z.string()), z.string(), z.null(), z.undefined()]).optional().nullable(),
  function_call: z.union([
    z.literal("none"),
    z.literal("auto"),
    z.object({ name: z.string() })
  ]).optional(),
  functions: z.array(
    z.object({
      name: z.string(),
      description: z.string().optional(),
      parameters: z.record(z.unknown()).optional()
    })
  ).optional(),
  temperature: z.number().optional().nullable(),
  top_p: z.number().optional().nullable()
});
var LLMConfigSchema = z.intersection(
  OpenAIConfigSchema,
  FlattenedOllamaConfigSchema
);
var transformLLMConfigIntoOpenAIConfig = (llmConfig) => {
  return OpenAIConfigSchema.parse(llmConfig);
};
var transformLLMConfigIntoOllamaConfig = (llmConfig) => {
  return OllamaConfigSchema.parse(
    LLMConfigSchema.transform((c) => {
      return {
        ...c,
        options: {
          microstat: c.microstat,
          microstat_eta: c.microstat_eta,
          microstat_tau: c.microstat_tau,
          num_ctx: c.num_ctx,
          num_gqa: c.num_gqa,
          num_gpu: c.num_gpu,
          num_thread: c.num_thread,
          repeat_last_n: c.repeat_last_n,
          repeat_penalty: c.repeat_penalty,
          temperature: c.temperature,
          seed: c.seed,
          stop: c.stop,
          tfs_z: c.tfs_z,
          num_predict: c.num_predict,
          top_k: c.top_k,
          top_p: c.top_p
        }
      };
    }).parse(llmConfig)
  );
};
var makeSampleOpenAIConfig = () => ({
  model: "",
  frequency_penalty: void 0,
  presence_penalty: void 0,
  stop: void 0,
  function_call: void 0,
  functions: void 0,
  temperature: void 0,
  top_p: void 0,
  role: "user"
});
var makeSampleOllamaConfig = () => ({
  model: "",
  microstat: void 0,
  microstat_eta: void 0,
  microstat_tau: void 0,
  num_ctx: void 0,
  num_gqa: void 0,
  num_gpu: void 0,
  num_thread: void 0,
  repeat_last_n: void 0,
  repeat_penalty: void 0,
  temperature: void 0,
  seed: void 0,
  stop: void 0,
  tfs_z: void 0,
  num_predict: void 0,
  top_k: void 0,
  top_p: void 0
});
var Llm = class {
  constructor({
    provider,
    ollamaConfig,
    openaiConfig
  }) {
    this.initialized = false;
    this.provider = provider;
    switch (provider) {
      case "openai": {
        if (!openaiConfig) {
          throw new Error("OpenAI config is required");
        }
        const { apiKey, ...restConfig } = openaiConfig;
        this.openaiConfig = restConfig;
        this.openai = new openai_default({
          apiKey,
          dangerouslyAllowBrowser: true
        });
        this.initialized = true;
        break;
      }
      case "ollama": {
        if (!ollamaConfig) {
          throw new Error("Ollama config is required");
        }
        const { baseURL, ...restConfig } = ollamaConfig;
        this.ollamaBaseURL = baseURL;
        this.ollamaConfig = restConfig;
        this.initialized = true;
        break;
      }
      default: {
        throw new Error("Invalid LLM provider");
      }
    }
  }
  getConfig() {
    if (this.provider === "openai") {
      return this.openaiConfig;
    } else if (this.provider === "ollama") {
      return this.ollamaConfig;
    } else {
      throw new Error("Invalid LLM provider");
    }
  }
  getSampleConfig() {
    if (this.provider === "openai") {
      return makeSampleOpenAIConfig();
    } else if (this.provider === "ollama") {
      return makeSampleOllamaConfig();
    } else {
      throw new Error("Invalid LLM provider");
    }
  }
  async getCompletion({
    messages,
    ...llmConfig
  }) {
    if (this.provider === "openai") {
      if (!this.openai) {
        throw new Error("OpenAI is not initialized");
      }
      const openaiConfig = transformLLMConfigIntoOpenAIConfig(llmConfig);
      return await this.openai.chat.completions.create(
        {
          messages,
          ...openaiConfig
        },
        { stream: false }
      );
    } else if (this.provider === "ollama") {
      invariant(this.ollamaBaseURL, "Ollama base URL is required");
      const ollamaConfig = transformLLMConfigIntoOllamaConfig(llmConfig);
      const rawBody = {
        messages: messages.filter(
          (m) => m.role !== "function"
        ),
        ...ollamaConfig,
        stream: false
      };
      const options = {
        url: `${this.ollamaBaseURL}/api/chat`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(rawBody)
      };
      const response = await (0, import_obsidian.requestUrl)(options);
      return response.json;
    } else {
      throw new Error("Invalid LLM provider");
    }
  }
  async getCompletionStream({
    messages,
    ...llmConfig
  }) {
    if (this.provider === "openai") {
      if (!this.openai) {
        throw new Error("OpenAI is not initialized");
      }
      const openaiConfig = transformLLMConfigIntoOpenAIConfig(llmConfig);
      return this.openai.chat.completions.create({
        messages,
        ...openaiConfig,
        stream: true
      });
    } else if (this.provider === "ollama") {
      invariant(this.ollamaBaseURL, "Ollama baseUrl is required");
      const ollamaConfig = transformLLMConfigIntoOllamaConfig(llmConfig);
      const rawBody = {
        messages: messages.filter(
          (m) => m.role !== "function"
        ),
        ...ollamaConfig,
        stream: true
      };
      const options = {
        url: `${this.ollamaBaseURL}/api/chat`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(rawBody)
      };
      const response = await fetch(options.url, options);
      return response.body;
    }
    return new Error("Provider does not support streaming");
  }
  static getFirstCompletionMessage(completionResponse) {
    if ("choices" in completionResponse) {
      return completionResponse.choices[0].message;
    } else if ("message" in completionResponse) {
      return completionResponse.message;
    } else {
      throw new Error("Invalid LLM provider");
    }
  }
  static getFirstStreamingCompletionMessageDelta(streamingCompletionChunk) {
    if ("choices" in streamingCompletionChunk) {
      return streamingCompletionChunk.choices[0].delta.content;
    } else if ("message" in streamingCompletionChunk) {
      return streamingCompletionChunk.message.content;
    } else {
      throw new Error("Invalid LLM provider");
    }
  }
  getPart(rawPart) {
    if (this.provider === "openai") {
      return rawPart;
    }
    const decoder = new TextDecoder("utf-8");
    const decodedPart = decoder.decode(rawPart);
    return JSON.parse(decodedPart);
  }
  static getStreamingCompletionFinished(streamingCompletionResponse) {
    if ("done" in streamingCompletionResponse) {
      return streamingCompletionResponse.done;
    } else if ("choices" in streamingCompletionResponse) {
      return !!streamingCompletionResponse.choices[0].finish_reason;
    }
    return true;
  }
  static getCompletionResponseUsage(completionResponse) {
    if ("usage" in completionResponse) {
      return completionResponse.usage;
    }
    return void 0;
  }
};

// src/models/node.ts
var CannoliNode = class extends CannoliVertex {
  constructor(nodeData) {
    super(nodeData);
    this.references = [];
    this.references = nodeData.cannoliData.references || [];
    this.renderFunction = this.buildRenderFunction();
  }
  buildRenderFunction() {
    let textCopy = this.text;
    let index = 0;
    textCopy = textCopy.replace(/\{\{[^{}]+\}\}/g, () => `{{${index++}}}`);
    const renderFunction = async (variables) => {
      textCopy = await this.processEmbeds(textCopy);
      const varMap = new Map(variables.map((v) => [v.name, v.content]));
      return textCopy.replace(/\{\{(\d+)\}\}/g, (match, index2) => {
        const reference = this.references[Number(index2)];
        return varMap.get(reference.name) || "{{invalid}}";
      });
    };
    return renderFunction;
  }
  async processEmbeds(content) {
    const embeddedNotes = content.match(/!\[\[[\s\S]*?\]\]/g);
    if (embeddedNotes) {
      for (const embeddedNote of embeddedNotes) {
        let noteName = embeddedNote.replace("![[", "").replace("]]", "");
        let subpath;
        if (noteName.includes("|")) {
          noteName = noteName.split("|")[0];
        }
        if (noteName.includes("#")) {
          const split = noteName.split("#");
          noteName = split[0];
          subpath = split[1];
        }
        const noteContent = await this.run.getNote({
          name: noteName,
          type: "note" /* Note */,
          shouldExtract: true,
          includeName: true,
          subpath
        });
        if (noteContent) {
          const blockquotedNoteContent = "> " + noteContent.replace(/\n/g, "\n> ");
          content = content.replace(
            embeddedNote,
            blockquotedNoteContent
          );
        }
      }
    }
    return content;
  }
  async getContentFromNote(reference) {
    const note = await this.run.getNote(reference);
    if (note === null) {
      return null;
    }
    return note;
  }
  getContentFromFloatingNode(name) {
    for (const object of Object.values(this.graph)) {
      if (object instanceof FloatingNode && object.getName() === name) {
        return object.getContent();
      }
    }
    return null;
  }
  async processReferences() {
    const variableValues = this.getVariableValues(true);
    const resolvedReferences = await Promise.all(
      this.references.map(async (reference) => {
        let content = "{{invalid reference}}";
        const { name } = reference;
        if ((reference.type === "variable" /* Variable */ || reference.type === "selection" /* Selection */) && !reference.shouldExtract) {
          const variable = variableValues.find(
            (variable2) => variable2.name === reference.name
          );
          if (variable) {
            content = variable.content;
          } else if (reference.name.match(/^#+$/)) {
            const depth = reference.name.length - 1;
            const loopIndex = this.getLoopIndex(depth);
            if (loopIndex !== null) {
              content = loopIndex.toString();
            } else {
              content = `{{${reference.name}}}`;
            }
          } else {
            content = `{{${reference.name}}}`;
          }
        } else if ((reference.type === "variable" /* Variable */ || reference.type === "selection" /* Selection */) && reference.shouldExtract) {
          const variable = variableValues.find(
            (variable2) => variable2.name === reference.name
          );
          if (variable && variable.content) {
            const originalName = reference.name;
            reference.name = variable.content;
            const noteContent = await this.getContentFromNote(
              reference
            );
            reference.name = originalName;
            if (noteContent) {
              content = noteContent;
            } else {
              this.warning(
                `Note "${variable.content}" not found`
              );
              content = `{{@${reference.name}}}`;
            }
          } else {
            content = `{{@${reference.name}}}`;
          }
        } else if (reference.type === "note" /* Note */) {
          if (reference.shouldExtract) {
            const noteContent = await this.getContentFromNote(
              reference
            );
            if (noteContent) {
              content = noteContent;
            } else {
              this.warning(`Note "${reference.name}" not found`);
              content = `{{${reference.name}}}`;
            }
          } else {
            content = reference.name;
          }
        } else if (reference.type === "floating" /* Floating */) {
          if (reference.shouldExtract) {
            const floatingContent = this.getContentFromFloatingNode(
              reference.name
            );
            if (floatingContent) {
              content = floatingContent;
            } else {
              this.warning(`Floating node "${name}" not found`);
              content = `{{[${reference.name}]}}`;
            }
          }
        }
        return { name, content };
      })
    );
    return this.renderFunction(resolvedReferences);
  }
  getLoopIndex(depth) {
    const group = this.graph[this.groups[depth]];
    if (!group) {
      return null;
    }
    if (!(group instanceof CannoliGroup)) {
      return null;
    }
    if (group.type !== "repeat" /* Repeat */ && group.type !== "for-each" /* ForEach */) {
      return null;
    }
    const loopIndex = group.currentLoop + 1;
    return loopIndex;
  }
  getVariableValues(includeGroupEdges) {
    const variableValues = [];
    let availableEdges = this.getAllAvailableProvideEdges();
    if (!includeGroupEdges) {
      availableEdges = availableEdges.filter(
        (edge) => this.incomingEdges.includes(edge.id)
      );
    }
    for (const edge of availableEdges) {
      const edgeObject = this.graph[edge.id];
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error on object ${edgeObject.id}: object is not a provide edge.`
        );
      }
      if (!(edgeObject.status === "complete" /* Complete */)) {
        if (!(edgeObject.status === "rejected" /* Rejected */) || !edgeObject.isReflexive || edgeObject.content === null) {
          continue;
        }
      }
      let content;
      if (edgeObject.content === null) {
        continue;
      }
      if (typeof edgeObject.content === "string" && edgeObject.text) {
        content = edgeObject.content;
        const variableValue = {
          name: edgeObject.text,
          content,
          edgeId: edgeObject.id
        };
        variableValues.push(variableValue);
      } else if (typeof edgeObject.content === "object" && !Array.isArray(edgeObject.content)) {
        const multipleVariableValues = [];
        for (const name in edgeObject.content) {
          const variableValue = {
            name,
            content: edgeObject.content[name],
            edgeId: edgeObject.id
          };
          multipleVariableValues.push(variableValue);
        }
        variableValues.push(...multipleVariableValues);
      } else {
        continue;
      }
    }
    if (this.run.currentNote && includeGroupEdges) {
      const currentNoteVariableValue = {
        name: "NOTE",
        content: this.run.currentNote,
        edgeId: ""
      };
      variableValues.push(currentNoteVariableValue);
    }
    if (this.run.selection && includeGroupEdges) {
      const currentSelectionVariableValue = {
        name: "SELECTION",
        content: this.run.selection,
        edgeId: ""
      };
      variableValues.push(currentSelectionVariableValue);
    }
    const resolvedVariableValues = this.resolveVariableConflicts(variableValues);
    return resolvedVariableValues;
  }
  resolveVariableConflicts(variableValues) {
    const finalVariables = [];
    const groupedByName = {};
    for (const variable of variableValues) {
      if (!groupedByName[variable.name]) {
        groupedByName[variable.name] = [];
      }
      groupedByName[variable.name].push(variable);
    }
    for (const name in groupedByName) {
      const variables = groupedByName[name];
      let selectedVariable = variables[0];
      for (const variable of variables) {
        const edgeObject = this.graph[variable.edgeId];
        if (edgeObject instanceof CannoliEdge && edgeObject.isReflexive) {
          selectedVariable = variable;
          break;
        }
      }
      finalVariables.push(selectedVariable);
    }
    return finalVariables;
  }
  loadOutgoingEdges(content, request) {
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (edgeObject instanceof CannoliEdge && !(edgeObject instanceof ChatResponseEdge)) {
        edgeObject.load({
          content,
          request
        });
      }
    }
  }
  dependencyCompleted(dependency) {
    if (this.allDependenciesComplete() && this.status === "pending" /* Pending */) {
      this.execute();
    }
  }
  getNoteOrFloatingReference() {
    const notePattern = /^{{\[\[([^\]]+)\]\]([\W]*)}}$/;
    const floatingPattern = /^{{\[([^\]]+)\]}}$/;
    const currentNotePattern = /^{{NOTE([\W]*)}}$/;
    const strippedText = this.text.trim();
    let match = notePattern.exec(strippedText);
    if (match) {
      const reference = {
        name: match[1],
        type: "note" /* Note */,
        shouldExtract: false
      };
      const modifiers = match[2];
      if (modifiers) {
        if (modifiers.includes("!#")) {
          reference.includeName = false;
        } else if (modifiers.includes("#")) {
          reference.includeName = true;
        }
        if (modifiers.includes("!$")) {
          reference.includeProperties = false;
        } else if (modifiers.includes("$")) {
          reference.includeProperties = true;
        }
      }
      return reference;
    }
    match = floatingPattern.exec(strippedText);
    if (match) {
      const reference = {
        name: match[1],
        type: "floating" /* Floating */,
        shouldExtract: false
      };
      return reference;
    }
    match = currentNotePattern.exec(strippedText);
    if (match && this.run.currentNote) {
      const reference = {
        name: this.run.currentNote,
        type: "note" /* Note */,
        shouldExtract: false
      };
      const modifiers = match[1];
      if (modifiers) {
        if (modifiers.includes("!#")) {
          reference.includeName = false;
        } else if (modifiers.includes("#")) {
          reference.includeName = true;
        }
        if (modifiers.includes("!$")) {
          reference.includeProperties = false;
        } else if (modifiers.includes("$")) {
          reference.includeProperties = true;
        }
      }
      return reference;
    }
    return null;
  }
  logDetails() {
    let groupsString = "";
    groupsString += `Groups: `;
    for (const group of this.groups) {
      groupsString += `
	-"${this.ensureStringLength(
        this.graph[group].text,
        15
      )}"`;
    }
    let incomingEdgesString = "";
    incomingEdgesString += `Incoming Edges: `;
    for (const edge of this.incomingEdges) {
      incomingEdgesString += `
	-"${this.ensureStringLength(
        this.graph[edge].text,
        15
      )}"`;
    }
    let outgoingEdgesString = "";
    outgoingEdgesString += `Outgoing Edges: `;
    for (const edge of this.outgoingEdges) {
      outgoingEdgesString += `
	-"${this.ensureStringLength(
        this.graph[edge].text,
        15
      )}"`;
    }
    return `[] Node ${this.id} Text: "${this.text}"
${incomingEdgesString}
${outgoingEdgesString}
${groupsString}
` + super.logDetails();
  }
  validate() {
    super.validate();
    if (this.incomingEdges.filter(
      (edge) => this.graph[edge].type === "list" /* List */
    ).length > 1) {
      this.error(`Nodes can only have one incoming list edge.`);
    }
  }
  getSpecialOutgoingEdges() {
    const specialOutgoingEdges = this.getOutgoingEdges().filter((edge) => {
      return edge.type === "field" /* Field */ || edge.type === "choice" /* Choice */ || edge.type === "category" /* Category */ || edge.type === "merge" /* Merge */ || edge.type === "list" /* List */ || edge.type === "variable" /* Variable */;
    });
    return specialOutgoingEdges;
  }
  specialOutgoingEdgesAreHomogeneous() {
    const specialOutgoingEdges = this.getSpecialOutgoingEdges();
    if (specialOutgoingEdges.length === 0) {
      return true;
    }
    const firstEdgeType = specialOutgoingEdges[0].type;
    for (const edge of specialOutgoingEdges) {
      if (edge.type !== firstEdgeType) {
        return false;
      }
    }
    return true;
  }
  getAllAvailableProvideEdges() {
    const availableEdges = [];
    for (const group of this.groups) {
      const groupObject = this.graph[group];
      if (!(groupObject instanceof CannoliVertex)) {
        throw new Error(
          `Error on node ${this.id}: group is not a vertex.`
        );
      }
      const groupIncomingEdges = groupObject.getIncomingEdges();
      availableEdges.push(...groupIncomingEdges);
    }
    const nodeIncomingEdges = this.getIncomingEdges();
    availableEdges.push(...nodeIncomingEdges);
    const filteredEdges = availableEdges.filter(
      (edge) => edge.type !== "logging" /* Logging */ && edge.type !== "write" /* Write */ && edge.type !== "config" /* Config */
    );
    return filteredEdges;
  }
};
var CallNode = class extends CannoliNode {
  getPrependedMessages() {
    const messages = [];
    const availableEdges = this.getAllAvailableProvideEdges();
    const directEdges = availableEdges.filter(
      (edge) => this.incomingEdges.includes(edge.id)
    );
    const indirectEdges = availableEdges.filter(
      (edge) => !this.incomingEdges.includes(edge.id)
    );
    for (const edge of directEdges) {
      const edgeObject = this.graph[edge.id];
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error on object ${edgeObject.id}: object is not a provide edge.`
        );
      }
      const edgeMessages = edgeObject.messages;
      if (!edgeMessages) {
        continue;
      }
      if (edgeMessages.length < 1) {
        continue;
      }
      for (const group of edgeObject.crossingInGroups) {
        const indirectEdgesToGroup = indirectEdges.filter(
          (edge2) => edge2.target === group
        );
        const indirectEdgesToAdd = indirectEdgesToGroup.filter(
          (edge2) => this.graph[edge2.id] instanceof CannoliEdge && this.graph[edge2.id].addMessages
        );
        for (const indirectEdge of indirectEdgesToAdd) {
          const indirectEdgeObject = this.graph[indirectEdge.id];
          if (!(indirectEdgeObject instanceof CannoliEdge)) {
            throw new Error(
              `Error on object ${indirectEdgeObject.id}: object is not a provide edge.`
            );
          }
          const indirectEdgeMessages = indirectEdgeObject.messages;
          if (!indirectEdgeMessages) {
            continue;
          }
          if (indirectEdgeMessages.length < 1) {
            continue;
          }
          edgeMessages.length = 0;
          edgeMessages.push(...indirectEdgeMessages);
        }
      }
      if (edgeMessages) {
        if (edge.type === "system-message" /* SystemMessage */) {
          messages.unshift(edgeMessages[0]);
        } else {
          messages.push(...edgeMessages);
        }
      }
    }
    if (messages.length === 0 && this.incomingEdges.filter(
      (edge) => this.cannoliGraph.isEdge(this.graph[edge]) && this.graph[edge].addMessages
    ).length === 0) {
      for (const edge of indirectEdges) {
        const edgeObject = this.graph[edge.id];
        if (!(edgeObject instanceof CannoliEdge)) {
          throw new Error(
            `Error on object ${edgeObject.id}: object is not a provide edge.`
          );
        }
        const edgeMessages = edgeObject.messages;
        if (!edgeMessages) {
          continue;
        }
        if (edgeMessages.length < 1) {
          continue;
        }
        if (edgeMessages) {
          if (edge.type === "system-message" /* SystemMessage */) {
            messages.unshift(edgeMessages[0]);
          } else {
            messages.push(...edgeMessages);
          }
        }
      }
    }
    return messages;
  }
  async getNewMessage(role) {
    const content = await this.processReferences();
    if (!content) {
      return null;
    }
    return {
      role: role || "user",
      content
    };
  }
  findNoteReferencesInMessages(messages) {
    var _a2;
    const references = [];
    const noteRegex = /\[\[(.+?)\]\]/g;
    for (const message of messages) {
      const matches = typeof message.content === "string" && ((_a2 = message.content) == null ? void 0 : _a2.matchAll(noteRegex));
      if (!matches) {
        continue;
      }
      for (const match of matches) {
        references.push(match[1]);
      }
    }
    return references;
  }
  getDefaultConfig() {
    const config = JSON.parse(JSON.stringify(this.run.getDefaultConfig()));
    return config;
  }
  updateConfigWithValue(runConfig, content, setting) {
    var _a2, _b;
    const sampleConfig = (_b = (_a2 = this.run.llm) == null ? void 0 : _a2.getSampleConfig()) != null ? _b : {};
    const keyTypeMap = {
      frequency_penalty: "number",
      presence_penalty: "number",
      temperature: "number",
      top_p: "number"
    };
    const convertValue = (key, value) => {
      const expectedType = keyTypeMap[key];
      return expectedType === "number" ? parseFloat(value) : value;
    };
    const isValidKey = (key) => {
      return key in sampleConfig;
    };
    if (typeof content === "string") {
      if (setting && isValidKey(setting)) {
        runConfig[setting] = convertValue(setting, content);
      } else {
        this.error(`"${setting}" is not a valid config setting.`);
      }
    } else if (typeof content === "object") {
      for (const key in content) {
        if (isValidKey(key)) {
          runConfig[key] = convertValue(key, content[key]);
        } else {
          this.error(`"${key}" is not a valid config setting.`);
        }
      }
    }
  }
  processSingleEdge(runConfig, edgeObject) {
    if (typeof edgeObject.content === "string" || typeof edgeObject.content === "object") {
      this.updateConfigWithValue(
        runConfig,
        edgeObject.content,
        edgeObject.text
      );
    } else {
      this.error(`Config edge has invalid content.`);
    }
  }
  processEdges(runConfig, edges) {
    for (const edgeObject of edges) {
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error processing config edges: object is not an edge.`
        );
      }
      this.processSingleEdge(runConfig, edgeObject);
    }
  }
  processGroups(runConfig) {
    for (let i = this.groups.length - 1; i >= 0; i--) {
      const group = this.graph[this.groups[i]];
      if (group instanceof CannoliGroup) {
        const configEdges = group.getIncomingEdges().filter((edge) => edge.type === "config" /* Config */);
        this.processEdges(runConfig, configEdges);
      }
    }
  }
  processNodes(runConfig) {
    const configEdges = this.getIncomingEdges().filter(
      (edge) => edge.type === "config" /* Config */
    );
    this.processEdges(runConfig, configEdges);
  }
  getConfig() {
    const runConfig = this.getDefaultConfig();
    this.processGroups(runConfig);
    this.processNodes(runConfig);
    return runConfig;
  }
  async execute() {
    var _a2, _b, _c, _d;
    this.executing();
    const request = await this.createLLMRequest();
    if (request.messages.length === 0) {
      this.error(
        `No messages to send to LLM. Empty call nodes only send the message history they've been passed.`
      );
      return;
    }
    const chatResponseEdges = this.getOutgoingEdges().filter(
      (edge) => edge.type === "chat-response" /* ChatResponse */
    );
    if (chatResponseEdges.length > 0) {
      request.stream = true;
      const stream = await this.run.callLLMStream(
        request
      );
      if (stream instanceof Error) {
        this.error(`Error calling LLM:
${stream.message}`);
        return;
      }
      if (!stream) {
        this.error(`Error calling LLM: no stream returned.`);
        return;
      }
      if (typeof stream === "string") {
        this.loadOutgoingEdges(stream, request);
        this.completed();
        return;
      }
      let messageContent = "";
      for await (const rawPart of stream) {
        const part = (_a2 = this.run.llm) == null ? void 0 : _a2.getPart(rawPart);
        if (part instanceof Error) {
          this.error(`Error calling LLM:
${part.message}`);
          return;
        }
        if (!part) {
          this.error(`Error calling LLM: no part returned.`);
          return;
        }
        if (Llm.getStreamingCompletionFinished(part)) {
          for (const edge of chatResponseEdges) {
            edge.load({
              content: "END OF STREAM",
              request
            });
          }
          continue;
        }
        const delta = Llm.getFirstStreamingCompletionMessageDelta(part);
        messageContent += delta;
        for (const edge of chatResponseEdges) {
          edge.load({
            content: delta != null ? delta : "",
            request
          });
        }
      }
      request.messages.push({
        role: "assistant",
        content: messageContent
      });
      this.loadOutgoingEdges(messageContent, request);
    } else {
      delete request.stream;
      const message = await this.run.callLLM(
        request
      );
      if (message instanceof Error) {
        this.error(`Error calling LLM:
${message.message}`);
        return;
      }
      if (!message) {
        this.error(`Error calling LLM: no message returned.`);
        return;
      }
      request.messages.push(message);
      if ((_b = message.function_call) == null ? void 0 : _b.arguments) {
        if (message.function_call.name === "note_select") {
          const args = JSON.parse(message.function_call.arguments);
          args.note = `[[${args.note}]]`;
          this.loadOutgoingEdges(args.note, request);
        } else {
          this.loadOutgoingEdges((_c = message.content) != null ? _c : "", request);
        }
      } else {
        this.loadOutgoingEdges((_d = message.content) != null ? _d : "", request);
      }
    }
    this.completed();
  }
  async createLLMRequest() {
    const config = this.getConfig();
    if (this instanceof FormNode || this instanceof ChooseNode) {
      const isOpenAI = this.run.cannoli.settings.llmProvider == "openai";
      if (!isOpenAI) {
        this.error(
          `Form and Choice nodes are only supported with OpenAI. Support for function calling with Ollama coming soon.`
        );
      }
    }
    const messages = this.getPrependedMessages();
    const newMessage = await this.getNewMessage(config.role);
    delete config.role;
    if (newMessage) {
      messages.push(newMessage);
    }
    const functions = this.getFunctions(messages);
    const function_call = functions && functions.length > 0 ? { name: functions[0].name } : void 0;
    return {
      messages,
      ...config,
      functions: functions && functions.length > 0 ? functions : void 0,
      function_call: function_call ? function_call : void 0
    };
  }
  getFunctions(messages) {
    if (this.getOutgoingEdges().some(
      (edge) => edge.vaultModifier === "note" /* Note */
    )) {
      const noteNames = this.findNoteReferencesInMessages(messages);
      return [this.run.createNoteNameFunction(noteNames)];
    } else {
      return [];
    }
  }
  logDetails() {
    return super.logDetails() + `Type: Call
`;
  }
  validate() {
    super.validate();
  }
};
var FormNode = class extends CallNode {
  getFunctions(messages) {
    const fields = this.getFields();
    const fieldsWithNotes = [];
    const noteEdges = this.getOutgoingEdges().filter(
      (edge) => edge.vaultModifier === "note" /* Note */
    );
    for (const item of fields) {
      if (noteEdges.find((edge) => edge.text === item)) {
        const noteNames = this.findNoteReferencesInMessages(messages);
        fieldsWithNotes.push({ name: item, noteNames });
      } else {
        fieldsWithNotes.push({ name: item });
      }
    }
    const formFunc = this.run.createFormFunction(fieldsWithNotes);
    return [formFunc];
  }
  getFields() {
    const outgoingFieldEdges = this.getOutgoingEdges().filter((edge) => {
      return edge.type === "field" /* Field */;
    });
    const uniqueNames = /* @__PURE__ */ new Set();
    for (const edge of outgoingFieldEdges) {
      const edgeObject = this.graph[edge.id];
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error on object ${edgeObject.id}: object is not a field edge.`
        );
      }
      const name = edgeObject.text;
      if (name) {
        uniqueNames.add(name);
      }
    }
    return Array.from(uniqueNames);
  }
  loadOutgoingEdges(content, request) {
    var _a2;
    const messages = request.messages;
    const lastMessage = messages[messages.length - 1];
    const formFunctionArgs = "function_call" in lastMessage && ((_a2 = lastMessage.function_call) == null ? void 0 : _a2.arguments);
    if (!formFunctionArgs) {
      this.error(`Form function call has no arguments.`);
      return;
    }
    const fields = JSON.parse(formFunctionArgs);
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (edgeObject instanceof CannoliEdge) {
        if (edgeObject instanceof CannoliEdge && edgeObject.type === "field" /* Field */) {
          const name = edgeObject.text;
          if (name) {
            const fieldContent = fields[name];
            if (fieldContent) {
              if (edgeObject.vaultModifier === "note" /* Note */) {
                edgeObject.load({
                  content: `[[${fieldContent}]]`,
                  request
                });
              } else {
                edgeObject.load({
                  content: fieldContent,
                  request
                });
              }
            }
          }
        } else {
          edgeObject.load({
            content: formFunctionArgs,
            request
          });
        }
      }
    }
  }
  logDetails() {
    return super.logDetails() + `Subtype: Form
`;
  }
  validate() {
    super.validate();
  }
};
var AccumulateNode = class extends CallNode {
  logDetails() {
    return super.logDetails() + `Subtype: Accumulate
`;
  }
};
var ChooseNode = class extends CallNode {
  getFunctions(messages) {
    const choices = this.getBranchChoices();
    const choiceFunc = this.run.createChoiceFunction(choices);
    return [choiceFunc];
  }
  loadOutgoingEdges(content, request) {
    var _a2;
    const messages = request.messages;
    const lastMessage = messages[messages.length - 1];
    const choiceFunctionArgs = "function_call" in lastMessage && ((_a2 = lastMessage.function_call) == null ? void 0 : _a2.arguments);
    if (!choiceFunctionArgs) {
      this.error(`Choice function call has no arguments.`);
      return;
    }
    const parsedVariable = JSON.parse(choiceFunctionArgs);
    this.rejectUnselectedOptions(parsedVariable.choice);
    super.loadOutgoingEdges(choiceFunctionArgs, request);
  }
  rejectUnselectedOptions(choice) {
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (edgeObject.type === "choice" /* Choice */) {
        const branchEdge = edgeObject;
        if (branchEdge.text !== choice) {
          branchEdge.reject();
        }
      }
    }
  }
  getBranchChoices() {
    const outgoingChoiceEdges = this.getOutgoingEdges().filter((edge) => {
      return edge.type === "choice" /* Choice */;
    });
    const uniqueNames = /* @__PURE__ */ new Set();
    for (const edge of outgoingChoiceEdges) {
      const edgeObject = this.graph[edge.id];
      if (!(edgeObject instanceof CannoliEdge)) {
        throw new Error(
          `Error on object ${edgeObject.id}: object is not a branch edge.`
        );
      }
      const name = edgeObject.text;
      if (name) {
        uniqueNames.add(name);
      }
    }
    return Array.from(uniqueNames);
  }
  logDetails() {
    return super.logDetails() + `Subtype: Choice
`;
  }
  validate() {
    super.validate();
    if (!this.getOutgoingEdges().some(
      (edge) => edge.type === "choice" /* Choice */
    )) {
      this.error(
        `Choice nodes must have at least one outgoing choice edge.`
      );
    }
  }
};
var ContentNode = class extends CannoliNode {
  reset() {
    if (this.type === "standard-content" /* StandardContent */ && this.incomingEdges.length > 0) {
      this.text = "";
    }
    super.reset();
  }
  async execute() {
    this.executing();
    let content = this.getWriteOrLoggingContent();
    if (!content) {
      const variableValues = this.getVariableValues(false);
      if (variableValues.length > 0) {
        content = variableValues[0].content || "";
      } else {
        content = "";
      }
    }
    if (content !== null && content !== void 0 && content !== "") {
      this.text = content;
    } else {
      content = await this.processReferences();
    }
    this.loadOutgoingEdges(content);
    this.completed();
  }
  dependencyCompleted(dependency) {
    if (dependency instanceof LoggingEdge && !dependency.crossingOutGroups.some((group) => {
      const groupObject = this.graph[group];
      if (!(groupObject instanceof CannoliGroup)) {
        throw new Error(
          `Error on object ${groupObject.id}: object is not a group.`
        );
      }
      return groupObject.type === "for-each" /* ForEach */;
    }) || dependency instanceof ChatResponseEdge) {
      this.execute();
    } else if (this.allDependenciesComplete() && this.status === "pending" /* Pending */) {
      this.execute();
    }
  }
  logDetails() {
    return super.logDetails() + `Type: Content
`;
  }
  getWriteOrLoggingContent() {
    const incomingEdges = this.getIncomingEdges();
    if (incomingEdges.filter((edge) => edge.type === "logging" /* Logging */).length > 1) {
      let content = "";
      for (const edge of incomingEdges) {
        const edgeObject = this.graph[edge.id];
        if (edgeObject instanceof LoggingEdge) {
          if (edgeObject.content !== null) {
            content += edgeObject.content;
          }
        }
      }
      return content;
    }
    let filteredEdges = incomingEdges.filter(
      (edge) => (edge.type === "write" /* Write */ || edge.type === "logging" /* Logging */ || edge.type === "chat-response" /* ChatResponse */ || edge.text.length === 0) && this.graph[edge.id].status === "complete" /* Complete */
    );
    filteredEdges = filteredEdges.filter(
      (edge) => edge.vaultModifier !== "folder" /* Folder */ && edge.vaultModifier !== "property" /* Property */
    );
    if (filteredEdges.length === 0) {
      return null;
    }
    const firstEdge = filteredEdges[0];
    const firstEdgeObject = this.graph[firstEdge.id];
    if (firstEdgeObject instanceof CannoliEdge) {
      if (firstEdgeObject.content !== null && typeof firstEdgeObject.content === "string") {
        return firstEdgeObject.content;
      }
    } else {
      throw new Error(
        `Error on object ${firstEdgeObject.id}: object is not an edge.`
      );
    }
    return null;
  }
  validate() {
    super.validate();
  }
};
var ReferenceNode = class extends ContentNode {
  constructor(nodeData) {
    super(nodeData);
    if (this.references.length !== 1) {
      this.error(`Could not find reference.`);
    } else {
      this.reference = this.references[0];
    }
  }
  async execute() {
    this.executing();
    let content = "";
    const writeOrLoggingContent = this.getWriteOrLoggingContent();
    const variableValues = this.getVariableValues(false);
    if (variableValues.length > 0) {
      const variableValueEdges = variableValues.map((variableValue) => {
        return this.graph[variableValue.edgeId];
      });
      const filteredVariableValueEdges = variableValueEdges.filter(
        (variableValueEdge) => {
          return variableValueEdge.text !== this.reference.name && variableValueEdge.vaultModifier !== "folder" /* Folder */ && variableValueEdge.vaultModifier !== "property" /* Property */;
        }
      );
      const filteredVariableValues = variableValues.filter(
        (variableValue) => {
          return filteredVariableValueEdges.some(
            (filteredVariableValueEdge) => {
              return filteredVariableValueEdge.id === variableValue.edgeId;
            }
          );
        }
      );
      if (filteredVariableValues.length > 0) {
        content = filteredVariableValues[0].content;
      } else if (writeOrLoggingContent !== null) {
        content = writeOrLoggingContent;
      }
    } else if (writeOrLoggingContent !== null) {
      content = writeOrLoggingContent;
    }
    const propertyEdges = this.getIncomingEdges().filter(
      (edge) => edge.vaultModifier === "property" /* Property */ && edge.text !== this.reference.name
    );
    if (content) {
      const append = this.getIncomingEdges().some(
        (edge) => edge.type === "chat-response" /* ChatResponse */
      );
      if (this.reference.type === "create-note" /* CreateNote */ || this.reference.type === "variable" /* Variable */) {
        await this.processDynamicReference(content);
      } else {
        await this.editContent(content, append);
        if (propertyEdges.length > 0) {
          for (const edge of propertyEdges) {
            if (edge.content === null || edge.content === void 0 || typeof edge.content !== "string") {
              this.error(`Property arrow has invalid content.`);
              return;
            }
            await this.editProperty(edge.text, edge.content);
          }
        }
      }
      await this.loadOutgoingEdges(content);
    } else {
      if (this.reference.type === "create-note" /* CreateNote */ || this.reference.type === "variable" /* Variable */) {
        await this.processDynamicReference("");
        const fetchedContent = await this.getContent();
        await this.loadOutgoingEdges(fetchedContent);
      } else {
        const fetchedContent = await this.getContent();
        await this.loadOutgoingEdges(fetchedContent);
      }
      if (propertyEdges.length > 0) {
        for (const edge of propertyEdges) {
          if (edge.content === null || edge.content === void 0 || typeof edge.content !== "string") {
            this.error(`Property arrow has invalid content.`);
            return;
          }
          await this.editProperty(edge.text, edge.content);
        }
      }
    }
    this.completed();
  }
  async getContent() {
    if (this.run.isMock) {
      return `Mock content`;
    }
    if (this.reference) {
      if (this.reference.type === "note" /* Note */) {
        const content = await this.getContentFromNote(this.reference);
        if (content !== null && content !== void 0) {
          return content;
        } else {
          this.error(
            `Invalid reference. Could not find note "${this.reference.name}"`
          );
        }
      } else if (this.reference.type === "selection" /* Selection */) {
        const content = this.run.selection;
        if (content !== null && content !== void 0) {
          return content;
        } else {
          this.error(`Invalid reference. Could not find selection.`);
        }
      } else if (this.reference.type === "floating" /* Floating */) {
        const content = this.getContentFromFloatingNode(
          this.reference.name
        );
        if (content) {
          return content;
        } else {
          this.error(
            `Invalid reference. Could not find floating node "${this.reference.name}"`
          );
        }
      } else if (this.reference.type === "variable" /* Variable */ || this.reference.type === "create-note" /* CreateNote */) {
        this.error(`Dynamic reference did not process correctly.`);
      }
    }
    return `Could not find reference.`;
  }
  async processDynamicReference(content) {
    if (this.run.isMock) {
      return;
    }
    const incomingEdges = this.getIncomingEdges();
    const referenceNameEdge = incomingEdges.find(
      (edge) => edge.text === this.reference.name
    );
    if (!referenceNameEdge) {
      this.error(`Could not find arrow containing note name.`);
      return;
    }
    if (referenceNameEdge.content === null || referenceNameEdge.content === void 0 || typeof referenceNameEdge.content !== "string") {
      this.error(`Note name arrow has invalid content.`);
      return;
    }
    const folderEdge = incomingEdges.find(
      (edge) => edge.vaultModifier === "folder" /* Folder */
    );
    let path = "";
    if (folderEdge) {
      if (folderEdge.content === null || folderEdge.content === void 0 || typeof folderEdge.content !== "string") {
        this.error(`Folder arrow has invalid content.`);
        return;
      }
      path = folderEdge.content;
    }
    const propertyEdges = incomingEdges.filter(
      (edge) => edge.vaultModifier === "property" /* Property */ && edge.text !== this.reference.name
    );
    if (this.reference.type === "create-note" /* CreateNote */) {
      let noteName;
      if (propertyEdges.length > 0) {
        let yamlFrontmatter = "---\n";
        for (const edge of propertyEdges) {
          if (edge.content === null || edge.content === void 0 || typeof edge.content !== "string") {
            this.error(`Property arrow has invalid content.`);
            return;
          }
          if (edge.content.startsWith("-")) {
            yamlFrontmatter += `${edge.text}: 
  ${edge.content.replace(/\n/g, "\n  ").trim()}
`;
          } else {
            yamlFrontmatter += `${edge.text}: "${edge.content}"
`;
          }
        }
        yamlFrontmatter += "---\n";
        content = yamlFrontmatter + content;
      }
      try {
        noteName = await this.run.createNoteAtExistingPath(
          referenceNameEdge.content,
          path,
          content
        );
      } catch (e) {
        this.error(`Could not create note: ${e.message}`);
        return;
      }
      if (!noteName) {
        this.error(`"${referenceNameEdge.content}" already exists.`);
      } else {
        this.reference.name = noteName;
        this.reference.type = "note" /* Note */;
      }
    } else {
      this.reference.name = referenceNameEdge.content;
      this.reference.type = "note" /* Note */;
      if (content !== null) {
        await this.editContent(content, false);
      }
      if (propertyEdges.length > 0) {
        for (const edge of propertyEdges) {
          if (edge.content === null || edge.content === void 0 || typeof edge.content !== "string") {
            this.error(`Property arrow has invalid content.`);
            return;
          }
          await this.editProperty(edge.text, edge.content);
        }
      }
    }
  }
  async editContent(newContent, append) {
    if (this.run.isMock) {
      return;
    }
    if (this.reference) {
      if (this.reference.type === "note" /* Note */) {
        const edit = await this.run.editNote(
          this.reference,
          newContent,
          append
        );
        if (edit !== null) {
          return;
        } else {
          this.error(
            `Invalid reference. Could not edit note ${this.reference.name}`
          );
        }
      } else if (this.reference.type === "selection" /* Selection */) {
        this.run.editSelection(newContent);
        return;
      } else if (this.reference.type === "floating" /* Floating */) {
        for (const objectId in this.graph) {
          const object = this.graph[objectId];
          if (object instanceof FloatingNode && object.getName() === this.reference.name) {
            object.editContent(newContent);
            return;
          }
        }
        this.error(
          `Invalid reference. Could not find floating node ${this.reference.name}`
        );
      } else if (this.reference.type === "variable" /* Variable */ || this.reference.type === "create-note" /* CreateNote */) {
        this.error(`Dynamic reference did not process correctly.`);
      }
    }
  }
  async editProperty(propertyName, newContent) {
    if (this.run.isMock) {
      return;
    }
    if (this.reference) {
      if (this.reference.type === "note" /* Note */) {
        const edit = await this.run.editPropertyOfNote(
          this.reference.name,
          propertyName,
          newContent.trim()
        );
        if (edit !== null) {
          return;
        } else {
          this.error(
            `Invalid reference. Could not edit property ${propertyName} of note ${this.reference.name}`
          );
        }
      } else if (this.reference.type === "floating" /* Floating */) {
        for (const objectId in this.graph) {
          const object = this.graph[objectId];
          if (object instanceof FloatingNode && object.getName() === this.reference.name) {
            object.editProperty(propertyName, newContent.trim());
            return;
          }
        }
      } else if (this.reference.type === "variable" /* Variable */ || this.reference.type === "create-note" /* CreateNote */) {
        this.error(`Dynamic reference did not process correctly.`);
      }
    }
  }
  async loadOutgoingEdges(content, request) {
    if (this.reference.type === "floating" /* Floating */) {
      this.loadOutgoingEdgesFloating(content, request);
      return;
    }
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (!(edgeObject instanceof CannoliEdge)) {
        continue;
      }
      if (edgeObject.vaultModifier === "property" /* Property */) {
        let value;
        if (edgeObject.text.length === 0) {
          value = await this.run.getAllPropertiesOfNote(
            this.reference.name,
            true
          );
        } else {
          value = await this.run.getPropertyOfNote(
            this.reference.name,
            edgeObject.text,
            true
          );
        }
        if (value) {
          edgeObject.load({
            content: value != null ? value : "",
            request
          });
        }
      } else if (edgeObject.vaultModifier === "note" /* Note */) {
        edgeObject.load({
          content: `${this.reference.name}`,
          request
        });
      } else if (edgeObject.vaultModifier === "folder" /* Folder */) {
        const path = await this.run.getNotePath(this.reference.name);
        if (path) {
          edgeObject.load({
            content: path,
            request
          });
        }
      } else if (edgeObject instanceof CannoliEdge && !(edgeObject instanceof ChatResponseEdge)) {
        edgeObject.load({
          content,
          request
        });
      }
    }
  }
  loadOutgoingEdgesFloating(content, request) {
    for (const edge of this.outgoingEdges) {
      const edgeObject = this.graph[edge];
      if (!(edgeObject instanceof CannoliEdge)) {
        continue;
      }
      if (edgeObject.vaultModifier === "note" /* Note */) {
        edgeObject.load({
          content: `${this.reference.name}`,
          request
        });
      } else if (edgeObject.vaultModifier === "property" /* Property */) {
        let propertyContent = "";
        for (const objectId in this.graph) {
          const object = this.graph[objectId];
          if (object instanceof FloatingNode && object.getName() === this.reference.name) {
            propertyContent = object.getProperty(edgeObject.text);
          }
        }
        if (propertyContent) {
          edgeObject.load({
            content: propertyContent,
            request
          });
        }
      } else if (edgeObject instanceof CannoliEdge && !(edgeObject instanceof ChatResponseEdge)) {
        edgeObject.load({
          content,
          request
        });
      }
    }
  }
  logDetails() {
    return super.logDetails() + `Subtype: Reference
`;
  }
  validate() {
    super.validate();
  }
};
var HttpNode = class extends ContentNode {
  logDetails() {
    return super.logDetails() + `Subtype: Http
`;
  }
  async execute() {
    this.executing();
    let content = this.getWriteOrLoggingContent();
    if (!content) {
      const variableValues = this.getVariableValues(false);
      if (variableValues.length > 0) {
        content = {};
        for (const variableValue of variableValues) {
          content[variableValue.name] = variableValue.content || "";
        }
      }
    }
    let template = null;
    for (const objectId in this.graph) {
      const object = this.graph[objectId];
      if (object instanceof FloatingNode && object.getName() === this.text) {
        template = object.text;
      }
    }
    let result;
    if (template) {
      result = await this.run.executeHttpTemplateFromFloatingNode(
        template,
        content
      );
    } else {
      result = await this.run.executeHttpTemplateByName(
        this.text,
        content
      );
    }
    if (result instanceof Error) {
      this.error(result.message);
      return;
    }
    if (typeof result === "string") {
      this.loadOutgoingEdges(result);
    }
    this.completed();
  }
};
var FormatterNode = class extends ContentNode {
  logDetails() {
    return super.logDetails() + `Subtype: Formatter
`;
  }
  async execute() {
    this.executing();
    const content = await this.processReferences();
    const processedContent = content.slice(2, -2);
    this.loadOutgoingEdges(processedContent);
    this.completed();
  }
};
var FloatingNode = class extends CannoliNode {
  constructor(nodeData) {
    super(nodeData);
    this.status = "complete" /* Complete */;
  }
  dependencyCompleted(dependency) {
    return;
  }
  dependencyRejected(dependency) {
    return;
  }
  async execute() {
    this.completed();
  }
  getName() {
    const firstLine = this.text.split("\n")[0].trim();
    return firstLine.substring(1, firstLine.length - 1);
  }
  // Content is everything after the first line
  getContent() {
    const firstLine = this.text.split("\n")[0];
    return this.text.substring(firstLine.length + 1);
  }
  editContent(newContent) {
    const firstLine = this.text.split("\n")[0];
    this.text = `${firstLine}
${newContent}`;
    const event = new CustomEvent("update", {
      detail: { obj: this, status: this.status }
    });
    this.dispatchEvent(event);
  }
  editProperty(propertyName, newContent) {
    const frontmatter = this.getContent().split("---")[1];
    if (!frontmatter) {
      return;
    }
    const parsedFrontmatter = load(
      frontmatter
    );
    if (!parsedFrontmatter) {
      return;
    }
    parsedFrontmatter[propertyName] = newContent;
    const newFrontmatter = dump(parsedFrontmatter);
    const newProps = `---
${newFrontmatter}---
${this.getContent().split("---")[2]}`;
    this.editContent(newProps);
  }
  getProperty(propertyName) {
    if (propertyName.length === 0) {
      return this.getContent().split("---")[1];
    }
    const frontmatter = this.getContent().split("---")[1];
    if (!frontmatter) {
      return "";
    }
    const parsedFrontmatter = load(
      frontmatter
    );
    if (!parsedFrontmatter) {
      return "";
    }
    return parsedFrontmatter[propertyName];
  }
  logDetails() {
    return super.logDetails() + `Type: Floating
Name: ${this.getName()}
Content: ${this.getContent()}
`;
  }
};

// src/models/graph.ts
var CannoliGraph2 = class {
  constructor(cannoliCanvasData) {
    this.graph = {};
    this.cannoliCanvasData = cannoliCanvasData;
    this.hydrateGraph();
    this.addGraphToAll();
    this.setupAllListeners();
  }
  hydrateGraph() {
    var _a2, _b, _c;
    for (const node of this.cannoliCanvasData.nodes) {
      switch ((_a2 = node.cannoliData) == null ? void 0 : _a2.type) {
        case "for-each" /* ForEach */: {
          const forEachGroup = node;
          this.graph[node.id] = new ForEachGroup(forEachGroup);
          break;
        }
        case "repeat" /* Repeat */: {
          const repeatGroup = node;
          this.graph[node.id] = new RepeatGroup(repeatGroup);
          break;
        }
        case "basic" /* Basic */: {
          const basicGroup = node;
          this.graph[node.id] = new CannoliGroup(basicGroup);
          break;
        }
        case "standard-content" /* StandardContent */: {
          const standardContentNode = node;
          this.graph[node.id] = new ContentNode(standardContentNode);
          break;
        }
        case "reference" /* Reference */: {
          const referenceNode = node;
          this.graph[node.id] = new ReferenceNode(referenceNode);
          break;
        }
        case "formatter" /* Formatter */: {
          const formatterNode = node;
          this.graph[node.id] = new FormatterNode(formatterNode);
          break;
        }
        case "http" /* Http */: {
          const httpNode = node;
          this.graph[node.id] = new HttpNode(httpNode);
          break;
        }
        case "standard-call" /* StandardCall */: {
          const standardCallNode = node;
          this.graph[node.id] = new CallNode(standardCallNode);
          break;
        }
        case "choose" /* Choose */: {
          const chooseNode = node;
          this.graph[node.id] = new ChooseNode(chooseNode);
          break;
        }
        case "form" /* Form */: {
          const formNode = node;
          this.graph[node.id] = new FormNode(formNode);
          break;
        }
        case "accumulate" /* Accumulate */: {
          const accumulateNode = node;
          this.graph[node.id] = new AccumulateNode(accumulateNode);
          break;
        }
        case "categorize" /* Categorize */: {
          console.error("Categorize node not implemented");
          break;
        }
        case "select" /* Select */: {
          console.error("Select node not implemented");
          break;
        }
        case "variable" /* Variable */: {
          const variableNode = node;
          this.graph[node.id] = new FloatingNode(variableNode);
          break;
        }
        default: {
          throw new Error(
            `Unknown node type: ${(_b = node.cannoliData) == null ? void 0 : _b.type}`
          );
        }
      }
    }
    for (const edge of this.cannoliCanvasData.edges) {
      switch ((_c = edge.cannoliData) == null ? void 0 : _c.type) {
        case "logging" /* Logging */: {
          const loggingEdge = edge;
          this.graph[edge.id] = new LoggingEdge(loggingEdge);
          break;
        }
        case "system-message" /* SystemMessage */: {
          const systemMessageEdge = edge;
          this.graph[edge.id] = new SystemMessageEdge(
            systemMessageEdge
          );
          break;
        }
        case "chat-converter" /* ChatConverter */: {
          const chatConverterEdge = edge;
          this.graph[edge.id] = new ChatConverterEdge(
            chatConverterEdge
          );
          break;
        }
        case "chat-response" /* ChatResponse */: {
          const chatResponseEdge = edge;
          this.graph[edge.id] = new ChatResponseEdge(
            chatResponseEdge
          );
          break;
        }
        default: {
          const genericEdge = edge;
          this.graph[edge.id] = new CannoliEdge(genericEdge);
          break;
        }
      }
    }
  }
  addGraphToAll() {
    for (const id in this.graph) {
      this.graph[id].setGraph(this.graph, this);
    }
  }
  setupAllListeners() {
    for (const id in this.graph) {
      this.graph[id].setupListeners();
    }
  }
  isEdge(edge) {
    return edge.kind === "edge" /* Edge */;
  }
  isNode(node) {
    return node.kind === "node" /* Node */;
  }
  isGroup(group) {
    return group.kind === "group" /* Group */;
  }
};

// src/factory.ts
var CannoliFactory = class {
  constructor(canvas, activeNote, contentIsColorless) {
    this.vaultModifierMap = {
      "[": "note" /* Note */,
      "/": "folder" /* Folder */,
      ":": "property" /* Property */
    };
    this.nodeColorMap = {
      "0": "call" /* Call */,
      "1": "call" /* Call */,
      "2": "content" /* Content */,
      "3": "call" /* Call */,
      "4": "call" /* Call */,
      "6": "content" /* Content */
    };
    this.edgePrefixMap = {
      "*": "config" /* Config */,
      "?": "choice" /* Choice */,
      "@": "chat-converter" /* ChatConverter */,
      "<": "list" /* List */,
      "=": "field" /* Field */
    };
    this.edgeColorMap = {
      "2": "config" /* Config */,
      "3": "choice" /* Choice */,
      "4": "chat-converter" /* ChatConverter */,
      "5": "list" /* List */,
      "6": "field" /* Field */
    };
    this.addMessagesModifierMap = {
      "|": true,
      "~": false
    };
    this.defaultAddMessagesMap = {
      ["choice" /* Choice */]: true,
      ["chat" /* Chat */]: true,
      ["system-message" /* SystemMessage */]: true,
      ["chat-converter" /* ChatConverter */]: true,
      ["function" /* Function */]: false,
      ["config" /* Config */]: false,
      ["field" /* Field */]: false,
      ["list" /* List */]: false,
      ["merge" /* Merge */]: false,
      ["variable" /* Variable */]: false,
      ["category" /* Category */]: false,
      ["logging" /* Logging */]: false,
      ["write" /* Write */]: false,
      ["chat-response" /* ChatResponse */]: false
    };
    this.groupPrefixMap = {
      "<": "signified-for-each" /* SignifiedForEach */
    };
    this.groupColorMap = {
      "5": "signified-for-each" /* SignifiedForEach */
    };
    this.cannoliData = canvas;
    this.activeNote = activeNote;
    if (contentIsColorless) {
      this.nodeColorMap = {
        "0": "content" /* Content */,
        "1": "call" /* Call */,
        "2": "content" /* Content */,
        "3": "call" /* Call */,
        "4": "call" /* Call */,
        "6": "call" /* Call */
      };
    }
  }
  getCannoliData() {
    this.cannoliData.nodes.forEach((node) => {
      if (node.color === "1") {
        return;
      }
      const kind2 = this.getVertexKind(node);
      let cannoliData;
      if (kind2 === "node" /* Node */) {
        node = node;
        cannoliData = this.createNodeData(node);
      } else {
        node = node;
        cannoliData = this.createGroupData(node);
      }
      if (cannoliData) {
        node.cannoliData = cannoliData;
      }
    });
    this.cannoliData.edges.forEach((edge) => {
      if (edge.color === "1") {
        return;
      }
      const cannoliData = this.createEdgeData(edge);
      if (cannoliData) {
        edge.cannoliData = cannoliData;
      }
    });
    let verifiedCannoliData = {
      nodes: this.cannoliData.nodes.filter((node) => !!node.cannoliData),
      edges: this.cannoliData.edges.filter((edge) => !!edge.cannoliData)
    };
    verifiedCannoliData = this.createForEachDuplicates(
      verifiedCannoliData
    );
    for (const node of verifiedCannoliData.nodes) {
      if (node.cannoliData) {
        node.cannoliData.dependencies = this.getVertexDependencies(
          node,
          verifiedCannoliData
        );
      }
    }
    for (const edge of verifiedCannoliData.edges) {
      if (edge.cannoliData) {
        edge.cannoliData.dependencies = this.getEdgeDependencies(edge);
      }
    }
    return verifiedCannoliData;
  }
  createNodeData(node) {
    if (node.cannoliData) {
      return node.cannoliData;
    }
    let universalText;
    if (node.type === "file") {
      node = node;
      const fileName = node.file.split("/").pop();
      universalText = fileName == null ? void 0 : fileName.split(".").shift();
      universalText = `{{[[${universalText}]]}}`;
    } else if (node.type === "link") {
      node = node;
      universalText = node.url;
    } else if (node.type === "text") {
      node = node;
      universalText = node.text;
    }
    const kind2 = "node" /* Node */;
    const type2 = this.getNodeType(node);
    const text = universalText || "";
    const references = node.type === "text" || node.type === "file" ? this.parseNodeReferences(node) : [];
    const incomingEdges = this.getIncomingEdges(node.id).map(
      (edge) => edge.id
    );
    const outgoingEdges = this.getOutgoingEdges(node.id).map(
      (edge) => edge.id
    );
    const groups = this.getGroupsForVertex(node);
    const dependencies = [];
    const originalObject = null;
    const status = type2 === "variable" /* Variable */ ? "complete" /* Complete */ : "pending" /* Pending */;
    if (!type2) {
      return null;
    }
    return {
      kind: kind2,
      type: type2,
      text,
      references,
      incomingEdges,
      outgoingEdges,
      groups,
      dependencies,
      originalObject,
      status
    };
  }
  createGroupData(group) {
    if (group.cannoliData) {
      return group.cannoliData;
    }
    const labelInfo = this.parseGroupLabel(group);
    const kind2 = "group" /* Group */;
    const type2 = this.getGroupType(group);
    const text = (labelInfo == null ? void 0 : labelInfo.text) || "";
    const incomingEdges = this.getIncomingEdges(group.id).map(
      (edge) => edge.id
    );
    const outgoingEdges = this.getOutgoingEdges(group.id).map(
      (edge) => edge.id
    );
    const groups = this.getGroupsForVertex(group);
    const members = this.getMembersForGroup(group).filter(
      (member) => {
        var _a2;
        return this.getNodeIndicatedType(
          this.cannoliData.nodes.find(
            (node) => node.id === member
          )
        ) !== null || ((_a2 = this.cannoliData.nodes.find((node) => node.id === member)) == null ? void 0 : _a2.type) === "group";
      }
    );
    const dependencies = [];
    const originalObject = group.originalObject;
    const status = type2 === "basic" /* Basic */ ? "complete" /* Complete */ : "pending" /* Pending */;
    const genericProps = {
      kind: kind2,
      type: type2,
      text,
      incomingEdges,
      outgoingEdges,
      groups,
      members,
      dependencies,
      originalObject,
      status
    };
    if (type2 === "repeat" /* Repeat */ || type2 === "signified-for-each" /* SignifiedForEach */) {
      return {
        ...genericProps,
        currentLoop: (labelInfo == null ? void 0 : labelInfo.completedNumber) || 0,
        maxLoops: (labelInfo == null ? void 0 : labelInfo.totalNumber) || 0
      };
    } else {
      return genericProps;
    }
  }
  createEdgeData(edge) {
    if (edge.cannoliData) {
      return edge.cannoliData;
    }
    const crossingGroups = this.getCrossingGroups(edge);
    let crossingInGroups = [];
    let crossingOutGroups = [];
    if (crossingGroups) {
      crossingInGroups = crossingGroups.crossingInGroups;
      crossingOutGroups = crossingGroups.crossingOutGroups;
    } else {
      crossingInGroups = [];
      crossingOutGroups = [];
    }
    const labelInfo = this.parseEdgeLabel(edge);
    const kind2 = "edge" /* Edge */;
    const type2 = this.getEdgeType(edge);
    const text = (labelInfo == null ? void 0 : labelInfo.text) || "";
    const vaultModifier = (labelInfo == null ? void 0 : labelInfo.vaultModifier) || void 0;
    let addMessages = false;
    if (type2) {
      addMessages = this.defaultAddMessagesMap[type2];
    }
    addMessages = (labelInfo == null ? void 0 : labelInfo.addMessages) !== void 0 && (labelInfo == null ? void 0 : labelInfo.addMessages) !== null ? labelInfo.addMessages : addMessages;
    const dependencies = [];
    const originalObject = null;
    const isReflexive = this.isReflexive(edge);
    const status = "pending" /* Pending */;
    if (!type2) {
      return null;
    }
    return {
      kind: kind2,
      type: type2,
      text,
      addMessages,
      dependencies,
      originalObject,
      crossingInGroups,
      crossingOutGroups,
      status,
      isReflexive,
      vaultModifier
    };
  }
  createForEachDuplicates(data) {
    for (const group of data.nodes) {
      if (group.cannoliData.kind === "group" /* Group */) {
        if (group.cannoliData.type === "signified-for-each" /* SignifiedForEach */) {
          const castGroup = group;
          if (!castGroup || !castGroup.cannoliData.maxLoops) {
            throw new Error(
              "createForEachDuplicates: castGroup is undefined or castGroup.cannoliData.maxLoops is undefined"
            );
          }
          const incomingEdges = castGroup.cannoliData.incomingEdges.map(
            (edgeId) => data.edges.find(
              (edge) => edge.id === edgeId
            )
          );
          const outgoingEdges = castGroup.cannoliData.outgoingEdges.map(
            (edgeId) => data.edges.find(
              (edge) => edge.id === edgeId
            )
          );
          const outgoingMergeEdge = outgoingEdges.find(
            (edge) => edge.cannoliData.type === "merge" /* Merge */
          );
          const mergeNode = outgoingMergeEdge ? data.nodes.find(
            (node) => node.id === outgoingMergeEdge.toNode
            // eslint-disable-next-line no-mixed-spaces-and-tabs
          ) : null;
          if (mergeNode && mergeNode.cannoliData.kind === "node" /* Node */) {
            const castMergeNode = mergeNode;
            const lines = castMergeNode.cannoliData.text.split("\n");
            const loopLine = lines.find(
              (line) => line.startsWith("{#}")
            );
            if (loopLine) {
              let beforeLoopLine = castMergeNode.cannoliData.text.slice(
                0,
                castMergeNode.cannoliData.text.indexOf(
                  loopLine
                )
              );
              const afterLoopLine = castMergeNode.cannoliData.text.slice(
                castMergeNode.cannoliData.text.indexOf(
                  loopLine
                ) + loopLine.length
              );
              const variables = loopLine.match(/{\w+}/g);
              if (variables) {
                for (
                  let i = 0;
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  i < castGroup.cannoliData.maxLoops;
                  i++
                ) {
                  let newLoopLine = loopLine;
                  newLoopLine = newLoopLine.replace(
                    "{#}",
                    `${i + 1}`
                  );
                  variables.forEach((variable) => {
                    newLoopLine = newLoopLine.replace(
                      variable,
                      `{${variable.slice(1, -1)} ${i + 1}}`
                    );
                  });
                  beforeLoopLine = `${beforeLoopLine}${newLoopLine}

`;
                }
                beforeLoopLine = `${beforeLoopLine}${afterLoopLine.trim()}`;
                castMergeNode.text = beforeLoopLine;
                castMergeNode.cannoliData.text = beforeLoopLine;
              }
            }
            castMergeNode.cannoliData.references = this.parseNodeReferences(castMergeNode);
            data.nodes = data.nodes.map((node) => {
              if (node.id === castMergeNode.id) {
                return castMergeNode;
              } else {
                return node;
              }
            });
          }
          const { crossingInEdges, crossingOutEdges, internalEdges } = this.getCrossingAndInternalEdges(castGroup, data);
          for (let i = 0; i < castGroup.cannoliData.maxLoops; i++) {
            this.createDuplicateGroup(
              group,
              i + 1,
              incomingEdges,
              outgoingEdges,
              crossingInEdges,
              crossingOutEdges,
              internalEdges,
              data
            );
          }
          data.nodes = data.nodes.filter(
            (node) => {
              var _a2;
              return node.id !== group.id && !((_a2 = castGroup.cannoliData) == null ? void 0 : _a2.members.includes(node.id));
            }
          );
          data.edges = data.edges.filter(
            (edge) => !incomingEdges.includes(edge) && !outgoingEdges.includes(edge) && !crossingInEdges.includes(edge) && !crossingOutEdges.includes(edge) && !internalEdges.includes(edge)
          );
        }
      }
    }
    return data;
  }
  createDuplicateGroup(group, index, incomingEdges, outgoingEdges, crossingInEdges, crossingOutEdges, internalEdges, canvas) {
    const duplicateGroup = this.duplicateObject(
      group
    );
    const duplicateMembers = this.duplicateObject(
      group.cannoliData.members.map(
        (memberId) => canvas.nodes.find((node) => node.id === memberId)
      )
    );
    const duplicateIncomingEdges = this.duplicateObject(
      incomingEdges
    );
    const duplicateOutgoingEdges = this.duplicateObject(
      outgoingEdges
    );
    const duplicateCrossingInEdges = this.duplicateObject(
      crossingInEdges
    );
    const duplicateCrossingOutEdges = this.duplicateObject(
      crossingOutEdges
    );
    const duplicateInternalEdges = this.duplicateObject(
      internalEdges
    );
    duplicateGroup.cannoliData.originalObject = group.id;
    duplicateGroup.id = `${duplicateGroup.id}-${index}`;
    duplicateGroup.cannoliData.currentLoop = index;
    duplicateGroup.cannoliData.type = "for-each" /* ForEach */;
    duplicateGroup.cannoliData.groups.forEach((groupId) => {
      const groupData = canvas.nodes.find(
        (node) => node.id === groupId
      );
      if (!groupData) {
        throw new Error("createDuplicateGroup: groupData is undefined");
      }
      groupData.cannoliData.members = groupData.cannoliData.members.map(
        (memberId) => {
          if (memberId === group.id) {
            return duplicateGroup.id;
          } else {
            return memberId;
          }
        }
      );
    });
    const incomingListEdge = canvas.edges.find(
      (edge) => edge.toNode === group.id && edge.cannoliData.type === "list" /* List */
    );
    let accumulatorNode = null;
    duplicateMembers.forEach((member) => {
      var _a2;
      member.cannoliData.originalObject = member.id;
      member.id = `${member.id}-${index}`;
      member.cannoliData.groups = member.cannoliData.groups.map(
        (groupId) => {
          if (groupId === group.id) {
            return duplicateGroup.id;
          } else {
            return groupId;
          }
        }
      );
      member.cannoliData.incomingEdges = [];
      member.cannoliData.outgoingEdges = [];
      if (member.cannoliData.kind === "node" /* Node */) {
        const node = member;
        node.cannoliData.references = (_a2 = node.cannoliData.references) == null ? void 0 : _a2.map(
          (reference) => {
            if (reference.type === "variable" /* Variable */ && reference.name === incomingListEdge.cannoliData.text) {
              reference.name = `${reference.name} ${index}`;
              return reference;
            } else {
              return reference;
            }
          }
        );
      }
    });
    duplicateGroup.cannoliData.members = duplicateMembers.map(
      (member) => member.id
    );
    duplicateGroup.cannoliData.incomingEdges = [];
    duplicateGroup.cannoliData.outgoingEdges = [];
    duplicateIncomingEdges.forEach((edge) => {
      edge.cannoliData.originalObject = edge.id;
      edge.id = `${edge.id}-${index}`;
      edge.toNode = duplicateGroup.id;
      duplicateGroup.cannoliData.incomingEdges.push(edge.id);
      if (edge.cannoliData.type === "list" /* List */) {
        edge.cannoliData.type = "field" /* Field */;
        edge.cannoliData.text = `${edge.cannoliData.text} ${index}`;
      }
      const fromNode = canvas.nodes.find(
        (node) => node.id === edge.fromNode
      );
      if (!fromNode) {
        throw new Error("createDuplicateGroup: fromNode is undefined");
      }
      fromNode.cannoliData.outgoingEdges.push(edge.id);
      fromNode.cannoliData.outgoingEdges = fromNode.cannoliData.outgoingEdges.filter(
        (edgeId) => edgeId !== edge.cannoliData.originalObject
      );
    });
    duplicateOutgoingEdges.forEach((edge) => {
      edge.cannoliData.originalObject = edge.id;
      edge.id = `${edge.id}-${index}`;
      edge.fromNode = duplicateGroup.id;
      duplicateGroup.cannoliData.outgoingEdges.push(edge.id);
      if (edge.cannoliData.type === "merge" /* Merge */) {
        edge.cannoliData.type = "variable" /* Variable */;
        edge.cannoliData.text = `${edge.cannoliData.text} ${index}`;
        accumulatorNode = canvas.nodes.find(
          (node) => node.id === edge.toNode
        );
      }
      const toNode = canvas.nodes.find(
        (node) => node.id === edge.toNode
      );
      if (!toNode) {
        throw new Error("createDuplicateGroup: toNode is undefined");
      }
      toNode.cannoliData.incomingEdges.push(edge.id);
      toNode.cannoliData.incomingEdges = toNode.cannoliData.incomingEdges.filter(
        (edgeId) => edgeId !== edge.cannoliData.originalObject
      );
    });
    duplicateCrossingInEdges.forEach((edge) => {
      edge.cannoliData.originalObject = edge.id;
      edge.id = `${edge.id}-${index}`;
      edge.toNode = `${edge.toNode}-${index}`;
      const toNode = duplicateMembers.find(
        (node) => node.id === edge.toNode
      );
      if (!toNode) {
        throw new Error("createDuplicateGroup: toNode is undefined");
      }
      toNode.cannoliData.incomingEdges.push(edge.id);
      const fromNode = canvas.nodes.find(
        (node) => node.id === edge.fromNode
      );
      if (!fromNode) {
        throw new Error("createDuplicateGroup: fromNode is undefined");
      }
      fromNode.cannoliData.outgoingEdges.push(edge.id);
      fromNode.cannoliData.outgoingEdges = fromNode.cannoliData.outgoingEdges.filter(
        (edgeId) => edgeId !== edge.cannoliData.originalObject
      );
      edge.cannoliData.crossingInGroups = edge.cannoliData.crossingInGroups.map((groupId) => {
        if (groupId === group.id) {
          return duplicateGroup.id;
        } else {
          return groupId;
        }
      });
    });
    duplicateCrossingOutEdges.forEach((edge) => {
      edge.cannoliData.originalObject = edge.id;
      edge.id = `${edge.id}-${index}`;
      edge.fromNode = `${edge.fromNode}-${index}`;
      if (edge.toNode === (accumulatorNode == null ? void 0 : accumulatorNode.id)) {
        edge.cannoliData.text = `${edge.cannoliData.text} ${index}`;
      }
      const fromNode = duplicateMembers.find(
        (node) => node.id === edge.fromNode
      );
      if (!fromNode) {
        throw new Error("createDuplicateGroup: fromNode is undefined");
      }
      fromNode.cannoliData.outgoingEdges.push(edge.id);
      const toNode = canvas.nodes.find(
        (node) => node.id === edge.toNode
      );
      if (!toNode) {
        throw new Error("createDuplicateGroup: toNode is undefined");
      }
      toNode.cannoliData.incomingEdges.push(edge.id);
      toNode.cannoliData.incomingEdges = toNode.cannoliData.incomingEdges.filter(
        (edgeId) => edgeId !== edge.cannoliData.originalObject
      );
      edge.cannoliData.crossingOutGroups = edge.cannoliData.crossingOutGroups.map((groupId) => {
        if (groupId === group.id) {
          return duplicateGroup.id;
        } else {
          return groupId;
        }
      });
    });
    duplicateInternalEdges.forEach((edge) => {
      var _a2, _b;
      edge.fromNode = (_a2 = duplicateMembers.find(
        (member) => member.cannoliData.originalObject === edge.fromNode
      )) == null ? void 0 : _a2.id;
      edge.toNode = (_b = duplicateMembers.find(
        (member) => member.cannoliData.originalObject === edge.toNode
      )) == null ? void 0 : _b.id;
    });
    canvas.nodes.push(duplicateGroup);
    canvas.nodes.push(...duplicateMembers);
    canvas.edges.push(
      ...duplicateIncomingEdges,
      ...duplicateOutgoingEdges,
      ...duplicateCrossingInEdges,
      ...duplicateCrossingOutEdges,
      ...duplicateInternalEdges
    );
  }
  duplicateObject(data) {
    return JSON.parse(JSON.stringify(data));
  }
  getCrossingAndInternalEdges(group, canvas) {
    const crossingInEdges = [];
    const crossingOutEdges = [];
    const internalEdges = [];
    for (const member of group.cannoliData.members) {
      const memberData = canvas.nodes.find(
        (node) => node.id === member
      );
      for (const edgeId of memberData.cannoliData.incomingEdges) {
        const edgeData = canvas.edges.find(
          (edge) => edge.id === edgeId
        );
        if (edgeData.cannoliData.crossingInGroups.includes(group.id)) {
          crossingInEdges.push(edgeData);
        } else {
          internalEdges.push(edgeData);
        }
      }
      for (const edgeId of memberData.cannoliData.outgoingEdges) {
        const edgeData = canvas.edges.find(
          (edge) => edge.id === edgeId
        );
        if (edgeData.cannoliData.crossingOutGroups.includes(group.id)) {
          crossingOutEdges.push(edgeData);
        } else {
          internalEdges.push(edgeData);
        }
      }
    }
    return {
      crossingInEdges,
      crossingOutEdges,
      internalEdges
    };
  }
  getVertexDependencies(vertex, data) {
    var _a2, _b, _c, _d;
    const dependencies = [];
    const incomingEdges = (_a2 = vertex.cannoliData) == null ? void 0 : _a2.incomingEdges;
    if (!incomingEdges) {
      throw new Error(
        "setVertexDependencies: vertex.cannoliData.incomingEdges is undefined"
      );
    }
    incomingEdges.forEach((edge) => {
      const edgeData = data.edges.find(
        (edgeData2) => edgeData2.id === edge
      );
      if (!edgeData) {
        throw new Error("setVertexDependencies: edgeData is undefined");
      }
      if (!edgeData.cannoliData) {
        return;
      }
      dependencies.push(edge);
    });
    const groups = (_b = vertex.cannoliData) == null ? void 0 : _b.groups;
    groups == null ? void 0 : groups.forEach((group) => {
      var _a3;
      const groupData = data.nodes.find(
        (groupData2) => groupData2.id === group
      );
      if (!groupData) {
        throw new Error(
          "setVertexDependencies: groupData is undefined"
        );
      }
      const incomingEdges2 = (_a3 = groupData.cannoliData) == null ? void 0 : _a3.incomingEdges;
      if (!incomingEdges2) {
        throw new Error(
          "setVertexDependencies: group.cannoliData.incomingEdges is undefined"
        );
      }
      incomingEdges2.forEach((edge) => {
        const edgeData = data.edges.find(
          (edgeData2) => edgeData2.id === edge
        );
        if (!edgeData) {
          throw new Error(
            "setVertexDependencies: edgeData is undefined"
          );
        }
        if (!edgeData.cannoliData) {
          return;
        }
        if (edgeData.cannoliData.isReflexive) {
          return;
        } else {
          dependencies.push(edge);
        }
      });
    });
    if (((_c = vertex.cannoliData) == null ? void 0 : _c.kind) === "group" /* Group */) {
      const group = vertex;
      const members = (_d = group.cannoliData) == null ? void 0 : _d.members;
      const existingMembers = members == null ? void 0 : members.filter(
        (member) => data.nodes.some((node) => node.id === member)
      );
      if (existingMembers) {
        dependencies.push(...existingMembers);
      }
    }
    return dependencies;
  }
  getEdgeDependencies(edge) {
    const dependencies = [];
    dependencies.push(edge.fromNode);
    const cannoliData = edge.cannoliData;
    if (!cannoliData) {
      throw new Error("getEdgeDependencies: cannoliData is undefined");
    }
    const crossingOutGroups = cannoliData.crossingOutGroups;
    dependencies.push(...crossingOutGroups);
    return dependencies;
  }
  getNodeType(node) {
    const indicatedType = this.getNodeIndicatedType(node);
    if (indicatedType === "floating" /* Floating */) {
      return "variable" /* Variable */;
    } else if (indicatedType === "content" /* Content */) {
      return this.getContentNodeType(node);
    } else if (indicatedType === "call" /* Call */) {
      const textNode = node;
      return this.getCallNodeType(textNode);
    } else {
      return null;
    }
  }
  getCallNodeType(vertex) {
    const incomingEdges = this.getIncomingEdges(vertex.id);
    const outgoingEdges = this.getOutgoingEdges(vertex.id);
    if (incomingEdges.some(
      (edge) => this.getEdgeType(edge) === "merge" /* Merge */
    )) {
      if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "category" /* Category */
      )) {
        return "categorize" /* Categorize */;
      } else if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "choice" /* Choice */
      )) {
        const choiceEdges = outgoingEdges.filter(
          (edge) => this.getEdgeType(edge) === "choice" /* Choice */
        );
        const choiceLabels = choiceEdges.map(
          (edge) => this.parseEdgeLabel(edge)
        );
        if (choiceLabels.every((label) => label === choiceLabels[0])) {
          return "select" /* Select */;
        } else {
          return "choose" /* Choose */;
        }
      } else if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "field" /* Field */ || this.getEdgeType(edge) === "list" /* List */
      )) {
        return "form" /* Form */;
      } else {
        return "accumulate" /* Accumulate */;
      }
    } else {
      if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "field" /* Field */ || this.getEdgeType(edge) === "list" /* List */
      )) {
        return "form" /* Form */;
      } else if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "choice" /* Choice */
      )) {
        return "choose" /* Choose */;
      } else if (outgoingEdges.some(
        (edge) => this.getEdgeType(edge) === "category" /* Category */
      )) {
        return "categorize" /* Categorize */;
      } else {
        return "standard-call" /* StandardCall */;
      }
    }
  }
  getContentNodeType(node) {
    if (node.type === "file") {
      return "reference" /* Reference */;
    }
    let text = "";
    if (node.type === "text") {
      node = node;
      text = node.text;
    } else {
      node = node;
      text = node.url;
    }
    if (node.color === "2") {
      return "http" /* Http */;
    }
    if (text.startsWith('""') && text.endsWith('""')) {
      return "formatter" /* Formatter */;
    }
    if (text.trim().startsWith("{{") && text.trim().endsWith("}}") && !text.trim().includes("\n") && text.trim().split("{{").length === 2 && text.trim().split("}}").length === 2) {
      return "reference" /* Reference */;
    }
    return "standard-content" /* StandardContent */;
  }
  getVertexKind(vertex) {
    switch (vertex.type) {
      case "file":
        return "node" /* Node */;
      case "link":
        return "node" /* Node */;
      case "text":
        return "node" /* Node */;
      case "group":
        return "group" /* Group */;
    }
  }
  getNodeIndicatedType(vertex) {
    var _a2;
    if (!this.hasEdges(vertex.id)) {
      if (this.isFloatingNode(vertex.id)) {
        return "floating" /* Floating */;
      } else {
        return null;
      }
    }
    switch (vertex.type) {
      case "file":
        return "content" /* Content */;
      case "link":
        return "content" /* Content */;
      case "text":
        if (!vertex.color) {
          vertex.color = "0";
        }
        if (this.nodeColorMap[vertex.color]) {
          return this.nodeColorMap[(_a2 = vertex.color) != null ? _a2 : "0"];
        }
    }
    return null;
  }
  getEdgeType(edge) {
    if (edge.color) {
      if (this.edgeColorMap[edge.color]) {
        if (this.edgeColorMap[edge.color] === "choice" /* Choice */) {
          return this.getChoiceEdgeSubtype(edge);
        } else if (this.edgeColorMap[edge.color] === "field" /* Field */) {
          return "field" /* Field */;
        } else if (this.edgeColorMap[edge.color] === "chat-converter" /* ChatConverter */) {
          const sourceNode = this.getNode(edge.fromNode);
          const targetNode = this.getNode(edge.toNode);
          if (sourceNode && this.getNodeIndicatedType(sourceNode) === "call" /* Call */ && targetNode && this.getNodeIndicatedType(targetNode) === "content" /* Content */) {
            return "chat-response" /* ChatResponse */;
          } else {
            return "chat-converter" /* ChatConverter */;
          }
        } else if (this.edgeColorMap[edge.color] === "config" /* Config */) {
          if (edge.label && edge.label.length > 0) {
            return "config" /* Config */;
          } else {
            return "logging" /* Logging */;
          }
        }
        return this.edgeColorMap[edge.color];
      }
    } else if (edge.label && edge.label.length > 0) {
      if (this.edgePrefixMap[edge.label[0]]) {
        if (this.edgePrefixMap[edge.label[0]] === "choice" /* Choice */) {
          return this.getChoiceEdgeSubtype(edge);
        } else if (this.edgePrefixMap[edge.label[0]] === "field" /* Field */) {
          return this.getKeyEdgeSubtype(edge);
        } else if (this.edgePrefixMap[edge.label[0]] === "config" /* Config */) {
          if (edge.label.length > 1) {
            return "config" /* Config */;
          } else {
            return "logging" /* Logging */;
          }
        }
        return this.edgePrefixMap[edge.label[0]];
      } else {
        return "variable" /* Variable */;
      }
    } else if (!edge.label || edge.label.length === 0) {
      const sourceNode = this.getVertex(edge.fromNode);
      const targetNode = this.getVertex(edge.toNode);
      if (!sourceNode || !targetNode) {
        throw new Error(
          `Edge: ${edge.label} source or target not found`
        );
      }
      if (sourceNode.kind === "group" /* Group */ || targetNode.kind === "group" /* Group */) {
        return "chat" /* Chat */;
      }
      const sourceIndicatedType = this.getNodeIndicatedType(
        sourceNode
      );
      const targetIndicatedType = this.getNodeIndicatedType(
        targetNode
      );
      if (sourceIndicatedType === "content" /* Content */) {
        if (targetIndicatedType === "content" /* Content */) {
          return "write" /* Write */;
        } else {
          return "system-message" /* SystemMessage */;
        }
      } else {
        if (targetIndicatedType === "content" /* Content */) {
          return "write" /* Write */;
        } else {
          return "chat" /* Chat */;
        }
      }
    }
    return null;
  }
  getChoiceEdgeSubtype(edge) {
    const targetGroup = this.getGroup(edge.toNode);
    if (targetGroup) {
      if (this.getGroupType(targetGroup) === "signified-for-each" /* SignifiedForEach */) {
        return "category" /* Category */;
      } else {
        return "choice" /* Choice */;
      }
    } else {
      return "choice" /* Choice */;
    }
  }
  getKeyEdgeSubtype(edge) {
    const sourceGroup = this.getGroup(edge.fromNode);
    const targetGroup = this.getGroup(edge.toNode);
    if (sourceGroup && (this.getGroupType(sourceGroup) === "signified-for-each" /* SignifiedForEach */ || this.getGroupType(sourceGroup) === "signified-for-each" /* SignifiedForEach */)) {
      return "merge" /* Merge */;
    } else if (targetGroup && this.getGroupType(targetGroup) === "signified-for-each" /* SignifiedForEach */) {
      return "list" /* List */;
    }
    return "field" /* Field */;
  }
  getGroupType(group) {
    if (group.color) {
      if (this.groupColorMap[group.color]) {
        return this.groupColorMap[group.color];
      }
    }
    if (group.label) {
      if (this.groupPrefixMap[group.label[0]]) {
        return this.groupPrefixMap[group.label[0]];
      }
      const labelInfo = this.parseGroupLabel(group);
      if (!labelInfo) {
        return "basic" /* Basic */;
      }
      if (labelInfo.isLoop) {
        return "repeat" /* Repeat */;
      } else {
        return "basic" /* Basic */;
      }
    }
    return "basic" /* Basic */;
  }
  getEdge(id) {
    return this.cannoliData.edges.find((edge) => edge.id === id);
  }
  getVertex(id) {
    return this.cannoliData.nodes.find((node) => node.id === id);
  }
  getNode(id) {
    const node = this.cannoliData.nodes.find((node2) => node2.id === id);
    if ((node == null ? void 0 : node.type) === "file" || (node == null ? void 0 : node.type) === "text" || (node == null ? void 0 : node.type) === "link") {
      return node;
    } else {
      return void 0;
    }
  }
  getGroup(id) {
    const group = this.cannoliData.nodes.find((group2) => group2.id === id);
    if ((group == null ? void 0 : group.type) === "group") {
      return group;
    }
  }
  parseEdgeLabel(edge) {
    if (!edge.label) {
      return null;
    }
    let text = edge.label;
    let vaultModifier = null;
    let addMessages = null;
    if (this.vaultModifierMap[edge.label[0]]) {
      vaultModifier = this.vaultModifierMap[edge.label[0]];
      text = text.slice(1);
    } else if (this.vaultModifierMap[edge.label.slice(0, 2)]) {
      vaultModifier = this.vaultModifierMap[edge.label.slice(0, 2)];
      text = text.slice(2);
    }
    if (this.addMessagesModifierMap[edge.label[edge.label.length - 1]] !== void 0) {
      addMessages = this.addMessagesModifierMap[edge.label[edge.label.length - 1]];
      text = text.slice(0, -1);
    }
    return {
      text,
      vaultModifier,
      addMessages
    };
  }
  parseGroupLabel(group) {
    let isLoop = false;
    let text = group.label;
    let completedNumber = null;
    let totalNumber = null;
    if (!text) {
      return null;
    }
    if (this.groupPrefixMap[text[0]]) {
      text = text.slice(1);
    }
    if (text.includes("/")) {
      const splitText = text.split("/");
      if (Number.isInteger(+splitText[0]) && Number.isInteger(+splitText[1])) {
        isLoop = true;
        completedNumber = +splitText[0];
        totalNumber = +splitText[1];
      }
    } else if (Number.isInteger(+text)) {
      isLoop = true;
      completedNumber = 0;
      totalNumber = +text;
    }
    return {
      isLoop,
      text,
      completedNumber,
      totalNumber
    };
  }
  parseNodeReferences(node) {
    const unifiedPattern = /{{(.*?)}}/g;
    const references = [];
    const textCopy = node.text;
    let match;
    while ((match = unifiedPattern.exec(textCopy)) !== null) {
      const content = match[1];
      const reference = {
        name: "",
        type: "variable" /* Variable */,
        // default type
        shouldExtract: false
      };
      let innerMatch;
      if (innerMatch = /^NOTE([\W]*)$/.exec(content)) {
        reference.type = "note" /* Note */;
        reference.shouldExtract = false;
        reference.name = this.activeNote;
        this.handleModifiers(reference, innerMatch[1]);
      } else if (innerMatch = /^SELECTION([\W]*)$/.exec(content)) {
        reference.type = "selection" /* Selection */;
        reference.shouldExtract = false;
        reference.name = "SELECTION";
        this.handleModifiers(reference, innerMatch[1]);
      } else if (innerMatch = /^\[\[(.*?)\]\]([\W]*)$/.exec(content)) {
        reference.type = "note" /* Note */;
        reference.shouldExtract = true;
        reference.name = innerMatch[1];
        this.handleModifiers(reference, innerMatch[2]);
      } else if (innerMatch = /^\[(.*?)\]$/.exec(content)) {
        reference.type = "floating" /* Floating */;
        reference.shouldExtract = true;
        reference.name = innerMatch[1];
      } else if (innerMatch = /^@(.*?)([\W]*)$/.exec(content)) {
        reference.type = "variable" /* Variable */;
        reference.shouldExtract = true;
        reference.name = innerMatch[1];
        this.handleModifiers(reference, innerMatch[2]);
      } else if (innerMatch = /^\+@(.*?)([\W]*)$/.exec(content)) {
        reference.type = "create-note" /* CreateNote */;
        reference.shouldExtract = true;
        reference.name = innerMatch[1];
        this.handleModifiers(reference, innerMatch[2]);
      } else {
        reference.name = content;
      }
      references.push(reference);
    }
    return references;
  }
  handleModifiers(reference, modifiers) {
    if (modifiers.includes("!#")) {
      reference.includeName = false;
    } else if (modifiers.includes("#")) {
      reference.includeName = true;
    }
    if (modifiers.includes("!^")) {
      reference.includeProperties = false;
    } else if (modifiers.includes("^")) {
      reference.includeProperties = true;
    }
  }
  getIncomingEdges(id) {
    return this.cannoliData.edges.filter(
      (edge) => edge.toNode === id && this.isValidEdge(edge)
    );
  }
  getOutgoingEdges(id) {
    return this.cannoliData.edges.filter(
      (edge) => edge.fromNode === id && this.isValidEdge(edge)
    );
  }
  hasEdges(id) {
    if (this.getIncomingEdges(id).length > 0 || this.getOutgoingEdges(id).length > 0) {
      return true;
    } else {
      return false;
    }
  }
  isValidEdge(edge) {
    if (edge.fromEnd === "none" && edge.toEnd === "none") {
      return false;
    } else if (edge.color === "1") {
      return false;
    } else {
      return true;
    }
  }
  isFloatingNode(id) {
    var _a2;
    const node = this.getNode(id);
    const firstLine = (_a2 = node == null ? void 0 : node.text) == null ? void 0 : _a2.split("\n")[0];
    if ((firstLine == null ? void 0 : firstLine.startsWith("[")) && (firstLine == null ? void 0 : firstLine.endsWith("]"))) {
      return true;
    } else {
      return false;
    }
  }
  createRectangle(x, y, width, height) {
    return {
      x,
      y,
      width,
      height,
      x_right: x + width,
      y_bottom: y + height
    };
  }
  encloses(a, b) {
    return a.x <= b.x && a.y <= b.y && a.x_right >= b.x_right && a.y_bottom >= b.y_bottom;
  }
  overlaps(a, b) {
    const horizontalOverlap = a.x < b.x_right && a.x_right > b.x;
    const verticalOverlap = a.y < b.y_bottom && a.y_bottom > b.y;
    const overlap = horizontalOverlap && verticalOverlap;
    return overlap && !this.encloses(a, b) && !this.encloses(b, a);
  }
  getGroupsForVertex(vertex) {
    const groups = [];
    const currentVertexRectangle = this.createRectangle(
      vertex.x,
      vertex.y,
      vertex.width,
      vertex.height
    );
    const allGroups = this.cannoliData.nodes.filter(
      (node) => this.getVertexKind(node) === "group" /* Group */ && node.id !== vertex.id
    );
    for (const group of allGroups) {
      const groupRectangle = this.createRectangle(
        group.x,
        group.y,
        group.width,
        group.height
      );
      if (this.encloses(groupRectangle, currentVertexRectangle)) {
        groups.push(group);
      }
    }
    groups.sort((a, b) => {
      const aArea = a.width * a.height;
      const bArea = b.width * b.height;
      return aArea - bArea;
    });
    return groups.map((group) => group.id);
  }
  getMembersForGroup(group) {
    const members = [];
    const currentGroupRectangle = this.createRectangle(
      group.x,
      group.y,
      group.width,
      group.height
    );
    for (const vertex of this.cannoliData.nodes) {
      if (vertex.id === group.id) {
        continue;
      }
      const vertexRectangle = this.createRectangle(
        vertex.x,
        vertex.y,
        vertex.width,
        vertex.height
      );
      if (this.encloses(currentGroupRectangle, vertexRectangle)) {
        members.push(vertex.id);
      }
    }
    return members;
  }
  getCrossingGroups(edge) {
    const source = this.getVertex(edge.fromNode);
    const target = this.getVertex(edge.toNode);
    if (!source || !target) {
      throw new Error("Source or target vertex is null");
    }
    if (!source.cannoliData || !target.cannoliData) {
      return null;
    }
    let crossingOutGroups = [];
    let crossingInGroups = [];
    const sourceGroups = source.cannoliData.groups.map(
      (groupId) => this.getVertex(groupId)
    );
    const targetGroups = target.cannoliData.groups.map(
      (groupId) => this.getVertex(groupId)
    );
    const sharedGroup = sourceGroups.find(
      (group) => targetGroups.includes(group)
    );
    if (sharedGroup === void 0) {
      crossingOutGroups = [...sourceGroups];
      crossingInGroups = [...targetGroups].reverse();
    } else {
      const sourceIndex = sourceGroups.indexOf(sharedGroup);
      crossingOutGroups = sourceGroups.slice(0, sourceIndex);
      const targetIndex = targetGroups.indexOf(sharedGroup);
      const tempCrossingInGroups = targetGroups.slice(0, targetIndex);
      crossingInGroups = tempCrossingInGroups.reverse();
    }
    const sourceAsGroup = this.getGroup(source.id);
    if (sourceAsGroup) {
      if (targetGroups.includes(sourceAsGroup)) {
        crossingInGroups.shift();
      }
    }
    const targetAsGroup = this.getGroup(target.id);
    if (targetAsGroup) {
      if (sourceGroups.includes(targetAsGroup)) {
        crossingOutGroups.pop();
      }
    }
    return {
      crossingOutGroups: crossingOutGroups.map((group) => group.id),
      crossingInGroups: crossingInGroups.map((group) => group.id)
    };
  }
  isReflexive(edge) {
    const source = this.getVertex(edge.fromNode);
    const target = this.getVertex(edge.toNode);
    if (!source || !target) {
      throw new Error("Source or target vertex is null");
    }
    if (!source.cannoliData || !target.cannoliData) {
      return true;
    }
    if (target.cannoliData.groups.includes(source.id)) {
      return true;
    }
    if (source.cannoliData.groups.includes(target.id)) {
      return true;
    }
    return false;
  }
};

// src/run.ts
var import_obsidian2 = require("obsidian");

// node_modules/yocto-queue/index.js
var Node = class {
  constructor(value) {
    __publicField(this, "value");
    __publicField(this, "next");
    this.value = value;
  }
};
var _head, _tail, _size;
var Queue = class {
  constructor() {
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _size, void 0);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();

// node_modules/p-limit/index.js
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve(result);
    try {
      await result;
    } catch (e) {
    }
    next();
  };
  const enqueue = (fn, resolve, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve) => {
    enqueue(fn, resolve, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}

// src/run.ts
var Run = class {
  constructor({
    graph,
    onFinish,
    isMock,
    canvas,
    llm,
    cannoli
  }) {
    this.graph = {};
    this.isStopped = false;
    this.currentNote = null;
    this.selection = null;
    this.modelInfo = {
      "gpt-4-1106-preview": {
        name: "gpt-4-1106-preview",
        promptTokenPrice: 0.01 / 1e3,
        // $0.01 per 1K tokens
        completionTokenPrice: 0.03 / 1e3
        // $0.03 per 1K tokens
      },
      "gpt-4-1106-vision-preview": {
        name: "gpt-4-1106-vision-preview",
        promptTokenPrice: 0.01 / 1e3,
        // $0.01 per 1K tokens
        completionTokenPrice: 0.03 / 1e3
        // $0.03 per 1K tokens
      },
      "gpt-4": {
        name: "gpt-4",
        promptTokenPrice: 0.03 / 1e3,
        // $0.03 per 1K tokens
        completionTokenPrice: 0.06 / 1e3
        // $0.06 per 1K tokens
      },
      "gpt-4-32k": {
        name: "gpt-4-32k",
        promptTokenPrice: 0.06 / 1e3,
        // $0.06 per 1K tokens
        completionTokenPrice: 0.12 / 1e3
        // $0.12 per 1K tokens
      },
      "gpt-3.5-turbo": {
        name: "gpt-3.5-turbo",
        promptTokenPrice: 1e-3 / 1e3,
        // $0.0010 per 1K tokens
        completionTokenPrice: 2e-3 / 1e3
        // $0.0020 per 1K tokens
      },
      "gpt-3.5-turbo-1106": {
        name: "gpt-3.5-turbo-1106",
        promptTokenPrice: 1e-3 / 1e3,
        // $0.0010 per 1K tokens
        completionTokenPrice: 2e-3 / 1e3
        // $0.0020 per 1K tokens
      },
      "gpt-3.5-turbo-instruct": {
        name: "gpt-3.5-turbo-instruct",
        promptTokenPrice: 15e-4 / 1e3,
        // $0.0015 per 1K tokens
        completionTokenPrice: 2e-3 / 1e3
        // $0.0020 per 1K tokens
      }
    };
    this.parseBodyTemplate = (template, body) => {
      const variablesInTemplate = (template.match(/\{\{.*?\}\}/g) || []).map(
        (v) => v.slice(2, -2)
      );
      if (variablesInTemplate.length === 1) {
        let valueToReplace;
        if (typeof body === "string") {
          valueToReplace = body;
        } else if (Object.keys(body).length === 1) {
          valueToReplace = Object.values(body)[0];
        } else {
          throw new Error(
            `Expected only one variable in the template, but found multiple values. This node expects the variable:
  - ${variablesInTemplate[0]}

Write to this node using a single variable arrow or a write arrow.`
          );
        }
        return template.replace(
          new RegExp(`{{${variablesInTemplate[0]}}}`, "g"),
          valueToReplace.replace(/\n/g, "\\n").replace(/"/g, '\\"')
        );
      }
      let parsedTemplate = template;
      if (typeof body === "object") {
        for (const variable of variablesInTemplate) {
          if (!(variable in body)) {
            throw new Error(
              `Missing value for variable "${variable}" in available arrows. This template requires the following variables:
${variablesInTemplate.map((v) => `  - ${v}`).join("\n")}`
            );
          }
          parsedTemplate = parsedTemplate.replace(
            new RegExp(`{{${variable}}}`, "g"),
            body[variable].replace(/\n/g, "\\n").replace(/"/g, '\\"')
          );
        }
        for (const key in body) {
          if (!variablesInTemplate.includes(key)) {
            throw new Error(
              `Extra variable "${key}" in available arrows. This template requires the following variables:
${variablesInTemplate.map((v) => `  - ${v}`).join("\n")}`
            );
          }
        }
      } else {
        throw new Error(
          `This action node expected multiple variables, but only found one. This node expects the following variables:
${variablesInTemplate.map((v) => `  - ${v}`).join("\n")}`
        );
      }
      return parsedTemplate;
    };
    var _a2, _b, _c, _d, _e;
    this.graph = graph;
    this.onFinish = onFinish != null ? onFinish : (stoppage) => {
    };
    this.isMock = isMock != null ? isMock : false;
    this.cannoli = cannoli;
    this.canvas = canvas != null ? canvas : null;
    this.llm = llm != null ? llm : null;
    this.usage = {};
    this.llmLimit = pLimit(this.cannoli.settings.pLimit);
    this.currentNote = `[[${(_a2 = this.cannoli.app.workspace.getActiveFile()) == null ? void 0 : _a2.basename}]]`;
    this.selection = ((_c = (_b = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _b.editor) == null ? void 0 : _c.getSelection()) ? (_e = (_d = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _d.editor) == null ? void 0 : _e.getSelection() : null;
    for (const object of Object.values(this.graph)) {
      object.setRun(this);
    }
  }
  async start() {
    this.setupListeners();
    this.reset();
    this.validate();
    if (this.canvas && this.isMock) {
      await this.canvas.enqueueRemoveAllErrorNodes();
    }
    for (const object of Object.values(this.graph)) {
      if (object.dependencies.length === 0) {
        object.execute();
      }
    }
  }
  error(message) {
    this.isStopped = true;
    this.onFinish({
      reason: "error",
      usage: this.calculateAllLLMCosts(),
      totalCost: this.getTotalCost(),
      message
    });
    throw new Error(message);
  }
  stop() {
    this.isStopped = true;
    this.onFinish({
      reason: "user",
      usage: this.calculateAllLLMCosts(),
      totalCost: this.getTotalCost()
    });
  }
  reset() {
    this.isStopped = false;
    for (const object of Object.values(this.graph)) {
      object.reset();
    }
  }
  validate() {
    for (const object of Object.values(this.graph)) {
      object.validate();
    }
    if (!this.isDAG(this.graph)) {
      for (const object of Object.values(this.graph)) {
        if (object instanceof CannoliVertex)
          object.error(
            "Cycle detected in graph. Please make sure the graph is a DAG.\n(exception: edges between groups and their members)"
          );
      }
    }
  }
  setupListeners() {
    for (const object of Object.values(this.graph)) {
      object.addEventListener("update", (event) => {
        this.objectUpdated(
          event.detail.obj,
          event.detail.status,
          event.detail.message
        );
      });
    }
  }
  getDefaultConfig() {
    var _a2, _b;
    return (_b = (_a2 = this.llm) == null ? void 0 : _a2.getConfig()) != null ? _b : {};
  }
  objectUpdated(object, status, message) {
    switch (status) {
      case "complete" /* Complete */: {
        this.objectCompleted(object);
        break;
      }
      case "rejected" /* Rejected */: {
        this.objectRejected(object);
        break;
      }
      case "executing" /* Executing */: {
        this.objectExecuting(object);
        break;
      }
      case "pending" /* Pending */: {
        this.objectPending(object);
        break;
      }
      case "error" /* Error */: {
        this.objectError(object, message);
        break;
      }
      case "warning" /* Warning */: {
        this.objectWarning(object, message);
        break;
      }
      default: {
        throw new Error(`Unknown status: ${status}`);
      }
    }
  }
  objectCompleted(object) {
    if (!this.isMock && this.canvas && object.originalObject === null) {
      if (object instanceof CallNode) {
        this.canvas.enqueueChangeNodeColor(object.id, "4");
      } else if (object instanceof ContentNode || object instanceof FloatingNode) {
        this.canvas.enqueueChangeNodeText(object.id, object.text);
      }
    }
    if (this.allObjectsFinished() && !this.isStopped) {
      this.isStopped = true;
      this.onFinish({
        reason: "complete",
        usage: this.calculateAllLLMCosts(),
        totalCost: this.getTotalCost()
      });
    }
  }
  objectRejected(object) {
    if (this.allObjectsFinished() && !this.isStopped) {
      this.isStopped = true;
      this.onFinish({
        reason: "complete",
        usage: this.calculateAllLLMCosts(),
        totalCost: this.getTotalCost()
      });
    }
  }
  objectExecuting(object) {
    if (!this.isMock && this.canvas && object instanceof CallNode && object.originalObject === null) {
      this.canvas.enqueueChangeNodeColor(object.id, "3");
    }
  }
  objectPending(object) {
    if (this.canvas && object instanceof CallNode) {
      if (this.cannoli.settings.contentIsColorless) {
        this.canvas.enqueueChangeNodeColor(object.id, "6");
      } else {
        this.canvas.enqueueChangeNodeColor(object.id, "0");
      }
    } else if (this.canvas && object instanceof ContentNode && object.text === "") {
      this.canvas.enqueueChangeNodeText(object.id, "");
    }
  }
  objectError(object, message) {
    if (this.canvas && object instanceof CannoliVertex) {
      this.canvas.enqueueAddErrorNode(
        object.id,
        message != null ? message : "Unknown error"
      );
    }
    this.error(message != null ? message : "Unknown error");
  }
  objectWarning(object, message) {
    if (this.canvas && object instanceof CannoliVertex) {
      this.canvas.enqueueAddWarningNode(
        object.id,
        message != null ? message : "Unknown warning"
      );
    }
  }
  allObjectsFinished() {
    for (const object of Object.values(this.graph)) {
      if (object.status !== "complete" /* Complete */ && object.status !== "rejected" /* Rejected */) {
        return false;
      }
    }
    return true;
  }
  isDAG(objects) {
    const states = /* @__PURE__ */ new Map();
    function visit(obj) {
      if (states.get(obj) === 1 /* VISITING */) {
        return false;
      }
      if (states.get(obj) === 2 /* VISITED */) {
        return true;
      }
      states.set(obj, 1 /* VISITING */);
      for (const dependency of obj.getAllDependencies()) {
        if (!visit(dependency)) {
          return false;
        }
      }
      states.set(obj, 2 /* VISITED */);
      return true;
    }
    for (const obj of Object.values(objects)) {
      if (states.get(obj) !== 2 /* VISITED */) {
        if (!visit(obj)) {
          return false;
        }
      }
    }
    return true;
  }
  async callLLM(request, verbose) {
    return this.llmLimit(async () => {
      if (this.isMock || !this.llm || !this.llm.initialized) {
        return this.createMockFunctionResponse(request);
      }
      try {
        const response = await this.llm.getCompletion(request);
        const completion = Llm.getFirstCompletionMessage(response);
        if (verbose) {
          console.log(
            "Input Messages:\n" + JSON.stringify(request.messages, null, 2) + "\n\nResponse Message:\n" + JSON.stringify(completion, null, 2)
          );
        }
        const responseUsage = Llm.getCompletionResponseUsage(response);
        if (responseUsage) {
          if (!this.modelInfo[request.model]) {
            this.modelInfo[request.model] = {
              name: request.model,
              promptTokenPrice: 0,
              completionTokenPrice: 0
            };
          }
          const model = this.modelInfo[request.model];
          if (!this.usage[model.name]) {
            this.usage[model.name] = {
              model,
              modelUsage: {
                promptTokens: 0,
                completionTokens: 0,
                apiCalls: 0,
                totalCost: 0
              }
            };
          }
          this.usage[model.name].modelUsage.promptTokens += responseUsage.prompt_tokens;
          this.usage[model.name].modelUsage.completionTokens += responseUsage.completion_tokens;
          this.usage[model.name].modelUsage.apiCalls += 1;
        }
        return completion ? completion : Error("No message returned");
      } catch (e) {
        return e;
      }
    });
  }
  async callLLMStream(request) {
    if (this.isMock || !this.llm || !this.llm.initialized) {
      return "Mock response";
    }
    try {
      const response = await this.llm.getCompletionStream(request);
      return response ? response : Error("No message returned");
    } catch (e) {
      return e;
    }
  }
  createMockFunctionResponse(request) {
    var _a2, _b, _c, _d;
    let textMessages = "";
    for (const message of request.messages) {
      if ("function_call" in message && message.function_call) {
        textMessages += `${message.role}: ${message.content} ${message.function_call} `;
      } else {
        textMessages += `${message.role}: ${message.content} `;
      }
    }
    const promptTokens = textMessages.length / 4;
    if (((_a2 = this.llm) == null ? void 0 : _a2.provider) === "openai" && !this.usage[request.model]) {
      if (!this.modelInfo[request.model]) {
        this.modelInfo[request.model] = {
          name: request.model,
          promptTokenPrice: 0,
          completionTokenPrice: 0
        };
      }
      const model = this.modelInfo[request.model];
      this.usage[request.model] = {
        model,
        modelUsage: {
          promptTokens: 0,
          completionTokens: 0,
          apiCalls: 0,
          totalCost: 0
        }
      };
    }
    if (this.usage[request.model]) {
      this.usage[request.model].modelUsage.promptTokens += promptTokens;
      this.usage[request.model].modelUsage.apiCalls += 1;
    }
    let calledFunction = "";
    if (request.functions && request.functions.length > 0) {
      calledFunction = request.functions[0].name;
    }
    if (calledFunction) {
      if (calledFunction === "choice") {
        const choiceFunction = (_b = request.functions) == null ? void 0 : _b.find(
          (fn) => fn.name === "choice"
        );
        if (!choiceFunction) {
          throw Error("No choice function found");
        }
        return this.createMockChoiceFunctionResponse(
          choiceFunction
        );
      } else if (calledFunction === "form") {
        const formFunction = (_c = request.functions) == null ? void 0 : _c.find(
          (fn) => fn.name === "form"
        );
        if (!formFunction) {
          throw Error("No form function found");
        }
        return this.createMockFormFunctionResponse(
          formFunction
        );
      } else if (calledFunction === "note_select") {
        const noteNameFunction = (_d = request.functions) == null ? void 0 : _d.find(
          (fn) => fn.name === "note_select"
        );
        if (!noteNameFunction) {
          throw Error("No note select function found");
        }
        return this.createMockNoteNameFunctionResponse(
          noteNameFunction
        );
      }
    }
    return {
      role: "assistant",
      content: "Mock response"
    };
  }
  createMockChoiceFunctionResponse(choiceFunction) {
    var _a2, _b, _c, _d, _e, _f, _g;
    const parsedProperties = JSON.parse(
      JSON.stringify((_b = (_a2 = choiceFunction == null ? void 0 : choiceFunction.parameters) == null ? void 0 : _a2["properties"]) != null ? _b : {})
    );
    const randomChoice = (_g = (_f = parsedProperties == null ? void 0 : parsedProperties.choice) == null ? void 0 : _f.enum[Math.floor(
      Math.random() * ((_e = (_d = (_c = parsedProperties == null ? void 0 : parsedProperties.choice) == null ? void 0 : _c.enum) == null ? void 0 : _d.length) != null ? _e : 0)
    )]) != null ? _g : "N/A";
    return {
      role: "assistant",
      function_call: {
        name: "choice",
        arguments: `{
					"choice" : "${randomChoice}"
					}`
      }
    };
  }
  createMockFormFunctionResponse(listFunction) {
    var _a2, _b;
    const args = [];
    for (const property of Object.keys(
      (_b = (_a2 = listFunction == null ? void 0 : listFunction.parameters) == null ? void 0 : _a2["properties"]) != null ? _b : {}
    )) {
      args.push({
        [property]: "Mock answer"
      });
    }
    return {
      role: "assistant",
      function_call: {
        name: "form",
        arguments: JSON.stringify(args)
      }
    };
  }
  createMockNoteNameFunctionResponse(noteFunction) {
    var _a2, _b, _c, _d, _e, _f, _g;
    const args = [];
    const parsedProperties = JSON.parse(
      JSON.stringify((_b = (_a2 = noteFunction == null ? void 0 : noteFunction.parameters) == null ? void 0 : _a2["properties"]) != null ? _b : {})
    );
    const randomNote = (_g = (_f = parsedProperties == null ? void 0 : parsedProperties.note) == null ? void 0 : _f.enum[Math.random() * ((_e = (_d = (_c = parsedProperties == null ? void 0 : parsedProperties.note) == null ? void 0 : _c.enum) == null ? void 0 : _d.length) != null ? _e : 0)]) != null ? _g : "N/A";
    args.push({
      note: randomNote
    });
    return {
      role: "assistant",
      function_call: {
        name: "note_select",
        arguments: JSON.stringify(args)
      }
    };
  }
  createChoiceFunction(choices) {
    return {
      name: "choice",
      description: "Enter your choice using this function.",
      parameters: {
        type: "object",
        properties: {
          choice: {
            type: "string",
            enum: choices
          }
        },
        required: ["choice"]
      }
    };
  }
  createFormFunction(tags) {
    const properties = {};
    tags.forEach((tag) => {
      if (tag.noteNames) {
        properties[tag.name] = {
          type: "string",
          enum: tag.noteNames
        };
        return;
      }
      properties[tag.name] = {
        type: "string"
      };
    });
    return {
      name: "form",
      description: "Use this function to enter the requested information for each key.",
      parameters: {
        type: "object",
        properties,
        required: tags.map((tag) => tag.name)
      }
    };
  }
  createNoteNameFunction(notes) {
    return {
      name: "note_select",
      description: "Enter one of the provided valid note names.",
      parameters: {
        type: "object",
        properties: {
          note: {
            type: "string",
            enum: notes
          }
        },
        required: ["note"]
      }
    };
  }
  calculateAllLLMCosts() {
    for (const usage of Object.values(this.usage)) {
      usage.modelUsage.totalCost = this.calculateLLMCostForModel(usage);
    }
    return this.usage;
  }
  calculateLLMCostForModel(usage) {
    var _a2;
    if (((_a2 = this.llm) == null ? void 0 : _a2.provider) === "ollama" || !usage || !usage.model || !usage.modelUsage)
      return 0;
    const promptCost = usage.model.promptTokenPrice * usage.modelUsage.promptTokens;
    const completionCost = usage.model.completionTokenPrice * usage.modelUsage.completionTokens;
    const totalCost = promptCost + completionCost;
    return totalCost;
  }
  getTotalCost() {
    let totalCost = 0;
    for (const usage of Object.values(this.usage)) {
      totalCost += this.calculateLLMCostForModel(usage);
    }
    return totalCost;
  }
  createHttpTemplate(inputString) {
    const lines = inputString.split("\n");
    const nameLine = lines[0];
    let jsonString = lines.slice(1).join("\n");
    if (jsonString.startsWith("```")) {
      jsonString = jsonString.substring(3, jsonString.length - 3);
    }
    if (jsonString.startsWith("json")) {
      jsonString = jsonString.substring(4, jsonString.length);
    }
    const name = nameLine.substring(1, nameLine.length - 1).trim();
    const json2 = JSON.parse(jsonString);
    const httpTemplate = {
      id: "",
      // Using an empty string for the ID as specified
      name,
      url: json2.url,
      method: json2.method,
      headers: json2.headers,
      bodyTemplate: JSON.stringify(json2.bodyTemplate)
    };
    return httpTemplate;
  }
  async executeHttpTemplateFromFloatingNode(inputString, body) {
    if (this.isMock) {
      return "Mock response";
    }
    let template;
    try {
      template = this.createHttpTemplate(inputString);
    } catch (error) {
      return new Error(
        `Failed to create HTTP template from input string: ${error.message}`
      );
    }
    try {
      return await this.executeHttpTemplate(template, body);
    } catch (error) {
      return error;
    }
  }
  async executeHttpTemplateByName(name, body) {
    if (this.isMock) {
      return "Mock response";
    }
    if (!this.cannoli.settings.httpTemplates) {
      return new Error(
        "No HTTP templates available. You can add them in Cannoli Plugin settings."
      );
    }
    const template = this.cannoli.settings.httpTemplates.find(
      (template2) => template2.name === name
    );
    if (!template) {
      return new Error(`HTTP template with name "${name}" not found.`);
    }
    try {
      return await this.executeHttpTemplate(template, body);
    } catch (error) {
      return error;
    }
  }
  executeHttpTemplate(template, body) {
    return new Promise((resolve, reject) => {
      let requestBody;
      if (template.bodyTemplate) {
        requestBody = this.parseBodyTemplate(
          template.bodyTemplate,
          body || ""
        );
      } else {
        if (typeof body === "string") {
          requestBody = body;
        } else {
          requestBody = JSON.stringify(body);
        }
      }
      const options = {
        method: template.method,
        headers: template.headers,
        body: template.method.toLowerCase() !== "get" ? requestBody : void 0
      };
      if (this.isMock) {
        resolve("mock response");
      }
      {
        (0, import_obsidian2.requestUrl)({ ...options, url: template.url }).then((response) => {
          return response.text;
        }).then((text) => {
          let response;
          if (text.length > 0) {
            response = JSON.parse(text);
          } else {
            response = {};
          }
          if (response.status >= 400) {
            reject(
              new Error(
                `HTTP error ${response.status}: ${response.statusText}`
              )
            );
          } else {
            resolve(JSON.stringify(response, null, 2));
          }
        }).catch((error) => {
          reject(
            new Error(`Error on HTTP request: ${error.message}`)
          );
        });
      }
    });
  }
  async editNote(reference, newContent, append) {
    var _a2, _b, _c, _d, _e, _f, _g;
    if (this.isMock) {
      return;
    }
    const filename = reference.name.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    if (append) {
      await this.cannoli.app.vault.process(file, (content) => {
        return content + newContent;
      });
      if (((_b = (_a2 = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _a2.file) == null ? void 0 : _b.basename) === file.basename) {
        const userTemplate = "\n\n" + ((_c = this.cannoli.settings.chatFormatString) == null ? void 0 : _c.replace("{{role}}", "User").replace("{{content}}", ""));
        if (newContent === userTemplate) {
          await new Promise((resolve) => setTimeout(resolve, 40));
        }
        if (this.cannoli.settings.autoScrollWithTokenStream) {
          (_g = (_d = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _d.editor) == null ? void 0 : _g.setCursor(
            ((_f = (_e = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _e.editor) == null ? void 0 : _f.lineCount()) || 0,
            0
          );
        }
      }
    } else {
      if (reference.includeProperties) {
        await this.cannoli.app.vault.modify(file, newContent);
      } else {
        await this.cannoli.app.vault.process(file, (content) => {
          var _a3;
          const yamlFrontmatter = (_a3 = content.match(
            /^---\n[\s\S]*?\n---\n/
          )) == null ? void 0 : _a3[0];
          if (yamlFrontmatter) {
            return yamlFrontmatter + newContent;
          } else {
            return newContent;
          }
        });
      }
    }
    return;
  }
  async getNote(reference, recursionCount = 0) {
    var _a2, _b, _c, _d, _e;
    if (this.isMock) {
      return `# ${reference.name}
Mock note content`;
    }
    const filename = reference.name.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    let content = await this.cannoli.app.vault.read(file);
    if (reference.subpath) {
      const metadata = this.cannoli.app.metadataCache.getCache(file.path);
      if (!metadata)
        return null;
      const subpath = (0, import_obsidian2.resolveSubpath)(metadata, reference.subpath);
      if (!subpath)
        return null;
      const startLine = subpath.start.line;
      const endLine = (_b = (_a2 = subpath.end) == null ? void 0 : _a2.line) != null ? _b : null;
      const lines = content.split("\n");
      if (endLine) {
        if (startLine === endLine) {
          return lines[startLine].trim();
        } else {
          content = lines.slice(startLine, endLine).join("\n");
        }
      } else {
        content = lines.slice(startLine).join("\n");
      }
      content = content.trim();
      if (content === "") {
        return null;
      }
    } else {
      if ((_c = reference.includeProperties) != null ? _c : this.cannoli.settings.includePropertiesInExtractedNotes) {
      } else {
        const yamlFrontmatter = (_d = content.match(
          /^---\n[\s\S]*?\n---\n/
        )) == null ? void 0 : _d[0];
        if (yamlFrontmatter) {
          content = content.replace(yamlFrontmatter, "");
        }
      }
      if ((_e = reference.includeName) != null ? _e : this.cannoli.settings.includeFilenameAsHeader) {
        const header = `# ${file.basename}
`;
        content = header + content;
      }
    }
    const embeddedNotes = content.match(/!\[\[[\s\S]*?\]\]/g);
    if (embeddedNotes) {
      for (const embeddedNote of embeddedNotes) {
        let noteName = embeddedNote.replace("![[", "").replace("]]", "");
        let subpath;
        if (noteName.includes("|")) {
          noteName = noteName.split("|")[0];
        }
        if (noteName.includes("#")) {
          const split = noteName.split("#");
          noteName = split[0];
          subpath = split[1];
        }
        if (noteName === reference.name) {
          continue;
        }
        if (recursionCount > 10) {
          console.error(
            `Recursion limit reached while extracting note "${noteName}".`
          );
          continue;
        }
        const noteContent = await this.getNote(
          {
            name: noteName,
            type: "note" /* Note */,
            shouldExtract: true,
            includeName: true,
            subpath
          },
          recursionCount + 1
        );
        if (noteContent) {
          const blockquotedNoteContent = "> " + noteContent.replace(/\n/g, "\n> ");
          content = content.replace(
            embeddedNote,
            blockquotedNoteContent
          );
        }
      }
    }
    return content;
  }
  editSelection(newContent) {
    var _a2, _b;
    if (this.isMock) {
      return;
    }
    if (!this.cannoli.app.workspace.activeEditor) {
      return;
    }
    (_b = (_a2 = this.cannoli.app.workspace.activeEditor) == null ? void 0 : _a2.editor) == null ? void 0 : _b.replaceSelection(
      newContent
    );
  }
  async getPropertyOfNote(noteName, propertyName, yamlFormat = false) {
    const filename = noteName.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    try {
      let frontmatter = {};
      await this.cannoli.app.fileManager.processFrontMatter(
        file,
        (content) => {
          frontmatter = content;
          return content;
        }
      );
      if (!frontmatter) {
        return null;
      }
      const property = frontmatter[propertyName];
      if (typeof property !== "string") {
        if (yamlFormat) {
          return dump(property);
        } else {
          return JSON.stringify(frontmatter[propertyName], null, 2);
        }
      } else {
        return property;
      }
    } catch (error) {
      console.error(
        "An error occurred while fetching frontmatter:",
        error
      );
      return null;
    }
  }
  async getAllPropertiesOfNote(noteName, yamlFormat = false) {
    const filename = noteName.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    try {
      let frontmatter = {};
      await this.cannoli.app.fileManager.processFrontMatter(
        file,
        (content) => {
          frontmatter = content;
          return content;
        }
      );
      if (!frontmatter) {
        return null;
      }
      if (!yamlFormat) {
        return JSON.stringify(frontmatter, null, 2);
      } else {
        return dump(frontmatter);
      }
    } catch (error) {
      console.error(
        "An error occurred while fetching frontmatter:",
        error
      );
      return null;
    }
  }
  async editPropertyOfNote(noteName, propertyName, newValue) {
    const filename = noteName.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return;
    }
    let parsedNewValue = newValue;
    if (newValue.startsWith("- ")) {
      parsedNewValue = newValue.split("\n").map((item) => item.replace("- ", "").trim()).filter((item) => item !== "");
    }
    try {
      await this.cannoli.app.fileManager.processFrontMatter(
        file,
        (content) => {
          let frontmatter = {};
          if (content) {
            frontmatter = content;
          }
          frontmatter[propertyName] = parsedNewValue;
          return frontmatter;
        }
      );
      return;
    } catch (error) {
      console.error(
        "An error occurred while editing frontmatter:",
        error
      );
      return;
    }
  }
  async createNoteAtExistingPath(noteName, path, content, verbose = false) {
    noteName = noteName.replace("[[", "").replace("]]", "");
    let i = 1;
    while (this.cannoli.app.metadataCache.getFirstLinkpathDest(noteName, "")) {
      if (noteName.match(/ \d+$/)) {
        noteName = noteName.replace(/ \d+$/, ` ${i.toString()}`);
      } else {
        noteName = `${noteName} ${i.toString()}`;
      }
      i++;
    }
    const fullPath = `${path != null ? path : ""}/${noteName}.md`;
    await this.cannoli.app.vault.create(fullPath, content != null ? content : "");
    if (verbose) {
      console.log(`Note "${noteName}" created at path "${fullPath}"`);
    }
    return noteName;
  }
  async createNoteAtNewPath(noteName, path, content, verbose = false) {
    const fullPath = `${path}/${noteName}.md`;
    await this.cannoli.app.vault.create(fullPath, content != null ? content : "");
    if (verbose) {
      console.log(`Note "${noteName}" created at path "${fullPath}"`);
    }
    return true;
  }
  async getNotePath(noteName) {
    const filename = noteName.replace("[[", "").replace("]]", "");
    const file = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    if (!file) {
      return null;
    }
    return file.path;
  }
  async createFolder(path, verbose = false) {
    const folder = this.cannoli.app.vault.getAbstractFileByPath(path);
    if (folder) {
      return false;
    }
    this.cannoli.app.vault.createFolder(path);
    if (verbose) {
      console.log(`Folder created at path "${path}"`);
    }
    return true;
  }
  async moveNote(noteName, newPath, verbose = false) {
    const newFullPath = `${newPath}/${noteName}.md`;
    const filename = noteName.replace("[[", "").replace("]]", "");
    const note = this.cannoli.app.metadataCache.getFirstLinkpathDest(
      filename,
      ""
    );
    const oldFullPath = note == null ? void 0 : note.path;
    if (!note) {
      return false;
    }
    await this.cannoli.app.vault.rename(note, newFullPath);
    if (verbose) {
      console.log(
        `Note "${noteName}" moved from path "${oldFullPath}" to path "${newFullPath}"`
      );
    }
    return true;
  }
  logGraph() {
    for (const node of Object.values(this.graph)) {
      console.log(node.logDetails());
    }
  }
};

// assets/cannoliCollege.js
var cannoliCollege = {
  "1. Basics": [
    {
      name: "1. Hello world.canvas",
      content: `{"nodes":[{"type":"group","id":"161279baf7763214","x":-174,"y":-160,"width":394,"height":340,"label":"Cannoli"},{"type":"text","text":"Hello world!","id":"dc3f9351f787531e","x":-97,"y":-91,"width":250,"height":60},{"type":"text","text":"","id":"bc1a550bbb4aac7b","x":-97,"y":60,"width":250,"height":60,"color":"6"},{"type":"text","text":"The purple node is a content node. Content nodes can be used to store and display text that can be read or written by you or another node.","id":"f77169b141243e65","x":240,"y":30,"width":420,"height":120},{"type":"text","text":"The colorless, green, or yellow node is a call node. Call nodes make a chat completion call to the LLM with the text of the node as a user message.","id":"0af5a453bd4d6ec9","x":240,"y":-110,"width":380,"height":120},{"type":"text","text":"If a node in a cannoli is floating (no arrows attached) it won't affect the cannoli unless it is formatted in a special way we'll go over later.","id":"7d005c80299f3674","x":-202,"y":220,"width":461,"height":112},{"type":"text","text":"This is a Cannoli. It's made up of different types of nodes and arrows.\\n\\nTry running it by clicking the Cannoli button in the control ribbon on the left side of your Obsidian window.","id":"24dd96c964700992","x":-147,"y":-400,"width":350,"height":180},{"type":"text","text":"Cannolis can be run in several ways:\\n\\n- Click the Cannoli ribbon icon\\n    - If you're on a canvas file, it will be run as a cannoli\\n    - If you're on a note with a \\"cannoli\\" property, the canvas file in that property will be run as a cannoli\\n- Run the \\"Start/Stop cannoli\\" command in the command palette (functions the same as the ribbon icon)\\n- If a canvas file name ends with \\".cno\\", it will have its own run command in the command palette\\n- Make an audio recording on a note with a \\"cannoli\\" property\\n\\t- That recording will be transcribed, replace the reference, and trigger the cannoli defined in the property.","id":"927cf33512b0dfc1","x":-740,"y":-182,"width":538,"height":402}],"edges":[{"id":"23c2d7dffb49bf75","fromNode":"dc3f9351f787531e","fromSide":"bottom","toNode":"bc1a550bbb4aac7b","toSide":"top"}]}`
    },
    {
      name: "2. Blank arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"e77c462deb61200c","x":-200,"y":-240,"width":360,"height":600,"label":"Blank Arrows"},{"type":"text","text":"This first arrow is going from a call node to another call node, so it will pass the chat history along.","id":"ab7c414710f7f130","x":-478,"y":-160,"width":268,"height":135},{"type":"text","text":"The third arrow is going from a content node to a content node, so it will just copy its content.","id":"ccd789ee75f32cfa","x":-513,"y":191,"width":303,"height":102},{"type":"text","text":"This is the second user message, after an LLM response","id":"78cc7edc0acf7754","x":-145,"y":-39,"width":250,"height":110},{"type":"text","text":"This is the first user message","id":"f20327851c3175bd","x":-145,"y":-190,"width":250,"height":60},{"type":"text","text":"","id":"ffdc926f780c7c6f","x":-145,"y":131,"width":250,"height":60,"color":"6"},{"type":"text","text":"","id":"2a451cf329dad9eb","x":-145,"y":260,"width":250,"height":60,"color":"6"},{"type":"text","text":"The second arrow is going to a content node, so it will just pass the content of the LLM's response along.","id":"69c75646befb238b","x":170,"y":49,"width":344,"height":112},{"type":"text","text":"Arrows behave differently depending on their color, their label, and the type of their source and target (the node they are coming from and the node they point to).","id":"7f3c629307341974","x":-210,"y":-440,"width":380,"height":130}],"edges":[{"id":"3e2d98fc5ddeb168","fromNode":"78cc7edc0acf7754","fromSide":"bottom","toNode":"ffdc926f780c7c6f","toSide":"top"},{"id":"321db5e7d72b0151","fromNode":"ffdc926f780c7c6f","fromSide":"bottom","toNode":"2a451cf329dad9eb","toSide":"top"},{"id":"d08c98406e290f66","fromNode":"f20327851c3175bd","fromSide":"bottom","toNode":"78cc7edc0acf7754","toSide":"top"}]}`
    },
    {
      name: "3. Branching.canvas",
      content: `{"nodes":[{"type":"group","id":"7c382706de4d0696","x":-160,"y":-409,"width":695,"height":770,"label":"Multiple outgoing arrows"},{"type":"group","id":"5a24d53646b10364","x":-132,"y":480,"width":640,"height":480,"label":"Branching chats"},{"type":"text","text":"In this case, we are sending the output of each call node to a content node as well as another call node.\\n\\nThis shows us the LLM's response to each user message.","id":"a920f9e049043602","x":-460,"y":-228,"width":280,"height":240},{"type":"text","text":"","id":"69ab78708b319e8d","x":140,"y":-329,"width":340,"height":110,"color":"6"},{"type":"text","text":"","id":"c096758e55238bfe","x":175,"y":-178,"width":340,"height":250,"color":"6"},{"type":"text","text":"What's the best Italian dessert?","id":"7b37496e496da827","x":-137,"y":-359,"width":250,"height":60},{"type":"text","text":"How do you make it?","id":"aea9dcb543944bb1","x":-137,"y":-189,"width":250,"height":60},{"type":"text","text":"Give me a simpler recipe","id":"2f59408c2be9b7ae","x":-137,"y":12,"width":250,"height":60},{"type":"text","text":"","id":"ddb05069cb9f6f3e","x":113,"y":137,"width":390,"height":190,"color":"6"},{"type":"text","text":"Nodes can have multiple arrows coming out of them. They can carry information to different kinds of nodes.","id":"6d316338bfce7b20","x":28,"y":-580,"width":340,"height":100},{"type":"text","text":"Nf3","id":"248594446ba6eca2","x":-97,"y":691,"width":250,"height":60},{"type":"text","text":"Lets play chess. Here's my first move: e4","id":"891f6d7945759cd7","x":69,"y":500,"width":250,"height":60},{"type":"text","text":"Nc3","id":"5d4454ca8f7bdb3a","x":228,"y":691,"width":250,"height":60},{"type":"text","text":"","id":"3492caf4ead7f8cb","x":-107,"y":853,"width":260,"height":78,"color":"6"},{"type":"text","text":"","id":"9f9ba5852d437657","x":228,"y":853,"width":254,"height":78,"color":"6"},{"type":"text","text":"We can also use multiple outgoing arrows to create different branches of a chat","id":"5347076c683c8346","x":-392,"y":680,"width":255,"height":104}],"edges":[{"id":"d8d4ab1340924892","fromNode":"2f59408c2be9b7ae","fromSide":"bottom","toNode":"ddb05069cb9f6f3e","toSide":"left"},{"id":"806865b0c75a6687","fromNode":"aea9dcb543944bb1","fromSide":"bottom","toNode":"2f59408c2be9b7ae","toSide":"top"},{"id":"44a20edc995a84d8","fromNode":"aea9dcb543944bb1","fromSide":"bottom","toNode":"c096758e55238bfe","toSide":"left"},{"id":"b59766f15e6812d8","fromNode":"7b37496e496da827","fromSide":"bottom","toNode":"aea9dcb543944bb1","toSide":"top"},{"id":"8fd655a2583e6f98","fromNode":"7b37496e496da827","fromSide":"bottom","toNode":"69ab78708b319e8d","toSide":"left"},{"id":"7d1bb4c2b5052c34","fromNode":"891f6d7945759cd7","fromSide":"bottom","toNode":"248594446ba6eca2","toSide":"top"},{"id":"bc0b97379618ae28","fromNode":"891f6d7945759cd7","fromSide":"bottom","toNode":"5d4454ca8f7bdb3a","toSide":"top"},{"id":"08fda0370caa615e","fromNode":"248594446ba6eca2","fromSide":"bottom","toNode":"3492caf4ead7f8cb","toSide":"top"},{"id":"e1a68493483394b4","fromNode":"5d4454ca8f7bdb3a","fromSide":"bottom","toNode":"9f9ba5852d437657","toSide":"top"}]}`
    },
    {
      name: "4. System messages.canvas",
      content: `{"nodes":[{"type":"group","id":"9a74aa8d0afdb942","x":-334,"y":-395,"width":669,"height":790,"label":"System Messages"},{"type":"text","text":"You are a silly goofy guy","id":"d005ba1be8656e6e","x":-314,"y":-205,"width":250,"height":60,"color":"6"},{"type":"text","text":"Hey what's a fun outing","id":"2c1e68fdaf20b936","x":-314,"y":-25,"width":250,"height":60},{"type":"text","text":"","id":"606e8b604062817a","x":-314,"y":111,"width":250,"height":154,"color":"6"},{"type":"text","text":"","id":"d0edacf3895cacc4","x":65,"y":-95,"width":250,"height":155,"color":"6"},{"type":"text","text":"Respond with a description of a very confused AI assistant that can't keep it together. Nothing else should be in your response. It should start with: \\"you are a...\\"","id":"59b7fc9dda9a50c1","x":65,"y":-375,"width":250,"height":232},{"type":"text","text":"This call node will include the above content node text as a system message.","id":"4b95de6b15e52400","x":-620,"y":-45,"width":260,"height":125},{"type":"text","text":"Here we're using a call node to generate a system message.","id":"9f14bc97186eabc0","x":360,"y":-143,"width":260,"height":98},{"type":"text","text":"Who invented mail?","id":"b8465e3c0926341e","x":65,"y":111,"width":250,"height":60},{"type":"text","text":"Blank arrows going from content nodes to call nodes will pass their content as a system message. System messages are used to give instructions on how the LLM should respond to user messages.","id":"225fa9e654db31d6","x":-189,"y":-620,"width":414,"height":157},{"type":"text","text":"","id":"661a61495dfeaf24","x":65,"y":218,"width":250,"height":157,"color":"6"}],"edges":[{"id":"4cfad5a8ec2be98f","fromNode":"d005ba1be8656e6e","fromSide":"bottom","toNode":"2c1e68fdaf20b936","toSide":"top"},{"id":"2a357972e7682b3d","fromNode":"2c1e68fdaf20b936","fromSide":"bottom","toNode":"606e8b604062817a","toSide":"top"},{"id":"c19d63a0e7873549","fromNode":"d0edacf3895cacc4","fromSide":"bottom","toNode":"b8465e3c0926341e","toSide":"top"},{"id":"04fc452e98f4b80f","fromNode":"59b7fc9dda9a50c1","fromSide":"bottom","toNode":"d0edacf3895cacc4","toSide":"top"},{"id":"ff5fd1f32d515a9f","fromNode":"b8465e3c0926341e","fromSide":"bottom","toNode":"661a61495dfeaf24","toSide":"top"}]}`
    },
    {
      name: "5. Variable arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"4dd63eded63256f2","x":-172,"y":240,"width":665,"height":460,"label":"Multiple variables"},{"type":"group","id":"d83444fe5b49fb2c","x":-160,"y":800,"width":653,"height":463,"label":"Between call nodes"},{"type":"group","id":"c409a28317a5ae26","x":11,"y":-360,"width":294,"height":510,"label":"Variables"},{"type":"text","text":"Pannetone","id":"0d48f7722e5db52e","x":31,"y":-340,"width":250,"height":60,"color":"6"},{"type":"text","text":"The label of the arrow names the variable, and you can inject it into a call node using the format \\"{{variable name}}\\"","id":"1a3b5db348375dba","x":-380,"y":-199,"width":371,"height":119},{"type":"text","text":"How do you make {{dessert}}?","id":"10cedae5ccf81664","x":31,"y":-180,"width":250,"height":60},{"type":"text","text":"","id":"5cf958d72a55d52d","x":32,"y":-24,"width":250,"height":154,"color":"6"},{"type":"text","text":"Labeling an arrow makes it a variable you can access in call nodes.","id":"db8924f8ddaaa08e","x":-13,"y":-520,"width":330,"height":86},{"type":"text","text":"Hannibal","id":"b2aa8b695a7b7774","x":-152,"y":260,"width":250,"height":60,"color":"6"},{"type":"text","text":"Elephants","id":"c23271f22630c4a9","x":223,"y":260,"width":250,"height":60,"color":"6"},{"type":"text","text":"What connects {{a}} and {{b}}?","id":"4f84654825f9df4c","x":34,"y":420,"width":293,"height":75},{"type":"text","text":"You can name and inject the output of call nodes the same way.","id":"835c4e523796df6e","x":-500,"y":915,"width":320,"height":80},{"type":"text","text":"Rate this limerick:\\n{{limerick}}","id":"25d842fe884f4e78","x":-140,"y":995,"width":250,"height":60},{"type":"text","text":"Respond with a limerick about Cannolis","id":"1714bc9f52099a91","x":-140,"y":820,"width":250,"height":60},{"type":"text","text":"","id":"84fb2c8243704c1a","x":55,"y":550,"width":250,"height":130,"color":"6"},{"type":"text","text":"","id":"13cde1cb12272304","x":-140,"y":1110,"width":250,"height":133,"color":"6"},{"type":"text","text":"Are you sure its {{city}}?","id":"fe8260fd047fe01a","x":192,"y":996,"width":250,"height":60},{"type":"text","text":"","id":"26d4da45eb95d333","x":192,"y":1110,"width":250,"height":133,"color":"6"},{"type":"text","text":"What's the capital of Italy?","id":"44d0ee25c2f23e66","x":192,"y":820,"width":250,"height":60},{"type":"text","text":"Multiple arrows going into a call node can be used to inject multiple variables.","id":"0fd0a4b39c942f0b","x":-426,"y":399,"width":246,"height":117},{"type":"text","text":"Labeled basic arrows between call nodes will not pass along the chat history by default, only the content of the response.\\n\\nYou can override this by adding a \\"|\\" symbol at the end of the arrow label like so. Then you can continue a conversation as well as use a variable.","id":"1fadbba4649fa725","x":520,"y":955,"width":380,"height":245}],"edges":[{"id":"139dad9317421572","fromNode":"0d48f7722e5db52e","fromSide":"bottom","toNode":"10cedae5ccf81664","toSide":"top","label":"dessert"},{"id":"fa1b26557addc3e5","fromNode":"b2aa8b695a7b7774","fromSide":"bottom","toNode":"4f84654825f9df4c","toSide":"top","label":"a"},{"id":"ece89fb689451485","fromNode":"c23271f22630c4a9","fromSide":"bottom","toNode":"4f84654825f9df4c","toSide":"top","label":"b"},{"id":"b9eadfcbf2c54fe1","fromNode":"10cedae5ccf81664","fromSide":"bottom","toNode":"5cf958d72a55d52d","toSide":"top"},{"id":"3a41dc5849268edf","fromNode":"4f84654825f9df4c","fromSide":"bottom","toNode":"84fb2c8243704c1a","toSide":"top"},{"id":"7cf5bbc070866504","fromNode":"25d842fe884f4e78","fromSide":"bottom","toNode":"13cde1cb12272304","toSide":"top"},{"id":"3b347865a761d32b","fromNode":"1714bc9f52099a91","fromSide":"bottom","toNode":"25d842fe884f4e78","toSide":"top","label":"limerick"},{"id":"f93a6b2b699a1bf6","fromNode":"44d0ee25c2f23e66","fromSide":"bottom","toNode":"fe8260fd047fe01a","toSide":"top","label":"city|"},{"id":"0fa4378c8752aca4","fromNode":"fe8260fd047fe01a","fromSide":"bottom","toNode":"26d4da45eb95d333","toSide":"top"}]}`
    }
  ],
  "2. Special arrows": [
    {
      name: "1. Config arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"b388b74fc76f9d5b","x":-411,"y":420,"width":800,"height":480,"label":"Config Arrows"},{"type":"group","id":"50e47210c3597f2c","x":-382,"y":-274,"width":742,"height":442,"label":"Logging Arrows"},{"type":"text","text":"What's the weakest?","id":"01b6cd0557436d0d","x":-362,"y":77,"width":250,"height":60},{"type":"text","text":"You're an expert in metallurgy","id":"cd8bccad9c0ff0e1","x":-362,"y":-254,"width":250,"height":60,"color":"6"},{"type":"text","text":"What's the strongest metal?","id":"d90d1eda5b1cee39","x":-362,"y":-94,"width":250,"height":60},{"type":"text","text":"The logging arrow will write the chat history, response, and config of the call node to the content node it is pointing to.","id":"82607dbca24bcc3b","x":-720,"y":48,"width":325,"height":120},{"type":"text","text":"As a cannoli gets more complex, it can be difficult to know what the LLM is actually seeing in each call node.\\n\\nA blank config arrow leaving a call node will log out everything the LLM saw on that call, as well as the config of that call node.","id":"2eddfb2df05ffd92","x":-932,"y":-224,"width":537,"height":160},{"type":"text","text":"Orange arrows are config arrows. You can change the color of arrows by left clicking on them and then clicking on the color pallet ","id":"f1b3951087221764","x":-160,"y":-440,"width":393,"height":118},{"type":"text","text":"","id":"18629c0795e99c52","x":-28,"y":-158,"width":365,"height":295,"color":"6"},{"type":"text","text":"Labeled config arrows pointing to call nodes will try to set their content to the LLM config setting named in the arrow's label.","id":"9750898ccab8b2ec","x":-190,"y":240,"width":325,"height":130},{"type":"text","text":"1.5","id":"f2066662ccfdf12b","x":-228,"y":450,"width":106,"height":68,"color":"6"},{"type":"text","text":"When will gpt-5 come out?","id":"901e534d654dbe8d","x":-285,"y":640,"width":250,"height":60},{"type":"text","text":"gpt-4","id":"32895b9cbe65ebf5","x":-385,"y":450,"width":100,"height":60,"color":"6"},{"type":"text","text":"","id":"f9768071dcaaf641","x":24,"y":445,"width":345,"height":415,"color":"6"},{"type":"text","text":"Config arrows can also be used to set the LLM config of call nodes, overriding the default.","id":"f75c463c060098f5","x":-760,"y":442,"width":324,"height":106},{"type":"text","text":"This call node will request a gpt-4 response with a temperature of 1.5, overriding the defaults.\\n\\n(You can set the defaults in the plugin settings)","id":"1a6e63c23f2fd598","x":-760,"y":581,"width":324,"height":179}],"edges":[{"id":"3e19de32f2cf2234","fromNode":"01b6cd0557436d0d","fromSide":"right","toNode":"18629c0795e99c52","toSide":"left","color":"2"},{"id":"a5ea03afb9e7519f","fromNode":"d90d1eda5b1cee39","fromSide":"bottom","toNode":"01b6cd0557436d0d","toSide":"top"},{"id":"e60e398ffd796673","fromNode":"cd8bccad9c0ff0e1","fromSide":"bottom","toNode":"d90d1eda5b1cee39","toSide":"top"},{"id":"4802b580405f5936","fromNode":"f2066662ccfdf12b","fromSide":"bottom","toNode":"901e534d654dbe8d","toSide":"top","color":"2","label":"temperature"},{"id":"44d9a85dc1209c3f","fromNode":"901e534d654dbe8d","fromSide":"right","toNode":"f9768071dcaaf641","toSide":"left","color":"2"},{"id":"18f98f277862e948","fromNode":"32895b9cbe65ebf5","fromSide":"bottom","toNode":"901e534d654dbe8d","toSide":"left","color":"2","label":"model"}]}`
    },
    {
      name: "2. Field arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"ac03334c4c9efbbf","x":-300,"y":320,"width":871,"height":540,"label":"Other details"},{"type":"group","id":"bb74df853c72868d","x":-240,"y":-80,"width":600,"height":328,"label":"Field arrows"},{"type":"text","text":"What's a good fruit to eat for each meal?","id":"bf2f302f415a57a7","x":-97,"y":-60,"width":250,"height":60},{"type":"text","text":"","id":"8eee16509fba3a49","x":-214,"y":168,"width":140,"height":60,"color":"6"},{"type":"text","text":"When a call node has field arrows leaving it, that call will include a function that gives the LLM fields to fill out for each field name you provide.","id":"c812856c4f5cfe60","x":-560,"y":-80,"width":309,"height":158},{"type":"text","text":"Choosing field arrow names is its own kind of prompting. Experiment with different ways of naming the arrows to get better results.","id":"bf823c055e81ed66","x":-560,"y":97,"width":309,"height":143},{"type":"text","text":"Purple arrows are field arrows. Field arrows are a special kind of variable arrow that allow you to name a field for the LLM to fill. \\n\\nThey use openai's function calling feature to get structured responses based on the arrow labels.","id":"972a9b4042c99aff","x":-160,"y":-320,"width":444,"height":186},{"type":"text","text":"Rank the top 2 most famous historical battles","id":"912a11d4e1afa3c1","x":-74,"y":340,"width":250,"height":60},{"type":"text","text":"","id":"7fcb2dd5de840465","x":-280,"y":600,"width":332,"height":241,"color":"6"},{"type":"text","text":"What makes the {{battle 1}} famous?","id":"b9016ed068d8f3df","x":-214,"y":496,"width":254,"height":60},{"type":"text","text":"","id":"fc3f0539962083c5","x":-33,"y":168,"width":122,"height":60,"color":"6"},{"type":"text","text":"","id":"303f2609904e9a78","x":153,"y":168,"width":180,"height":60,"color":"6"},{"type":"text","text":"","id":"b58f716ac95e1bd3","x":81,"y":600,"width":339,"height":241,"color":"6"},{"type":"text","text":"What makes the {{battle 2}} famous?","id":"355f89d3338915a0","x":89,"y":496,"width":271,"height":60},{"type":"text","text":"{\\n  \\"battle 1\\": \\"Battle of Waterloo\\",\\n  \\"battle 2\\": \\"Battle of Stalingrad\\"\\n}","id":"602c0eb10399429c","x":251,"y":340,"width":301,"height":120,"color":"6"},{"type":"text","text":"Non-field arrows will just carry the response as a JSON string.","id":"05a12136e3510af7","x":580,"y":340,"width":250,"height":98},{"type":"text","text":"Similarly to variable arrows, by default field arrows don't pass chat history. Override this with a \\"|\\" symbol at the end.","id":"e385c431c950a822","x":-600,"y":435,"width":277,"height":155}],"edges":[{"id":"f243e7ecc26dddf0","fromNode":"bf2f302f415a57a7","fromSide":"bottom","toNode":"8eee16509fba3a49","toSide":"top","color":"6","label":"breakfast"},{"id":"19acdf8c5139a403","fromNode":"bf2f302f415a57a7","fromSide":"bottom","toNode":"fc3f0539962083c5","toSide":"top","color":"6","label":"lunch"},{"id":"eea5e61d628a1f37","fromNode":"bf2f302f415a57a7","fromSide":"bottom","toNode":"303f2609904e9a78","toSide":"top","color":"6","label":"dinner"},{"id":"3e455995e5dff301","fromNode":"912a11d4e1afa3c1","fromSide":"bottom","toNode":"b9016ed068d8f3df","toSide":"top","color":"6","label":"battle 1"},{"id":"de82f8c9cc47e515","fromNode":"912a11d4e1afa3c1","fromSide":"bottom","toNode":"355f89d3338915a0","toSide":"top","color":"6","label":"battle 2|"},{"id":"1a9662bf2fcaaeca","fromNode":"b9016ed068d8f3df","fromSide":"bottom","toNode":"7fcb2dd5de840465","toSide":"top","color":"2"},{"id":"7f6b2d929334d325","fromNode":"355f89d3338915a0","fromSide":"bottom","toNode":"b58f716ac95e1bd3","toSide":"top","color":"2"},{"id":"0d6c132ba45af90d","fromNode":"912a11d4e1afa3c1","fromSide":"right","toNode":"602c0eb10399429c","toSide":"left"}]}`
    },
    {
      name: "3. Choice arrows.canvas",
      content: `{"nodes":[{"type":"group","id":"c9dd6d1bd62bafff","x":-380,"y":380,"width":800,"height":520,"label":"Chat history"},{"type":"group","id":"cd01298f475a3dd6","x":-296,"y":980,"width":578,"height":640,"label":"Variables from different choice paths"},{"type":"group","id":"a6599fe712bec80e","x":-296,"y":-200,"width":604,"height":474,"label":"Choice arrows"},{"type":"text","text":"When a call node has choice arrows leaving it, it will be given a function that asks for a response with one of the arrow labels.","id":"45df9fe6d33cd2d2","x":-660,"y":-140,"width":341,"height":135},{"type":"text","text":"Should I make pasta tonight?","id":"28786f9598c550d5","x":-112,"y":-179,"width":204,"height":79},{"type":"text","text":"You sure?","id":"ac91698a073fc95c","x":-237,"y":6,"width":177,"height":60,"color":"0"},{"type":"text","text":"Ok give me a list of ingredients","id":"63096630fb9f2e2e","x":48,"y":6,"width":230,"height":60},{"type":"text","text":"","id":"3acf958e2220ce5e","x":-273,"y":140,"width":250,"height":114,"color":"6"},{"type":"text","text":"Yellow arrows are choice arrows. Use these to give the LLM a choice between options. Only the arrows that have the chosen label will activate.","id":"4e077ea9cfa98595","x":-175,"y":-368,"width":415,"height":108},{"type":"text","text":"Similarly to blank arrows, choice arrows pass chat history by default.\\n\\nIf you'd like a choice arrow not to pass chat history, and simply define which nodes to activate, add a \\"~\\" symbol at the end of the label.","id":"f258c0364e5303bb","x":-781,"y":400,"width":380,"height":207},{"type":"text","text":"","id":"a5276dfa0b72a1d9","x":38,"y":140,"width":250,"height":114,"color":"6"},{"type":"text","text":"What's the most difficult pasta to make?","id":"03f149b198234b2e","x":-232,"y":400,"width":250,"height":60},{"type":"text","text":"Choice arrows and any other outgoing arrows simply pass the response as a JSON string.","id":"f342c07dfcc12a65","x":440,"y":395,"width":299,"height":109},{"type":"text","text":"","id":"631691e520dac009","x":-355,"y":760,"width":358,"height":120,"color":"6"},{"type":"text","text":"","id":"b217af764ccecfd0","x":28,"y":760,"width":375,"height":120,"color":"6"},{"type":"text","text":"","id":"e82cc2675ee6f4ac","x":140,"y":400,"width":263,"height":60,"color":"6"},{"type":"text","text":"","id":"599128089fbfde0c","x":220,"y":561,"width":183,"height":135,"color":"6"},{"type":"text","text":"Is this my first message?","id":"76252deff058a30b","x":28,"y":641,"width":175,"height":85,"color":"0"},{"type":"text","text":"","id":"32b8f51ebe623e94","x":-369,"y":560,"width":164,"height":135,"color":"6"},{"type":"text","text":"Is this my first message?","id":"c63995fa03f9e524","x":-190,"y":629,"width":166,"height":85},{"type":"text","text":"Write a shopping list based on this recipe: {{a}}","id":"b95eb36f138e1a24","x":-126,"y":1349,"width":250,"height":92},{"type":"text","text":"Which pasta is better for a red sauce?","id":"0fd490ac150e0f5e","x":-143,"y":1000,"width":250,"height":60},{"type":"text","text":"","id":"676ea6885c79b682","x":-185,"y":1480,"width":368,"height":120,"color":"6"},{"type":"text","text":"I dont have any orzo. Respond with a recipe for orzo as well as a recipe for a simple red sauce.","id":"a234933050b99f4f","x":8,"y":1160,"width":250,"height":120,"color":"0"},{"type":"text","text":"Ok I have that. Just respond with the recipe for a simple red sauce.","id":"46b1cd2114123ac8","x":-276,"y":1160,"width":250,"height":120},{"type":"text","text":"If a call node has multiple incoming edges with the same name, only the one from an activated path will be injected.","id":"6e5936cc2c85af89","x":-610,"y":1280,"width":288,"height":137}],"edges":[{"id":"7265ecc0e39454b0","fromNode":"03f149b198234b2e","fromSide":"bottom","toNode":"32b8f51ebe623e94","toSide":"top","color":"3","label":"rigatoni"},{"id":"5b08fd306da75b91","fromNode":"03f149b198234b2e","fromSide":"bottom","toNode":"599128089fbfde0c","toSide":"top","color":"3","label":"linguini"},{"id":"82b732c8452c9584","fromNode":"28786f9598c550d5","fromSide":"bottom","toNode":"ac91698a073fc95c","toSide":"top","color":"3","label":"no"},{"id":"b83dfe178174121d","fromNode":"28786f9598c550d5","fromSide":"bottom","toNode":"63096630fb9f2e2e","toSide":"top","color":"3","label":"yes"},{"id":"b4775fe4758dc40d","fromNode":"ac91698a073fc95c","fromSide":"bottom","toNode":"3acf958e2220ce5e","toSide":"top"},{"id":"ae2322dc9035b985","fromNode":"63096630fb9f2e2e","fromSide":"bottom","toNode":"a5276dfa0b72a1d9","toSide":"top"},{"id":"26d34c5e87e7d03c","fromNode":"03f149b198234b2e","fromSide":"bottom","toNode":"c63995fa03f9e524","toSide":"top","color":"3","label":"rigatoni~"},{"id":"7db7e2a8fc1e1ef6","fromNode":"03f149b198234b2e","fromSide":"bottom","toNode":"76252deff058a30b","toSide":"top","color":"3","label":"linguini~"},{"id":"6f95f372b461f8d5","fromNode":"76252deff058a30b","fromSide":"bottom","toNode":"b217af764ccecfd0","toSide":"top","color":"2"},{"id":"abc25503ba8076fb","fromNode":"c63995fa03f9e524","fromSide":"bottom","toNode":"631691e520dac009","toSide":"top","color":"2"},{"id":"1582d8994ac555e1","fromNode":"03f149b198234b2e","fromSide":"right","toNode":"e82cc2675ee6f4ac","toSide":"left"},{"id":"c43d38e12b9c16b8","fromNode":"46b1cd2114123ac8","fromSide":"bottom","toNode":"b95eb36f138e1a24","toSide":"top","label":"a"},{"id":"f22bc7061eff5703","fromNode":"a234933050b99f4f","fromSide":"bottom","toNode":"b95eb36f138e1a24","toSide":"top","label":"a"},{"id":"bf13cea8fc4d3ac8","fromNode":"0fd490ac150e0f5e","fromSide":"bottom","toNode":"46b1cd2114123ac8","toSide":"top","color":"3","label":"penne"},{"id":"0d60d2b18558d544","fromNode":"0fd490ac150e0f5e","fromSide":"bottom","toNode":"a234933050b99f4f","toSide":"top","color":"3","label":"orzo"},{"id":"96c63376c757dbf0","fromNode":"b95eb36f138e1a24","fromSide":"bottom","toNode":"676ea6885c79b682","toSide":"top"}]}`
    },
    {
      name: "4. Chat arrows.cno.canvas",
      content: '{"nodes":[{"id":"167d3b7b2f6f548d","type":"group","x":-460,"y":400,"width":1004,"height":660,"label":"Limiting chat messages"},{"id":"ec1597e4e7f3530c","type":"group","x":-209,"y":-208,"width":290,"height":348,"label":"Chat arrows"},{"id":"09ce49517baf7eda","type":"text","text":"","x":-189,"y":-60,"width":250,"height":60},{"id":"b90c7fbfa70e4300","type":"text","text":"{{NOTE}}","x":-189,"y":60,"width":250,"height":60,"color":"6"},{"id":"4857524edbae8263","type":"text","text":"This chat arrow will parse the contents of the reference node into an array of messages","x":100,"y":-147,"width":380,"height":87},{"id":"ef3cdc2a117f9156","type":"text","text":"{{NOTE}}","x":-330,"y":420,"width":250,"height":60,"color":"6"},{"id":"82ba7993840f1760","type":"text","text":"","x":-330,"y":568,"width":250,"height":60},{"id":"09a9d8dd0741d74b","type":"text","text":"","x":163,"y":568,"width":250,"height":60},{"id":"9a309223d6ce3931","type":"text","text":"","x":-440,"y":680,"width":471,"height":360,"color":"6"},{"id":"f2d8da368e1c51b6","type":"text","text":"","x":53,"y":680,"width":471,"height":360,"color":"6"},{"id":"cd757b7484ffd798","type":"text","text":"{{NOTE}}","x":163,"y":420,"width":250,"height":60,"color":"6"},{"id":"d9739a4acdf10a34","type":"text","text":"This chat node is empty, so it will just send the previous messages it was given to the LLM","x":-610,"y":-86,"width":343,"height":106},{"id":"2b08e45e39b8eb39","type":"text","text":"This chat arrow will append the content of the response to the same note, as a stream.","x":100,"y":-30,"width":380,"height":120},{"id":"ce80fff3047872f3","type":"text","text":"The final chat arrow only sends the final response, so you can do anything you like with the space between the two chat arrows. \\n\\nUse this flexibility to build chatbots that send http requests, make decisions, edit notes, or gather relevant context.","x":-717,"y":60,"width":459,"height":200},{"id":"1097b1b80a3abe81","type":"text","text":"{{NOTE}}","x":-189,"y":-188,"width":250,"height":60,"color":"6"},{"id":"a8e6750d3ca80fff","type":"text","text":"This is a special reference node that references the note that was active when the cannoli was run.","x":-717,"y":-211,"width":450,"height":83},{"id":"2d01d9688ecbe4da","type":"text","text":"Green arrows are chat arrows. They can be used to build custom chatbots within obsidian using Cannoli.\\n\\nTry this by moving to a note, then running this cannoli using the \\"4. Chat arrows\\" command.","x":-277,"y":-440,"width":427,"height":180},{"id":"6ff1bc87ce822f42","x":-890,"y":489,"width":403,"height":218,"type":"text","text":"You can limit the number of messages parsed from a note by adding a number to the label.\\n\\nJust a number will limit the number of messages, and adding a \\"#\\" to the beginning of the label will limit based on an approximation of tokens. "},{"id":"2213c3caec2e3835","x":-800,"y":804,"width":315,"height":96,"type":"text","text":"The example on the left will send the most recent two messages from the note"},{"id":"fd4602caf5adb9bc","x":560,"y":508,"width":440,"height":90,"type":"text","text":"This chat arrow will send messages not exceeding the estimated token limit (but at least 1 message)"}],"edges":[{"id":"dddd3b587c8b7340","fromNode":"1097b1b80a3abe81","fromSide":"bottom","toNode":"09ce49517baf7eda","toSide":"top","color":"4"},{"id":"847946cb0fc14d7a","fromNode":"09ce49517baf7eda","fromSide":"bottom","toNode":"b90c7fbfa70e4300","toSide":"top","color":"4"},{"id":"8cc7de72b0881d19","fromNode":"ef3cdc2a117f9156","fromSide":"bottom","toNode":"82ba7993840f1760","toSide":"top","color":"4","label":"2"},{"id":"a738da5d15aa4bd8","fromNode":"82ba7993840f1760","fromSide":"bottom","toNode":"9a309223d6ce3931","toSide":"top","color":"2"},{"id":"b2376898a9f7d1f1","fromNode":"09a9d8dd0741d74b","fromSide":"bottom","toNode":"f2d8da368e1c51b6","toSide":"top","color":"2"},{"id":"9406dd17d5c41032","fromNode":"cd757b7484ffd798","fromSide":"bottom","toNode":"09a9d8dd0741d74b","toSide":"top","color":"4","label":"#500"}]}'
    }
  ],
  "3. Special nodes": [
    {
      name: "1. Floating nodes.canvas",
      content: `{"nodes":[{"type":"group","id":"6221f4693ddb3417","x":-320,"y":-80,"width":600,"height":460,"label":"Floating nodes"},{"type":"text","text":"Use a specific format on a floating node (no attached arrows) to create a global variable. You can read and write to this variable anywhere in the cannoli.","id":"9650a6926008b16f","x":-234,"y":-259,"width":414,"height":119},{"type":"text","text":"Now just write the new version by itself in your next response.","id":"867aca6f08aff01f","x":-1,"y":124,"width":250,"height":116},{"type":"text","text":"Please critique and rewrite this email to be a bit more apologetic:\\n{{[Email Draft]}}","id":"848648ac1ab74998","x":-14,"y":-60,"width":274,"height":120},{"type":"text","text":"{{[Email Draft]}}","id":"5246f4d07c4012a8","x":-1,"y":300,"width":250,"height":60,"color":"6"},{"type":"text","text":"In this example we reference and write to a floating node.","id":"38e2ac4e746d3f44","x":-580,"y":-30,"width":250,"height":90},{"type":"text","text":"When a floating node's first line is in single square brackets, it can be accessed as a variable.","id":"ff6cf4c87583cf77","x":-580,"y":111,"width":250,"height":129},{"type":"text","text":"You can reference floating node variables the same way you'd reference normal variables, but with the addition of single square brackets.","id":"80a63e1ff8700f60","x":300,"y":-40,"width":340,"height":120},{"type":"text","text":"This is an example of a Reference Node. When a content node is just a floating node reference or note reference wrapped in  double curly braces, you can write to the referenced location instead of the node itself.","id":"f0466f473408290b","x":300,"y":240,"width":516,"height":127},{"type":"text","text":"[Email Draft]\\nLet me get back to you on that","id":"329298ec10140a51","x":-300,"y":75,"width":250,"height":99}],"edges":[{"id":"f33f402d10538f79","fromNode":"848648ac1ab74998","fromSide":"bottom","toNode":"867aca6f08aff01f","toSide":"top"},{"id":"bfad0ddbfa29f18f","fromNode":"867aca6f08aff01f","fromSide":"bottom","toNode":"5246f4d07c4012a8","toSide":"top"}]}`
    },
    {
      name: "2. Action nodes.canvas",
      content: '{"nodes":[{"type":"group","id":"bde9e8c9838b15f7","x":-540,"y":260,"width":920,"height":820,"label":"Template example"},{"type":"group","id":"57121fc775e40f08","x":-480,"y":-140,"width":720,"height":304,"label":"Action node"},{"type":"text","text":"Write me a text with my todo items for tomorrow. Here are my notes:\\n{{[[TODO]]}}","id":"644e75c14fbf0f66","x":-452,"y":-120,"width":291,"height":130},{"type":"text","text":"You can set up action node templates in two ways.\\n\\n1. Adding them in the plugin settings (click + Template)\\n2. Creating a floating node with the template as a JSON object","id":"d7c2f23ed59d226e","x":-863,"y":-120,"width":329,"height":280},{"type":"text","text":"Random Chuck Norris Joke","id":"26a3b80a6af9c744","x":-80,"y":-120,"width":250,"height":60,"color":"2"},{"type":"text","text":"Translate this joke into latin and remove the json","id":"89cfe3ad39ea9129","x":-80,"y":-20,"width":250,"height":60,"color":"0"},{"type":"text","text":"","id":"f0588ef3506e99e9","x":-80,"y":70,"width":250,"height":60,"color":"6"},{"type":"text","text":"Text me","id":"a4500d915425b8f6","x":-431,"y":70,"width":250,"height":60,"color":"2"},{"type":"text","text":"Simply reference a template using its name in the action node.","id":"ef226520ee26b04e","x":260,"y":-40,"width":362,"height":80},{"type":"text","text":"Orange nodes are action nodes. You can use them to make http calls with content from the cannoli.","id":"60bd8cc6ffcdd82b","x":-280,"y":-320,"width":291,"height":123},{"type":"text","text":"In this example, the body template requires two variables, \\"subject\\" and \\"content\\". You can provide these variables the way you usually provide variables for call nodes.","id":"1276a3e56b64ebfc","x":400,"y":582,"width":448,"height":136},{"type":"text","text":"[Email me]\\n```json\\n{\\n  \\"url\\": \\"https://api.sendgrid.com/v3/mail/send\\",\\n  \\"method\\": \\"POST\\",\\n  \\"headers\\": {\\n    \\"Content-Type\\": \\"application/json\\",\\n    \\"Authorization\\": \\"Bearer 1234\\"\\n  },\\n  \\"bodyTemplate\\": {\\n    \\"personalizations\\": [\\n      {\\n        \\"to\\": [\\n          {\\n            \\"email\\": \\"cannoli@cannoli.com\\"\\n          }\\n        ]\\n      }\\n    ],\\n    \\"from\\": {\\n      \\"email\\": \\"cannoli@cannoli.com\\"\\n    },\\n    \\"subject\\": \\"{{subject}}\\",\\n    \\"content\\": [\\n      {\\n        \\"type\\": \\"text/plain\\",\\n        \\"value\\": \\"{{content}}\\"\\n      }\\n    ]\\n  }\\n}\\n```","id":"00e28f79ba0da98b","x":-500,"y":300,"width":440,"height":740},{"type":"text","text":"Write me an email summarizing my notes from this meeting:\\n{{[[Meeting Notes]]}}","id":"a48a862d95ca71ae","x":-40,"y":520,"width":291,"height":130},{"type":"text","text":"Email me","id":"1d13ff952b032937","x":-19,"y":760,"width":250,"height":60,"color":"2"},{"type":"text","text":"Body Templates:\\n\\n- You can predefine what the body of the http request will look like using a body template.\\n- Name variable references using the format {{variable}}. You can use this to inject content from the cannoli in specific ways.\\n- If there is no body template, the body will just be whatever is written to the action node.","id":"f44dec64c8fe0af2","x":-1020,"y":700,"width":458,"height":277},{"type":"text","text":"You can write action node templates in JSON like this. (The JSON code block is optional)\\n\\nThese fields are required:\\n\\n- url\\n- method\\n\\nThese fields are optional:\\n\\n- headers\\n- bodyTemplate","id":"0967ce0429d322cc","x":-1020,"y":300,"width":458,"height":340}],"edges":[{"id":"964c0c5be9b3a97a","fromNode":"644e75c14fbf0f66","fromSide":"bottom","toNode":"a4500d915425b8f6","toSide":"top"},{"id":"a80a16dedbed00a1","fromNode":"26a3b80a6af9c744","fromSide":"bottom","toNode":"89cfe3ad39ea9129","toSide":"top"},{"id":"dad771d1fff98094","fromNode":"89cfe3ad39ea9129","fromSide":"bottom","toNode":"f0588ef3506e99e9","toSide":"top"},{"id":"bb08ec4cc1aba258","fromNode":"a48a862d95ca71ae","fromSide":"bottom","toNode":"1d13ff952b032937","toSide":"top","color":"6","label":"subject"},{"id":"4965c2f949fd6be0","fromNode":"a48a862d95ca71ae","fromSide":"right","toNode":"1d13ff952b032937","toSide":"right","color":"6","label":"content"}]}'
    },
    {
      name: "3. Formatter nodes.canvas",
      content: '{"nodes":[{"type":"group","id":"94f5f94475efad52","x":-242,"y":-100,"width":512,"height":635,"label":"Formatter nodes"},{"type":"text","text":"Respond with the name of a nosy villager character","id":"e2163e206cbda905","x":-200,"y":-80,"width":250,"height":60},{"type":"text","text":"","id":"b9b423ce99fb31c9","x":-217,"y":360,"width":284,"height":155,"color":"6"},{"type":"text","text":"A content node wrapped in double double quotes (\\"\\") is a formatter node. They will not be overwritten.","id":"0be55ec8c78cd264","x":-500,"y":201,"width":250,"height":119},{"type":"text","text":"\\"\\"Name: {{name}}\\nLines:\\n{{lines}}\\"\\"","id":"4f1b8e3bd87e5bd8","x":-222,"y":160,"width":294,"height":140,"color":"6"},{"type":"text","text":"Formatter nodes allow you to work with variables the same way you do with call nodes, but without making an LLM call.","id":"b6560aee19ea758c","x":-180,"y":-260,"width":394,"height":113},{"type":"text","text":"You can use the output of formatter nodes the same way you use call nodes.","id":"897ca9e72f35add4","x":-500,"y":385,"width":250,"height":105},{"type":"text","text":"Now write a list of 5 lines they might say.","id":"7a909145058b7691","x":0,"y":40,"width":250,"height":60}],"edges":[{"id":"3ba3954eb0260bb0","fromNode":"e2163e206cbda905","fromSide":"bottom","toNode":"7a909145058b7691","toSide":"top"},{"id":"be08a31884ecc768","fromNode":"e2163e206cbda905","fromSide":"bottom","toNode":"4f1b8e3bd87e5bd8","toSide":"top","label":"name"},{"id":"2f201d9220f6ef3f","fromNode":"7a909145058b7691","fromSide":"bottom","toNode":"4f1b8e3bd87e5bd8","toSide":"top","label":"lines"},{"id":"f590014afea4fcd1","fromNode":"4f1b8e3bd87e5bd8","fromSide":"bottom","toNode":"b9b423ce99fb31c9","toSide":"top"}]}'
    },
    {
      name: "4. Reference nodes.canvas",
      content: '{"nodes":[{"type":"group","id":"546578b6fae29490","x":-420,"y":-160,"width":580,"height":640,"label":"Reference nodes"},{"id":"8d414d7be725ce11","type":"group","x":-420,"y":880,"width":610,"height":259,"label":"Getting properties"},{"id":"8fd4e3f6e22304ba","type":"group","x":-420,"y":560,"width":290,"height":259,"label":"Getting note name"},{"id":"8c0fb44530075f7d","type":"group","x":-420,"y":1200,"width":290,"height":259,"label":"Getting note path"},{"type":"text","text":"{{[Current state]}}","id":"079588e3f7e0afa0","x":-393,"y":203,"width":250,"height":60,"color":"6"},{"type":"text","text":"Reference nodes can reference floating nodes or notes from your vault.","id":"a8346a9d96a737bb","x":-692,"y":238,"width":262,"height":114},{"type":"text","text":"Reference nodes are content nodes surrounded by double curly braces.","id":"a9ea85b101bc8776","x":-686,"y":-149,"width":250,"height":129},{"type":"text","text":"You can write or read from them the same way you use normal content nodes.","id":"be5c114d263a0107","x":-686,"y":66,"width":250,"height":137},{"type":"text","text":"Write a poem about walking","id":"fba8c017a84a0a74","x":-380,"y":-124,"width":250,"height":60,"color":"0"},{"type":"text","text":"{{[[Walking Poem]]}}","id":"e8e998b3d784e3a1","x":-380,"y":6,"width":250,"height":60,"color":"6"},{"type":"text","text":"Reference nodes can be used to write to and read from notes in your vault or floating nodes on the cannoli.","id":"28c071d10dfda17f","x":-333,"y":-340,"width":379,"height":122},{"type":"text","text":"[Current state]\\nNot much going on","id":"e08885cd2f146f7d","x":-113,"y":203,"width":250,"height":92},{"id":"344bb3da359269a4","type":"text","text":"","x":-100,"y":327,"width":237,"height":113,"color":"6"},{"type":"text","text":"Does this change our plan at all:\\n{{a}}","id":"e9768515f6295d9b","x":-393,"y":333,"width":250,"height":100,"color":"0"},{"id":"963eacfd11f92b34","type":"text","text":"{{[[Meeting Notes]]}}","x":-400,"y":580,"width":250,"height":60,"color":"6"},{"id":"ef10f47160ceb92a","type":"text","text":"","x":-400,"y":739,"width":250,"height":60,"color":"6"},{"id":"f85bdd621bacd536","type":"text","text":"If a variable arrow coming from a reference node starts with a square bracket, it will extract the link for the reference.\\n\\nThis is uses in cases when you dynamically create nodes and need to get their link reliably.","x":-763,"y":580,"width":318,"height":239},{"id":"da10ade6ef9ec7fb","type":"text","text":"{{[[Meeting Notes]]}}","x":-400,"y":900,"width":250,"height":60,"color":"6"},{"id":"d0e83b31dc2a1576","type":"text","text":"{{[[Meeting Notes]]}}","x":-90,"y":900,"width":250,"height":60,"color":"6"},{"id":"1566407420c6d37d","type":"text","text":"","x":-400,"y":1059,"width":250,"height":60,"color":"6"},{"id":"68e42dd6d4721f26","type":"text","text":"","x":-90,"y":1059,"width":250,"height":60,"color":"6"},{"id":"28a0281c87a0c588","type":"text","text":"{{[[Meeting Notes]]}}","x":-400,"y":1220,"width":250,"height":60,"color":"6"},{"id":"babacacceece0d0f","type":"text","text":"","x":-400,"y":1379,"width":250,"height":60,"color":"6"},{"id":"bad9bf674fca2bfa","type":"text","text":"You can use arrows that start with \\":\\" to retrieve the associated property of the same name from a note.\\n\\nIf there is nothing on the arrow other than \\":\\", all properties will be retrieved. ","x":-763,"y":900,"width":318,"height":239},{"id":"b6b1e156ad3548a2","type":"text","text":"You can use arrows that start with \\"/\\" to retrieve the path of a reference node.\\n\\nThis could be useful for creating notes in the same folder as dynamically selected notes.","x":-763,"y":1220,"width":318,"height":219}],"edges":[{"id":"bc3f3aa5abc3914d","fromNode":"fba8c017a84a0a74","fromSide":"bottom","toNode":"e8e998b3d784e3a1","toSide":"top"},{"id":"c98efd6bf2dff5d4","fromNode":"079588e3f7e0afa0","fromSide":"bottom","toNode":"e9768515f6295d9b","toSide":"top","label":"a"},{"id":"20b93bd61e36c19f","fromNode":"963eacfd11f92b34","fromSide":"bottom","toNode":"ef10f47160ceb92a","toSide":"top","label":"["},{"id":"d1ab9632f705d309","fromNode":"e9768515f6295d9b","fromSide":"right","toNode":"344bb3da359269a4","toSide":"left","color":"2"},{"id":"4320417bc6736dd9","fromNode":"da10ade6ef9ec7fb","fromSide":"bottom","toNode":"1566407420c6d37d","toSide":"top","label":":Date"},{"id":"e56ac04c2a7ef6da","fromNode":"d0e83b31dc2a1576","fromSide":"bottom","toNode":"68e42dd6d4721f26","toSide":"top","label":":"},{"id":"06d6a4450c69c049","fromNode":"28a0281c87a0c588","fromSide":"bottom","toNode":"babacacceece0d0f","toSide":"top","label":"/"}]}'
    }
  ],
  "4. Vault interaction": [
    {
      name: "1. Referencing notes.canvas",
      content: `{"nodes":[{"type":"group","id":"1e30c5b622c33707","x":-700,"y":-160,"width":600,"height":500,"label":"Reference nodes"},{"type":"group","id":"34ab67ca730bb363","x":-700,"y":420,"width":600,"height":500,"label":"Extraction modifiers"},{"type":"group","id":"4b47baa584657fc0","x":-700,"y":-620,"width":650,"height":360,"label":"Notes as variables"},{"id":"3c55aea3ab7679cf","type":"group","x":-690,"y":1680,"width":610,"height":259,"label":"Getting properties"},{"id":"71f82d60459605e9","type":"group","x":-690,"y":1000,"width":290,"height":290,"label":"Special \\"NOTE\\" reference"},{"id":"bc6196ed2a59141c","type":"group","x":-690,"y":1360,"width":290,"height":259,"label":"Getting note names"},{"id":"f5c0436b8aa42d7f","type":"group","x":-690,"y":2000,"width":290,"height":259,"label":"Getting note path"},{"type":"text","text":"Check this out:\\n{{[[Lemons for Cleaning]]}}","id":"24fc10789416284c","x":-680,"y":-600,"width":250,"height":60},{"type":"text","text":"What was in that note?","id":"e62b59877d19a53b","x":-680,"y":-490,"width":250,"height":50},{"type":"text","text":"","id":"62447884955fc816","x":-409,"y":-560,"width":349,"height":280,"color":"6"},{"type":"text","text":"You can reference notes in Cannolis to give LLMs up-to-date context conveniently.","id":"305dbf844cee4b22","x":-562,"y":-780,"width":328,"height":102},{"type":"text","text":"To show the LLM the content of a note, simply wrap a note link in curly braces, just as you would a variable.","id":"9ae16a6025e83401","x":-1060,"y":-521,"width":345,"height":113},{"type":"file","file":"Cannoli College/Example notes/Apple Trees.md","text":"{{[[Apple Trees]]}}","id":"b7597d6f39e7acc9","x":-690,"y":-120,"width":283,"height":145},{"type":"text","text":"What's the note above about","id":"8039b20f5e260110","x":-673,"y":80,"width":250,"height":80},{"type":"text","text":"What's this about:\\n{{a}}","id":"dec28b770c6e0601","x":-359,"y":80,"width":250,"height":80},{"type":"text","text":"","id":"37c33e8f19a09beb","x":-680,"y":-380,"width":250,"height":100,"color":"6"},{"type":"text","text":"You can also pull the content of notes with arrows leaving Obsidian's built-in file cards.","id":"7563d53b40bf5f1a","x":-986,"y":-101,"width":271,"height":126},{"type":"text","text":"The same effect can be achieved with a reference node, using this double curly brace notation in a content node.","id":"7486aafd14a866f8","x":-80,"y":-103,"width":340,"height":111},{"type":"text","text":"{{[[Lemons for Cleaning]]}}","id":"aa6a67a2ff0f2fe8","x":-359,"y":-77,"width":250,"height":60,"color":"6"},{"type":"text","text":"","id":"a96e14fbb7d1265f","x":-673,"y":200,"width":250,"height":120,"color":"6"},{"type":"text","text":"","id":"7f19194be69549ec","x":-359,"y":200,"width":250,"height":120,"color":"6"},{"id":"e7990bd20a1a3f11","type":"text","text":"{{NOTE}}","x":-670,"y":1020,"width":250,"height":60},{"id":"da19d9eee04a6946","type":"text","text":"This reference node will always correspond to the active note when the cannoli was started.\\n\\nYou can use this syntax to build chatbots (see [[4. Chat arrows.cno.canvas|4. Chat arrows.cno]]) or cannolis that process the content of the active note somehow.","x":-1039,"y":1010,"width":324,"height":260},{"id":"dd06bd8ffd8959c3","type":"text","text":"","x":-670,"y":1140,"width":250,"height":130,"color":"6"},{"type":"text","text":"You can change how notes are extracted or edited using symbols after the note within a reference.\\n\\nThese modifiers will override the related settings you chose in the cannoli settings.","id":"f98df3d186b6b8b3","x":-1080,"y":410,"width":365,"height":205},{"id":"21a132196d1026bf","type":"text","text":"To add the filename of a note as a header, reference it like this:\\n{{[[Note]]#}}\\n\\nIf your default setting is to add the filename header, you can remove it like this:\\n{{[[Note]]!#}}","x":-1074,"y":660,"width":354,"height":245},{"type":"text","text":"{{[[Meeting Notes]]^}}","id":"10439db683a6c0a7","x":-368,"y":473,"width":250,"height":60,"color":"6"},{"id":"0856fc4c98e0e01c","type":"text","text":"To include the properties (YAML frontmatter) in the note, reference it like this:\\n{{[[Note]]^}}\\n\\nIf your default setting is to include the properties, you can remove them like this:\\n{{[[Note]]!^}}\\n\\nIf you are editing a note, this modifier will also change if the edit can affect the existing properties. This is useful if you don't want to overwrite properties when you edit a note.","x":-80,"y":408,"width":420,"height":342},{"id":"8352e64802f9ff93","type":"text","text":"You can add multiple modifiers in a single reference:\\n{{[[Note]]^!#}}","x":-80,"y":780,"width":398,"height":120},{"id":"b63aa69459ed0e33","type":"text","text":"{{[[Meeting Notes]]}}","x":-670,"y":1380,"width":250,"height":60,"color":"6"},{"id":"d19cad0060fcb71c","type":"text","text":"","x":-670,"y":1539,"width":250,"height":60,"color":"6"},{"id":"9aff2c48988f7fdf","type":"text","text":"If a variable arrow coming from a reference node starts with a square bracket, it will extract the link for the reference.\\n\\nThis is uses in cases when you dynamically create nodes and need to get their link reliably.","x":-1033,"y":1380,"width":318,"height":239},{"id":"d399962128a18b2e","type":"text","text":"","x":-680,"y":615,"width":268,"height":277,"color":"6"},{"id":"919f3852d5538bac","type":"text","text":"","x":-377,"y":615,"width":268,"height":277,"color":"6"},{"type":"text","text":"{{[[Meeting Notes]]#}}","id":"30afb34c1019f5df","x":-670,"y":473,"width":250,"height":60,"color":"6"},{"id":"9967b60050a55863","type":"text","text":"{{[[Meeting Notes]]}}","x":-670,"y":1700,"width":250,"height":60,"color":"6"},{"id":"570d87dc498def43","type":"text","text":"","x":-670,"y":1859,"width":250,"height":60,"color":"6"},{"id":"94c9f6ee12de2723","type":"text","text":"You can use arrows that start with \\":\\" to retrieve the associated property of the same name from a note.\\n\\nIf there is nothing on the arrow other than \\":\\", all properties will be retrieved. ","x":-1033,"y":1700,"width":318,"height":239},{"id":"382cdbdf89daa53c","type":"text","text":"{{[[Meeting Notes]]}}","x":-360,"y":1700,"width":250,"height":60,"color":"6"},{"id":"386367aa8acf2917","type":"text","text":"","x":-360,"y":1859,"width":250,"height":60,"color":"6"},{"id":"47f1774a10a6de98","type":"text","text":"{{[[Meeting Notes]]}}","x":-670,"y":2020,"width":250,"height":60,"color":"6"},{"id":"09ec11f71f736c5a","type":"text","text":"","x":-670,"y":2179,"width":250,"height":60,"color":"6"},{"id":"82df68e8b67c09c8","type":"text","text":"You can use arrows that start with \\"/\\" to retrieve the path of a reference node.\\n\\nThis could be useful for creating notes in the same folder as dynamically selected notes.","x":-1033,"y":2020,"width":318,"height":219}],"edges":[{"id":"7ebbdaba21c78245","fromNode":"24fc10789416284c","fromSide":"right","toNode":"62447884955fc816","toSide":"top","color":"2"},{"id":"ee4e6166d0ffe43d","fromNode":"24fc10789416284c","fromSide":"bottom","toNode":"e62b59877d19a53b","toSide":"top"},{"id":"063d6d8d083b2666","fromNode":"b7597d6f39e7acc9","fromSide":"bottom","toNode":"8039b20f5e260110","toSide":"top"},{"id":"9bcad28d8d703638","fromNode":"aa6a67a2ff0f2fe8","fromSide":"bottom","toNode":"dec28b770c6e0601","toSide":"top","label":"a"},{"id":"ba5e154b30f8168f","fromNode":"e62b59877d19a53b","fromSide":"bottom","toNode":"37c33e8f19a09beb","toSide":"top"},{"id":"6e838ae4192a0925","fromNode":"8039b20f5e260110","fromSide":"bottom","toNode":"a96e14fbb7d1265f","toSide":"top"},{"id":"7f3f25c31ae38f6d","fromNode":"dec28b770c6e0601","fromSide":"bottom","toNode":"7f19194be69549ec","toSide":"top"},{"id":"8af2e272382f3038","fromNode":"e7990bd20a1a3f11","fromSide":"bottom","toNode":"dd06bd8ffd8959c3","toSide":"top"},{"id":"aba263db1eb0f4b6","fromNode":"9967b60050a55863","fromSide":"bottom","toNode":"570d87dc498def43","toSide":"top","label":":Date"},{"id":"f0e0c3d61fe7aca3","fromNode":"30afb34c1019f5df","fromSide":"bottom","toNode":"d399962128a18b2e","toSide":"top"},{"id":"e137cb2b47fff78e","fromNode":"10439db683a6c0a7","fromSide":"bottom","toNode":"919f3852d5538bac","toSide":"top"},{"id":"7919954c7360c103","fromNode":"b63aa69459ed0e33","fromSide":"bottom","toNode":"d19cad0060fcb71c","toSide":"top","label":"["},{"id":"a149899b3a0f51b7","fromNode":"47f1774a10a6de98","fromSide":"bottom","toNode":"09ec11f71f736c5a","toSide":"top","label":"/"},{"id":"1bb84d00af5d18f5","fromNode":"382cdbdf89daa53c","fromSide":"bottom","toNode":"386367aa8acf2917","toSide":"top","label":":"}]}`
    },
    {
      name: "2. Writing to notes.canvas",
      content: `{"nodes":[{"type":"group","id":"a81f6864d57513f0","x":-335,"y":300,"width":755,"height":620,"label":"Tips"},{"type":"group","id":"92f439736587539d","x":-335,"y":-760,"width":615,"height":477,"label":"Reference nodes"},{"id":"50c183ba68857287","type":"group","x":-335,"y":1000,"width":610,"height":259,"label":"Editing properties"},{"type":"group","id":"255a410c19a12e56","x":-335,"y":-160,"width":355,"height":328,"label":"Protecting properties"},{"type":"text","text":"You can write to notes using file cards or the reference node format shown below.","id":"d9b027f149b4da0f","x":-140,"y":-942,"width":253,"height":122},{"type":"text","text":"Write a short article about using lemons for cleaning. It should have the title \\"Lemons for Cleaning\\" and use proper markdown.","id":"e19b655090530949","x":-312,"y":-740,"width":255,"height":150},{"type":"text","text":"Write a short article about using lemons for cleaning. It should have the title \\"Lemons for Cleaning\\" and use proper markdown.","id":"1de6b113e5ad75c5","x":8,"y":-740,"width":250,"height":150},{"type":"file","file":"Cannoli College/Example notes/Lemons for Cleaning.md","text":"{{[[Lemons for Cleaning]]}}","id":"d6552cf2b811cb0a","x":-315,"y":-540,"width":261,"height":237},{"type":"text","text":"You can write to a note the same way you'd write to a normal content node, from call nodes or other content nodes.","id":"fe1f2c35a7426056","x":-640,"y":-622,"width":280,"height":120},{"type":"text","text":"{{[[Lemons for Cleaning]]}}","id":"2160d3369fea2bcb","x":8,"y":-451,"width":250,"height":60,"color":"6"},{"type":"text","text":"Write a sample meeting minutes","id":"cc3989fddfc7607b","x":-297,"y":-134,"width":250,"height":80},{"type":"text","text":"Utilize multiple chat messages to get a clean written response. You can even use a more expensive model to generate the article, then use a less expensive one to copy the final product to the note.","id":"98deb4f5f13687c5","x":-800,"y":470,"width":440,"height":145},{"type":"text","text":"Outline and write a short article about growing apple trees.","id":"63db7ba6f5cb3524","x":-312,"y":320,"width":250,"height":100},{"type":"text","text":"Write a short poem about walking.","id":"9de84ebf983156f8","x":8,"y":320,"width":250,"height":100},{"type":"file","file":"Cannoli College/Example notes/Apple Trees.md","text":"{{[[Apple Trees]]}}","id":"0561c9ae1669460f","x":-315,"y":715,"width":255,"height":189},{"type":"text","text":"","id":"9de536515698d256","x":220,"y":618,"width":182,"height":62,"color":"6"},{"type":"text","text":"Field arrows can help get good formatting for notes. Use \\"content\\" and \\"title\\" field names to keep the LLM from writing the title of the note into the content.","id":"5943bd16d1a71072","x":440,"y":506,"width":357,"height":119},{"type":"text","text":"Ok, now respond with just the article\\n\\nThere should be nothing in your response other than the article","id":"94567e5a2b31c42b","x":-315,"y":475,"width":255,"height":180},{"type":"text","text":"You can change how notes are extracted or edited using symbols after the note within a reference.\\n\\nThese modifiers will override the related settings you chose in the cannoli settings.","id":"bffb0679a38e68b5","x":-720,"y":-134,"width":365,"height":205},{"id":"9fa03f1308317478","type":"text","text":"To allow the edit to overwrite the properties (YAML frontmatter) in the note, reference it like this:\\n{{[[Note]]^}}\\n\\nIf your default setting is to include (overwrite) the properties, you can remove them like this:\\n{{[[Note]]!^}}","x":48,"y":-122,"width":420,"height":229},{"type":"text","text":"{{[[Lemons for Cleaning]]!^}}","id":"6c3aaf24c1410da5","x":-309,"y":77,"width":274,"height":60,"color":"6"},{"type":"file","file":"Cannoli College/Example notes/Walking Poem.md","text":"{{[[Apple Trees]]}}","id":"5e54d6df61248d37","x":8,"y":715,"width":255,"height":189},{"id":"fe4f45ec55ab88f8","type":"text","text":"You can use arrows that start with \\":\\" to edit the property in the arrow label.\\n\\nThis also works for list format properties.","x":-678,"y":1020,"width":318,"height":189},{"id":"ae32c84e56f650cb","type":"text","text":"{{[[Meeting Notes]]}}","x":-310,"y":1179,"width":250,"height":60,"color":"6"},{"id":"b58f063da822b869","type":"text","text":"Tuesday","x":-310,"y":1020,"width":250,"height":60,"color":"6"},{"id":"d283ed9e9d24b01d","type":"text","text":"{{[[Meeting Notes]]}}","x":0,"y":1179,"width":250,"height":60,"color":"6"},{"id":"f82f1adc99fcc4db","type":"text","text":"- jim\\n- mary","x":0,"y":1020,"width":250,"height":80,"color":"6"}],"edges":[{"id":"32c1cb193a6bfc19","fromNode":"e19b655090530949","fromSide":"bottom","toNode":"d6552cf2b811cb0a","toSide":"top"},{"id":"e339725c61ba4f0b","fromNode":"1de6b113e5ad75c5","fromSide":"bottom","toNode":"2160d3369fea2bcb","toSide":"top"},{"id":"741c9e0b211241a2","fromNode":"94567e5a2b31c42b","fromSide":"bottom","toNode":"0561c9ae1669460f","toSide":"top"},{"id":"38d8c5cd09414fe8","fromNode":"9de84ebf983156f8","fromSide":"bottom","toNode":"5e54d6df61248d37","toSide":"top","color":"6","label":"content"},{"id":"6e207e77a539fbd3","fromNode":"9de84ebf983156f8","fromSide":"bottom","toNode":"9de536515698d256","toSide":"top","color":"6","label":"title"},{"id":"e7cd177b0fe4bf6b","fromNode":"63db7ba6f5cb3524","fromSide":"bottom","toNode":"94567e5a2b31c42b","toSide":"top"},{"id":"996659a79f50e2da","fromNode":"cc3989fddfc7607b","fromSide":"bottom","toNode":"6c3aaf24c1410da5","toSide":"top"},{"id":"790403f81a184f3b","fromNode":"b58f063da822b869","fromSide":"bottom","toNode":"ae32c84e56f650cb","toSide":"top","label":":weekday"},{"id":"503b5af7f363b512","fromNode":"f82f1adc99fcc4db","fromSide":"bottom","toNode":"d283ed9e9d24b01d","toSide":"top","label":":tags"}]}`
    },
    {
      name: "3. Dynamic note references.canvas",
      content: `{"nodes":[{"type":"group","id":"3884a37115998334","x":-200,"y":1160,"width":520,"height":760,"label":"Dynamic reference nodes"},{"type":"group","id":"1d4638cc848ce883","x":-160,"y":460,"width":460,"height":575,"label":"Ensuring proper note names"},{"type":"group","id":"190c7fe39136a4e6","x":-175,"y":-400,"width":321,"height":575,"label":"Note names as variables"},{"type":"text","text":"What's this about:\\n{{@note}}","id":"4e5095e59d3b1f75","x":-140,"y":-100,"width":250,"height":58},{"type":"text","text":"","id":"78a31a6b0db6e00a","x":-155,"y":40,"width":281,"height":115,"color":"6"},{"type":"text","text":"An \\"@\\" symbol in front of a variable reference will have the node attempt to extract the content of the note with that name.","id":"8dc52a792fef349a","x":-460,"y":-146,"width":275,"height":150},{"type":"text","text":"Respond with the name of one of these notes without square brackets:\\n[[Apple Trees]],\\n[[Lemons for Cleaning]]","id":"71fc4d9bcf7e5cef","x":-140,"y":-380,"width":250,"height":160},{"type":"text","text":"In addition to statically referencing notes, you can have the LLM generate note names that you expect to be valid, and reference them in prompts.","id":"aa35fa7b42662498","x":-220,"y":-580,"width":387,"height":120},{"type":"text","text":"Respond with the name of one of these notes:\\n[[Apple Trees]],\\n[[Lemons for Cleaning]]","id":"a563177e81b5c95e","x":-125,"y":480,"width":250,"height":140},{"type":"text","text":"The square bracket signifies that you'd like the LLM to respond with a note name, and Cannoli uses function calling to ensure that the response is only one of the note names present in the prompt.","id":"e2632c0409b0c31e","x":-500,"y":581,"width":335,"height":179},{"type":"text","text":"","id":"39b8926cc93a3400","x":-140,"y":860,"width":281,"height":155,"color":"6"},{"type":"text","text":"You can use this to build Cannolis that interact with your vault in dynamic ways, navigating through it using links.","id":"8c08925cfa290c8a","x":-508,"y":818,"width":343,"height":127},{"type":"text","text":"The same format can also be used for reference nodes.","id":"ff34fc6b7a9db4a4","x":-540,"y":1281,"width":335,"height":79},{"type":"text","text":"In this example, the LLM chooses a note and writes to it.","id":"c185a020e676b84a","x":-548,"y":1500,"width":343,"height":82},{"type":"text","text":"","id":"65d38a62ff03dbfe","x":110,"y":671,"width":175,"height":60,"color":"6"},{"type":"text","text":"Write an article with that title.","id":"d192686ddf19160b","x":40,"y":1430,"width":250,"height":60},{"type":"text","text":"Respond with the name of one of these notes:\\n[[Apple Trees]],\\n[[Lemons for Cleaning]]","id":"6b6b4b634889aad8","x":-165,"y":1180,"width":250,"height":140},{"type":"text","text":"{{@note}}","id":"8a0e100e00bdcaea","x":-165,"y":1582,"width":250,"height":58,"color":"6"},{"type":"text","text":"What's this about:\\n{{@note}}","id":"0db897a7e991783c","x":-125,"y":760,"width":250,"height":58},{"type":"text","text":"","id":"1394a8cbb5db72d9","x":-165,"y":1720,"width":455,"height":180,"color":"6"},{"type":"text","text":"Getting the LLM to properly name notes can be a challenge. You can ensure the response is a valid note name the LLM has seen by using a single square bracket prefix on an arrow label.","id":"8b52c0b7a2e3aa8a","x":-220,"y":240,"width":442,"height":141}],"edges":[{"id":"f0ecaa4ebe5d824b","fromNode":"71fc4d9bcf7e5cef","fromSide":"bottom","toNode":"4e5095e59d3b1f75","toSide":"top","label":"note"},{"id":"303a7695b62bb265","fromNode":"4e5095e59d3b1f75","fromSide":"bottom","toNode":"78a31a6b0db6e00a","toSide":"top","color":"2"},{"id":"cb401d73afd6b5b0","fromNode":"a563177e81b5c95e","fromSide":"bottom","toNode":"0db897a7e991783c","toSide":"top","label":"[note"},{"id":"87145bcd5b0ef58a","fromNode":"0db897a7e991783c","fromSide":"bottom","toNode":"39b8926cc93a3400","toSide":"top","color":"2"},{"id":"d7621f4a15b0b7fb","fromNode":"6b6b4b634889aad8","fromSide":"bottom","toNode":"8a0e100e00bdcaea","toSide":"top","label":"[note"},{"id":"8748f38aca7e3e66","fromNode":"6b6b4b634889aad8","fromSide":"bottom","toNode":"d192686ddf19160b","toSide":"top"},{"id":"6b0d63d0cc50d49a","fromNode":"d192686ddf19160b","fromSide":"bottom","toNode":"8a0e100e00bdcaea","toSide":"top"},{"id":"b2e6acd4ac04fdb5","fromNode":"a563177e81b5c95e","fromSide":"right","toNode":"65d38a62ff03dbfe","toSide":"top","label":"[note"},{"id":"3cbecc9da0226b67","fromNode":"8a0e100e00bdcaea","fromSide":"bottom","toNode":"1394a8cbb5db72d9","toSide":"top"}]}`
    },
    {
      name: "4. Creating notes.canvas",
      content: `{"nodes":[{"id":"4456b948335f3b94","type":"group","x":-334,"y":260,"width":731,"height":518,"label":"Defining path"},{"id":"837ba0cd52636e4c","type":"group","x":-280,"y":-335,"width":677,"height":518,"label":"Creating notes"},{"id":"fc94ad73861dd0b4","type":"text","text":"{{+@articleName}}","x":-40,"y":-146,"width":250,"height":60,"color":"6"},{"id":"375c5de56f45d5e1","type":"text","text":"The Truth About Hula Hoops","x":-260,"y":-296,"width":285,"height":60,"color":"6"},{"id":"679af4d2d1190b6b","type":"text","text":"Write a paragraph about a sinister history of hula hoops","x":85,"y":-315,"width":292,"height":79,"color":"0"},{"id":"bd60374fe51f025d","type":"text","text":"","x":-64,"y":-20,"width":299,"height":183,"color":"6"},{"id":"58140dc2db7bc769","type":"text","text":"You can create a note using a special reference node.\\n\\nAdd a \\"+\\" before the variable in a dynamic reference node, and it will create that note.","x":-660,"y":-236,"width":354,"height":180},{"id":"4c6e2bf4a9959f15","type":"text","text":"Write an overly apologetic email about how we're out of altoids","x":85,"y":280,"width":292,"height":100,"color":"0"},{"id":"6b9ee922dd00451b","type":"text","text":"{{+@title}}","x":-40,"y":449,"width":250,"height":60,"color":"6"},{"id":"8372acb7e244fb15","type":"text","text":"","x":-64,"y":575,"width":299,"height":183,"color":"6"},{"id":"0f4591137e166313","type":"text","text":"No more Altoids","x":-117,"y":280,"width":180,"height":60,"color":"6"},{"id":"b0608205e7a748f6","type":"text","text":"/Cannoli College/4. Vault interaction","x":-306,"y":350,"width":250,"height":60,"color":"6"},{"id":"f3c97367ffc6cce1","x":-700,"y":310,"width":342,"height":180,"type":"text","text":"You can define where the new note will be created using an arrow that starts with \\"/\\".\\n\\nIf it's a valid path, then the note will be created there."},{"id":"dec1b7beb803bffa","x":-608,"y":575,"width":250,"height":60,"type":"text","text":"This example will create a new note in this folder."},{"id":"7a8aaacc8a5f8e49","x":-635,"y":0,"width":329,"height":72,"type":"text","text":"This feature should play nicely with other plugins like templater."}],"edges":[{"id":"87857bf3a2254dec","fromNode":"375c5de56f45d5e1","fromSide":"bottom","toNode":"fc94ad73861dd0b4","toSide":"top","label":"articleName"},{"id":"a49c245f203702e6","fromNode":"679af4d2d1190b6b","fromSide":"bottom","toNode":"fc94ad73861dd0b4","toSide":"top"},{"id":"283a21bf831d34da","fromNode":"fc94ad73861dd0b4","fromSide":"bottom","toNode":"bd60374fe51f025d","toSide":"top"},{"id":"c0aea91c093cd031","fromNode":"6b9ee922dd00451b","fromSide":"bottom","toNode":"8372acb7e244fb15","toSide":"top"},{"id":"7aca371238d9f008","fromNode":"0f4591137e166313","fromSide":"bottom","toNode":"6b9ee922dd00451b","toSide":"top","label":"title"},{"id":"f2ab13710488acaa","fromNode":"4c6e2bf4a9959f15","fromSide":"bottom","toNode":"6b9ee922dd00451b","toSide":"top"},{"id":"f9e1ee261742cf86","fromNode":"b0608205e7a748f6","fromSide":"bottom","toNode":"6b9ee922dd00451b","toSide":"left","label":"/"}]}`
    },
    {
      name: "5. Referencing selections.canvas",
      content: `{"nodes":[{"id":"8c02946171040e71","type":"group","x":30,"y":-145,"width":350,"height":345,"label":"Special \\"SELECTION\\" variable"},{"id":"a0047756f6bf199f","type":"group","x":30,"y":280,"width":350,"height":320,"label":"Replacing selections"},{"id":"28278bc5135af80c","type":"text","text":"Respond with a more concise version of this text:\\n{{SELECTION}}","x":75,"y":-125,"width":250,"height":120},{"id":"9b5312d8361c2f5e","type":"text","text":"","x":75,"y":40,"width":250,"height":130,"color":"6"},{"id":"6f34b064907441fd","type":"text","text":"This works in any workspace where you can select text, including canvas files.\\n\\nTry it on the sentence above.","x":-313,"y":-100,"width":324,"height":140},{"id":"21dc5d31fab5298f","type":"text","text":"You can reference the current selection (the text highlighted by your cursor when you started the cannoli) using the {{SELECTION}} variable","x":11,"y":-360,"width":378,"height":142},{"id":"2deb4b62d41bbfb7","type":"text","text":"Respond with a more concise version of this text:\\n{{SELECTION}}","x":75,"y":300,"width":250,"height":120},{"id":"6e8591393bf5e285","type":"text","text":"You can write to a selection reference node just like a Note reference node. \\n\\nWriting to a {{SELECTION}} node will replace the text if there is a selection, or insert it at the cursor if there isn't.","x":-340,"y":325,"width":351,"height":175},{"id":"880831fc3c8b5e93","type":"text","text":"{{SELECTION}}","x":75,"y":500,"width":250,"height":60,"color":"6"},{"id":"c940877ff5ddd66f","type":"text","text":"Note that if you click away from a selection before the cannoli reaches this node, it will change where the replacement happens, so be wary of long cannolis that use this feature.","x":389,"y":346,"width":404,"height":133}],"edges":[{"id":"ff57adf1f2f08d4d","fromNode":"28278bc5135af80c","fromSide":"bottom","toNode":"9b5312d8361c2f5e","toSide":"top"},{"id":"e6c1d0371468967e","fromNode":"2deb4b62d41bbfb7","fromSide":"bottom","toNode":"880831fc3c8b5e93","toSide":"top"}]}`
    }
  ],
  "5. Groups": [
    {
      name: "1. Basic groups.canvas",
      content: `{"nodes":[{"type":"group","id":"3507f53b8ef19875","x":-400,"y":-280,"width":610,"height":940,"label":"Basic Groups"},{"type":"group","id":"9ea4603066155724","x":-100,"y":-220,"width":290,"height":273,"label":"Group 1"},{"type":"group","id":"9d076987e99ce6a6","x":-100,"y":260,"width":290,"height":240,"label":"Group 2"},{"type":"text","text":"Hey what model are you?","id":"554b1577865f24d4","x":-80,"y":280,"width":250,"height":60},{"type":"text","text":"Actually you don't know that.","id":"35881fd57b1d4269","x":-80,"y":420,"width":250,"height":60},{"type":"text","text":"","id":"fd9b2131408190a4","x":-80,"y":520,"width":250,"height":120,"color":"6"},{"type":"text","text":"gpt-4","id":"e7d78cc1a7a948f8","x":-320,"y":250,"width":105,"height":60,"color":"6"},{"type":"text","text":"Rubiks cube","id":"e83b4c5b2409b738","x":-370,"y":-163,"width":180,"height":57,"color":"6"},{"type":"text","text":"Here we use a basic group to provide all of the member nodes with a variable.","id":"1354395dbba49c59","x":-700,"y":-163,"width":290,"height":93},{"type":"text","text":"Basic groups allow you to conveniently provide variables or change config settings of multiple nodes.\\n\\nFunctionally, its the same as drawing arrows to every node in the group.","id":"cb4e55a56aa20105","x":-320,"y":-500,"width":423,"height":170},{"type":"text","text":"Groups whose label is not an integer are basic groups.","id":"ad8c877c4bdbc784","x":-298,"y":-620,"width":380,"height":94},{"type":"text","text":"You can use {{a}} in this node","id":"3f724ea642f3f39d","x":-80,"y":-200,"width":250,"height":60},{"type":"text","text":"And you can use {{a}} in this node","id":"6b128a864045c0e7","x":-80,"y":-27,"width":250,"height":60},{"type":"text","text":"","id":"b6f9f0b26ae8e68e","x":-80,"y":80,"width":250,"height":100,"color":"6"},{"type":"text","text":"Here we change the model config setting of all the member nodes of a group.","id":"e58e6effa966f52b","x":-728,"y":242,"width":318,"height":98}],"edges":[{"id":"3986f98e5c79c58a","fromNode":"e83b4c5b2409b738","fromSide":"right","toNode":"9ea4603066155724","toSide":"left","label":"a"},{"id":"b54add99d36d3b53","fromNode":"e7d78cc1a7a948f8","fromSide":"right","toNode":"9d076987e99ce6a6","toSide":"left","color":"2","label":"model"},{"id":"3ec08b096671959f","fromNode":"3f724ea642f3f39d","fromSide":"bottom","toNode":"6b128a864045c0e7","toSide":"top"},{"id":"71449d8dc3ac9bac","fromNode":"6b128a864045c0e7","fromSide":"bottom","toNode":"b6f9f0b26ae8e68e","toSide":"top","color":"2"},{"id":"b2ca430257741d71","fromNode":"554b1577865f24d4","fromSide":"bottom","toNode":"35881fd57b1d4269","toSide":"top"},{"id":"948da6eeffd07b7e","fromNode":"35881fd57b1d4269","fromSide":"bottom","toNode":"fd9b2131408190a4","toSide":"top","color":"2"}]}`
    },
    {
      name: "2. Loop groups.canvas",
      content: '{"nodes":[{"type":"group","id":"33e7457728f9ef47","x":-320,"y":-80,"width":820,"height":560,"label":"Nested loop groups"},{"type":"group","id":"0064c11720e6cf20","x":-320,"y":560,"width":820,"height":480,"label":"The loop number variable"},{"type":"group","id":"81cdef3b9de52df9","x":-200,"y":-880,"width":460,"height":680,"label":"Loop groups"},{"type":"group","id":"df42bd1da1866b7f","x":-300,"y":0,"width":330,"height":420,"label":"2"},{"type":"group","id":"2ae53ef6008eeb4e","x":-300,"y":640,"width":360,"height":360,"label":"2"},{"type":"group","id":"986991747df080b2","x":-115,"y":-720,"width":290,"height":260,"label":"3"},{"type":"group","id":"d83bf39a509c67bd","x":-280,"y":150,"width":280,"height":250,"label":"2"},{"type":"group","id":"76b98e9977f73412","x":-280,"y":790,"width":310,"height":190,"label":"2"},{"type":"text","text":"When all the nodes in a loop group are finished, all nodes will reset and the group will restart. \\n\\nIt will loop as many times as are defined in the label, and only the result of the final loop will be sent along the arrows leaving the group.","id":"6e5fbad373215bd8","x":-660,"y":-695,"width":441,"height":170},{"type":"text","text":"Loop groups are colorless groups that have a positive integer in their label.","id":"a408edeafd6bc62f","x":-169,"y":-1040,"width":399,"height":89},{"type":"text","text":"This message will be sent once","id":"2a9251ad533d8576","x":-95,"y":-860,"width":250,"height":60},{"type":"text","text":"This one will be sent 3 times","id":"896ace77fa0c6a7e","x":-95,"y":-700,"width":250,"height":60},{"type":"text","text":"Only the last response will be written to the content node outside the loop.","id":"c6b8d6a1f384022f","x":-95,"y":-610,"width":250,"height":120},{"type":"text","text":"","id":"96f3935e8174877f","x":-95,"y":-400,"width":250,"height":180,"color":"6"},{"type":"text","text":"Nested loop groups will fully reset, meaning in this case the inner group will repeat 4 times.","id":"24835b0cc486957f","x":-690,"y":64,"width":350,"height":106},{"type":"text","text":"This message will be sent 2 times","id":"d09815f95971b8a6","x":-260,"y":20,"width":250,"height":60},{"type":"text","text":"This will be sent 4 times","id":"479bd3009fb464b0","x":-260,"y":170,"width":250,"height":60},{"type":"text","text":"","id":"cdc967d2e777ade5","x":85,"y":-40,"width":395,"height":500,"color":"6"},{"type":"text","text":"Be careful with nested loop groups","id":"bc61ab59035be49d","x":-260,"y":280,"width":250,"height":90},{"type":"text","text":"Logging edges from loop groups will log out what happens on each loop and sub-loop (if its nested)","id":"17c0c46b3378bd79","x":520,"y":120,"width":321,"height":102},{"type":"text","text":"","id":"7b6747a24b1ed36e","x":85,"y":600,"width":395,"height":400,"color":"6"},{"type":"text","text":"Inner loop number: {{#}}\\nOuter loop number: {{##}}","id":"a1e4bbbafcec0850","x":-260,"y":840,"width":270,"height":100},{"id":"f029d4309bd2b1fc","x":-650,"y":665,"width":310,"height":260,"type":"text","text":"You can access the current loop number/iteration of the loop group a node is in using the variable {{#}} or {{##...}}.\\n\\nThe number of \\"#\\"s corresponds to the depth of the loop number you want to see, in the case of nested loops."},{"type":"text","text":"Hello there","id":"4b6e4eac00d4ca2a","x":-250,"y":680,"width":250,"height":60},{"id":"ea53365b1b01a031","x":520,"y":740,"width":356,"height":217,"type":"text","text":"This is useful for processing lists of items using the loop group, as you can tell the LLM to handle a specific item in the list iteratively.\\n\\n(There is a forEach group feature on its way, where this would be handled in parallel)"}],"edges":[{"id":"270794f37f25bb76","fromNode":"c6b8d6a1f384022f","fromSide":"bottom","toNode":"96f3935e8174877f","toSide":"top"},{"id":"fa5fd9941ce413fa","fromNode":"896ace77fa0c6a7e","fromSide":"bottom","toNode":"c6b8d6a1f384022f","toSide":"top"},{"id":"f0286819a9f22127","fromNode":"2a9251ad533d8576","fromSide":"bottom","toNode":"896ace77fa0c6a7e","toSide":"top"},{"id":"007d49590f64ef9d","fromNode":"d09815f95971b8a6","fromSide":"bottom","toNode":"479bd3009fb464b0","toSide":"top"},{"id":"65ef095c89dded80","fromNode":"479bd3009fb464b0","fromSide":"bottom","toNode":"bc61ab59035be49d","toSide":"top"},{"id":"adc29be9103fb02b","fromNode":"bc61ab59035be49d","fromSide":"right","toNode":"cdc967d2e777ade5","toSide":"left","color":"2"},{"id":"734208df80c9a33e","fromNode":"a1e4bbbafcec0850","fromSide":"right","toNode":"7b6747a24b1ed36e","toSide":"left","color":"2"},{"id":"8c921de751762ac3","fromNode":"4b6e4eac00d4ca2a","fromSide":"bottom","toNode":"a1e4bbbafcec0850","toSide":"top"}]}'
    },
    {
      name: "3. Loop group features.canvas",
      content: `{"nodes":[{"type":"group","id":"cd5aefdec24485a6","x":-395,"y":920,"width":1200,"height":1187,"label":"Conditional loop groups"},{"type":"group","id":"b41f5d77d2587137","x":-215,"y":-344,"width":840,"height":948,"label":"Feedback variables"},{"type":"group","id":"a8db6171d1ed7037","x":-375,"y":987,"width":680,"height":1040,"label":"3"},{"type":"group","id":"308eacb6bc673cc4","x":5,"y":-136,"width":290,"height":240,"label":"3"},{"type":"text","text":"Crisp shell, sweet delight, Ricotta whispers within, Sicily's soft night.","id":"8bd344c2d351a946","x":25,"y":-324,"width":250,"height":100,"color":"6"},{"type":"text","text":"If a variable edge is pointing from a group member to the group itself, this variable will be accessible on subsequent loops. (This is an exception to the rule that the Cannoli must be a DAG)","id":"69c0aa7ba528fd7f","x":25,"y":-604,"width":378,"height":187},{"type":"text","text":"Critique this haiku:\\n{{a}}","id":"4522c0d5f13ecbf2","x":25,"y":-104,"width":250,"height":60},{"type":"text","text":"Respond with a rewrite. Nothing else should be in your response.","id":"08d62752b952d1b9","x":25,"y":-14,"width":250,"height":90},{"type":"text","text":"If there are multiple available arrows with the same name, the node will prefer the self-group-pointing one.\\n\\nYou can use this to pre-load variables with an initial version for the first loop, which will be written over in later loops.","id":"1547e2e1c8e36e01","x":-625,"y":-214,"width":390,"height":221},{"type":"text","text":"This is an example of a rewrite loop, where we have the LLM rewrite a piece of content several times and output the final result.","id":"39f5077b01de86bc","x":-618,"y":215,"width":383,"height":121},{"type":"text","text":"","id":"0209622577e4d8e4","x":-195,"y":196,"width":270,"height":205,"color":"6"},{"type":"text","text":"","id":"a8c82e1399aa0667","x":144,"y":217,"width":461,"height":367,"color":"6"},{"type":"text","text":"If a loop group has incoming arrows from within itself, it will only loop if they are all activated.\\n\\nThis means you can use choice arrows to create groups that stop looping based on a decision the LLM makes.","id":"109c6d143c904ac2","x":-40,"y":700,"width":559,"height":153},{"type":"text","text":"Are there any obvious improvements to this article?\\n\\n{{article}}","id":"c9ac27366825fb46","x":-271,"y":1327,"width":283,"height":122},{"type":"text","text":"What would you change?","id":"42e65836e7bc0d2d","x":-254,"y":1540,"width":250,"height":60},{"type":"file","file":"Cannoli College/Example notes/Lemons for Cleaning.md","text":"{{[[Lemons for Cleaning]]}}","id":"9b09ade8a96fdc49","x":-330,"y":1025,"width":400,"height":203},{"type":"text","text":"In this example, we use choice arrows to have the LLM decide whether to edit a note.\\n\\nThe decision to edit it activates a path that points to the group itself, so the group will loop again once it is done.\\n\\nIf that path is rejected, the group will not loop again.","id":"3ae1b1035e633274","x":-814,"y":1228,"width":402,"height":259},{"type":"text","text":"Respond with a rewrite based on your feedback.","id":"92dee3525bb5528a","x":-289,"y":1660,"width":320,"height":100},{"type":"text","text":"","id":"65d12403b1902562","x":120,"y":1328,"width":165,"height":121,"color":"6"},{"type":"text","text":"","id":"c19decb87eb68f4e","x":340,"y":1443,"width":440,"height":535,"color":"6"},{"type":"text","text":"It doesn't matter what the node pointing at the group is, or what kind of arrow. In this case we use a blank arrow to signal that the rewrite path was chosen and add the chat history suppression suffix (~) so we don't continue the conversation in the next loop.","id":"07a8d464729bd7db","x":-800,"y":1864,"width":388,"height":196},{"type":"file","file":"Cannoli College/Example notes/Lemons for Cleaning.md","text":"{{[[Lemons for Cleaning]]}}","id":"a447b4af7f9b59af","x":-329,"y":1820,"width":400,"height":180}],"edges":[{"id":"98bface3c4272939","fromNode":"08d62752b952d1b9","fromSide":"right","toNode":"308eacb6bc673cc4","toSide":"right","label":"a"},{"id":"01117e93ffd16810","fromNode":"8bd344c2d351a946","fromSide":"bottom","toNode":"4522c0d5f13ecbf2","toSide":"top","label":"a"},{"id":"4705bd8c3ac7a1dd","fromNode":"4522c0d5f13ecbf2","fromSide":"bottom","toNode":"08d62752b952d1b9","toSide":"top"},{"id":"09153b08d8afc249","fromNode":"08d62752b952d1b9","fromSide":"bottom","toNode":"0209622577e4d8e4","toSide":"top"},{"id":"d74b679a0e9c5a8e","fromNode":"08d62752b952d1b9","fromSide":"bottom","toNode":"a8c82e1399aa0667","toSide":"top","color":"2"},{"id":"313f7dba1ac082e7","fromNode":"a447b4af7f9b59af","fromSide":"bottom","toNode":"a8db6171d1ed7037","toSide":"bottom","label":"~"},{"id":"ae86725de62f454c","fromNode":"92dee3525bb5528a","fromSide":"right","toNode":"c19decb87eb68f4e","toSide":"left","color":"2"},{"id":"28dd5bf26534621f","fromNode":"9b09ade8a96fdc49","fromSide":"bottom","toNode":"c9ac27366825fb46","toSide":"top","label":"article"},{"id":"cb414a8bed4cab51","fromNode":"c9ac27366825fb46","fromSide":"bottom","toNode":"42e65836e7bc0d2d","toSide":"top","color":"3","label":"yes"},{"id":"8e14d432eb6409d9","fromNode":"c9ac27366825fb46","fromSide":"right","toNode":"65d12403b1902562","toSide":"left","color":"3","label":"no"},{"id":"e151468f90fae46f","fromNode":"42e65836e7bc0d2d","fromSide":"bottom","toNode":"92dee3525bb5528a","toSide":"top"},{"id":"e9279e94dd7a9109","fromNode":"92dee3525bb5528a","fromSide":"bottom","toNode":"a447b4af7f9b59af","toSide":"top"}]}`
    }
  ],
  "Example notes": [
    {
      name: "Apple Trees.md",
      content: "Apple trees, scientifically known as *Malus domestica*, are not just providers of one of the world's most consumed fruits but are also a model of efficiency and adaptability. Originating in Central Asia, these trees have been cultivated for thousands of years and have adapted to a variety of climates, from temperate to sub-tropical. The tree's rootstock can often be grafted to optimize for disease resistance, soil compatibility, or fruit yield, a testament to its remarkable genetic flexibility.\n\nThe life cycle of an apple tree involves a series of well-coordinated biological events. After the cold dormancy of winter, apple trees enter a phase of bud break in the spring, followed by flowering and pollination. Apple trees are usually not self-pollinating and require cross-pollination from another apple tree of a different variety. This ensures genetic diversity, which is crucial for the tree's adaptability and long-term survival. Post-pollination, the tree focuses on fruit development, channeling nutrients and energy into the growing apples.\n\nApple trees also have a profound impact on ecosystems. They offer habitat and food sources for various species, including but not limited to, bees, birds, and small mammals. Their flowers provide nectar for bees, aiding in the process of pollination for not just apple trees but other plants in the ecosystem. Their leaves and bark offer shelter and their fallen fruits are a food source for multiple ground-dwelling organisms. \n\nHowever, it's worth considering the impact of monoculture and industrial farming practices on apple trees. While these methods might increase short-term yield, they can also make the trees more susceptible to diseases and pests by reducing genetic diversity. This opens up a discourse on the need for more sustainable and diversified farming practices. In a world that's increasingly facing the brunt of climate change and biodiversity loss, the apple tree stands as a symbol of both the possibilities and responsibilities that come with cultivation.\n"
    },
    {
      name: "Lemons for Cleaning.md",
      content: "Cleaning your home with lemons is not only effective but also environmentally friendly. Lemons, with their natural disinfecting properties and high citric acid content, can tackle a wide range of cleaning tasks. Here are some detailed tips to maximize the cleaning power of lemons:\n\n1. All-Purpose Cleaner: Create a potent all-purpose cleaner by mixing equal parts lemon juice and water. Lemons contain citric acid, which is effective in killing germs, bacteria, and odors. Squeeze the juice of fresh lemons into a spray bottle, adding an equal amount of water. Shake the bottle well to thoroughly blend the solution. This natural disinfectant is perfect for countertops, sinks, cutting boards, and food containers. To use, simply spray the solution onto the surface and let it sit for a few minutes to allow the citric acid to work its magic. Then, scrub with a sponge or cloth and rinse thoroughly with water.\n\n2. Streak-Free Glass Cleaner: Make your glass surfaces shine with a lemon-based glass cleaner. In a spray bottle, mix equal parts lemon juice and water. The acidity of lemons helps break down dirt and grime, while the natural oils leave a streak-free finish. For tougher stains or spots, add a small amount of vinegar. Shake the bottle well to ensure the ingredients are evenly mixed. To use the cleaner, spray the solution onto the glass surface and use a lint-free cloth or newspaper to wipe it clean. Begin wiping from the top to prevent streaks. Allow the solution to sit on stubborn spots for a few minutes before wiping them away.\n\n3. Eliminating Stains on Faucets and Fixtures: Bid farewell to stains on faucets and fixtures with the natural power of lemons. Cut a lemon in half and rub it directly onto the affected areas, focusing on the stains. The citric acid in lemons effectively breaks down stains while the natural oils give a polished look. After thoroughly rubbing the lemon onto the surface, rinse it with water to remove any residue. Finally, use a dry cloth to polish the faucets and fixtures for a gleaming finish.\n\n4. Rust and Hard Water Stain Remover: Lemons excel at tackling rust and hard water stains. To remove these stubborn stains, dip a cloth or sponge into fresh lemon juice and scrub the affected areas such as faucets, showerheads, or stainless steel appliances. The acidic properties of lemons help dissolve the stains effortlessly. For tougher stains, sprinkle a little salt on the lemon before scrubbing. The salt acts as an abrasive agent. After scrubbing, rinse well with water and dry the surface to prevent further rusting.\n\n5. Natural Air Freshener: Create an inviting and refreshing atmosphere in your home using lemon juice. In a spray bottle, mix lemon juice, water, and a few drops of your favorite essential oil. Lemons have a fresh, citrus scent that naturally eliminates unwanted odors, while the essential oil adds a pleasant fragrance of your choice. Shake the bottle well to ensure the ingredients are properly blended. Spritz this delightful blend around your living spaces to naturally freshen the air. The pleasant, lemony fragrance will replace unwanted odors and create a beautifully scented environment.\n\n6. Polishing and Shining: Lemons can also act as a natural polish for various surfaces. To restore the shine to hardwood furniture, brass, or copper items, cut a lemon in half and dip it into a small amount of salt. Gently rub the lemon onto the surface, allowing the salt and lemon juice to lift dirt and tarnish. The abrasive action of the salt combined with the citric acid helps restore the natural beauty and shine of the items. Rinse the item with water and buff with a soft cloth to reveal the brilliant shine.\n\nBy following these comprehensive tips, you can harness the full cleaning power of lemons to keep your home fresh, sparkling, and free from bacteria and stains. Say goodbye to harsh chemicals and embrace the natural brilliance of lemons. Happy cleaning!"
    },
    {
      name: "Meeting Notes.md",
      content: "---\nDate: 2023-09-26T22:16:00\ntags:\n  - meeting\n  - bob\nweekday: Tuesday\n---\n## Attendees:\n- Alice\n- Bob\n- Charlie\n- Daisy\n\n## Agenda:\n1. **Discuss New Coffee Machine**\n2. **Vote on Office Plants**\n3. **Brainstorm Team Outing Ideas**\n\n### Discuss New Coffee Machine:\n- Alice likes lattes\n- Bob prefers cold brew\n- Charlie's a fan of tea\n- Daisy enjoys espresso\n\n### Vote on Office Plants:\n- Alice: Cactus\n- Bob: Fern\n- Charlie: Bamboo\n- Daisy: Succulent\n\n### Brainstorm Team Outing Ideas:\n- Bowling night\n- Hiking trip\n- Movie night\n\n## Action Items:\n- [ ] Purchase coffee machine\n- [ ] Buy office plants\n- [ ] Plan team outing\n\n## Notes Prepared By:\n- Bob\n"
    },
    {
      name: "Walking Poem.md",
      content: "In the early dawn, when daylight gleams,\nA journey begins, a walk to dream.\nFootsteps upon the earth\u2019s embrace,\nInto the boundless, open space.\n\nBeneath the azure canopy above,\nGuided by whispers of a gentle dove.\nMy soul alights with each tranquil stride,\nBound to the world, I\u2019m opened wide.\n\nThrough groves and meadows, I wander free,\nThe earth, my canvas, my muse, you see.\nAs daisies sway, and the willows weep,\nI find solace in footsteps, slow and deep.\n\nThrough cobbled streets of history,\nI stroll amongst tales of reverie.\nThe past\u2019s echoes guide my way,\nUnveiling lost stories of yesterday.\n\nFootprints on sand, near the ocean's shore,\nSoft whispers of waves, beguiling more.\nThe salty breeze upon my face,\nA dance of nature, in this sacred place.\n\nUp slopes and mountains, I ascend,\nEager to conquer, to transcend.\nWith each steep climb, my spirit soars,\nCloaked by nature's abundant doors.\n\nThrough crowded cities, I navigate,\nObscured by chaos, yet radiate\nA sense of peace, a tranquil grace,\nFostering moments, without a chase.\n\nInto the woods, where silence bloomed,\nUnderneath arboreal canopy, assumed.\nWhispers of leaves, in serenade,\nA sacred symphony, nature's accolade.\n\nWalking through life, step by step,\nEach footfall closer, as dreams intercept.\nTrusting the path, as it twists and turns,\nWith newfound knowledge, my spirit yearns.\n\nFor walking uncovers hidden truth,\nAs thoughts diffuse, my heart finds youth.\nIt is in motion that I discover,\nThe world and myself, forever uncover.\n\nSo embark on journeys, in each new day,\nFor walking provides solace, come what may.\nTake time to marvel, to breathe and roam,\nFor in the rhythm of footsteps, we find our home."
    }
  ]
};

// assets/cannoliIcon.js
var cannoliIcon = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0.00 0.00 100.00 100.00">
<g stroke-width="0.4" fill="none" stroke-linecap="butt">
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 55.75 12.79
  C 40.46 27.55 25.39 42.58 10.32 57.57
  Q 4.20 63.65 2.43 67.47
  C -5.88 85.44 12.97 106.07 31.72 97.48
  C 36.51 95.29 41.69 89.89 45.31 86.31
  Q 67.80 64.10 90.26 41.86
  Q 95.83 36.34 97.53 32.66
  C 106.02 14.29 86.73 -5.45 69.07 2.30
  Q 64.56 4.28 55.75 12.79"
/>
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 92.27 12.95
  C 87.47 6.19 79.03 2.70 71.04 5.83
  C 67.14 7.36 66.47 10.95 65.69 14.83
  Q 63.59 25.24 61.64 35.72
  Q 61.54 36.22 62.05 36.18
  Q 76.41 34.95 90.75 33.53
  C 91.69 33.43 93.52 31.86 93.94 30.73
  Q 97.72 20.62 92.27 12.95"
/>
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 12.70 60.71
  Q 12.32 61.07 12.84 60.99
  Q 28.63 58.55 44.66 55.79
  C 51.26 54.66 54.87 50.54 56.16 43.91
  Q 59.19 28.34 62.02 13.38
  Q 62.30 11.91 61.23 12.96
  L 12.70 60.71"
/>
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 39.58 86.17
  L 87.89 38.49
  Q 88.52 37.87 87.64 37.95
  L 61.24 40.32
  Q 60.64 40.37 60.55 40.97
  C 58.98 51.53 54.97 59.30 43.13 60.05
  A 1.34 1.34 0.0 0 0 41.88 61.23
  L 39.00 85.89
  A 0.34 0.34 0.0 0 0 39.58 86.17"
/>
<path stroke="currentColor" vector-effect="non-scaling-stroke" d="
  M 27.50 94.60
  C 30.02 94.01 34.16 91.67 34.52 88.78
  Q 36.20 75.16 37.73 62.02
  Q 37.85 61.00 36.84 61.16
  Q 24.36 63.14 12.09 65.14
  C 6.13 66.11 3.84 72.08 4.39 77.58
  C 5.61 89.66 15.70 97.36 27.50 94.60"
/>

</g>
<path fill="currentColor" d="
  M 10.32 57.57
  C 25.39 42.58 40.46 27.55 55.75 12.79
  Q 64.56 4.28 69.07 2.30
  C 86.73 -5.45 106.02 14.29 97.53 32.66
  Q 95.83 36.34 90.26 41.86
  Q 67.80 64.10 45.31 86.31
  C 41.69 89.89 36.51 95.29 31.72 97.48
  C 12.97 106.07 -5.88 85.44 2.43 67.47
  Q 4.20 63.65 10.32 57.57
  Z
  M 92.27 12.95
  C 87.47 6.19 79.03 2.70 71.04 5.83
  C 67.14 7.36 66.47 10.95 65.69 14.83
  Q 63.59 25.24 61.64 35.72
  Q 61.54 36.22 62.05 36.18
  Q 76.41 34.95 90.75 33.53
  C 91.69 33.43 93.52 31.86 93.94 30.73
  Q 97.72 20.62 92.27 12.95
  Z
  M 12.70 60.71
  Q 12.32 61.07 12.84 60.99
  Q 28.63 58.55 44.66 55.79
  C 51.26 54.66 54.87 50.54 56.16 43.91
  Q 59.19 28.34 62.02 13.38
  Q 62.30 11.91 61.23 12.96
  L 12.70 60.71
  Z
  M 39.58 86.17
  L 87.89 38.49
  Q 88.52 37.87 87.64 37.95
  L 61.24 40.32
  Q 60.64 40.37 60.55 40.97
  C 58.98 51.53 54.97 59.30 43.13 60.05
  A 1.34 1.34 0.0 0 0 41.88 61.23
  L 39.00 85.89
  A 0.34 0.34 0.0 0 0 39.58 86.17
  Z
  M 27.50 94.60
  C 30.02 94.01 34.16 91.67 34.52 88.78
  Q 36.20 75.16 37.73 62.02
  Q 37.85 61.00 36.84 61.16
  Q 24.36 63.14 12.09 65.14
  C 6.13 66.11 3.84 72.08 4.39 77.58
  C 5.61 89.66 15.70 97.36 27.50 94.60
  Z"
/>
<path fill="none" d="
  M 12.70 60.71
  L 61.23 12.96
  Q 62.30 11.91 62.02 13.38
  Q 59.19 28.34 56.16 43.91
  C 54.87 50.54 51.26 54.66 44.66 55.79
  Q 28.63 58.55 12.84 60.99
  Q 12.32 61.07 12.70 60.71
  Z"
/>
<path fill="none" d="
  M 87.89 38.49
  L 39.58 86.17
  A 0.34 0.34 0.0 0 1 39.00 85.89
  L 41.88 61.23
  A 1.34 1.34 0.0 0 1 43.13 60.05
  C 54.97 59.30 58.98 51.53 60.55 40.97
  Q 60.64 40.37 61.24 40.32
  L 87.64 37.95
  Q 88.52 37.87 87.89 38.49
  Z"
/>
</svg>
`;

// main.ts
var DEFAULT_SETTINGS = {
  llmProvider: "openai",
  ollamaBaseUrl: "http://127.0.0.1:11434",
  ollamaModel: "llama2",
  openaiAPIKey: "",
  costThreshold: 0.5,
  defaultModel: "gpt-3.5-turbo",
  defaultTemperature: 1,
  httpTemplates: [],
  includeFilenameAsHeader: false,
  includePropertiesInExtractedNotes: false,
  chatFormatString: `---
# <u>{{role}}</u>

{{content}}`,
  enableAudioTriggeredCannolis: false,
  deleteAudioFilesAfterAudioTriggeredCannolis: false,
  autoScrollWithTokenStream: false,
  pLimit: 50,
  contentIsColorless: false
};
var Cannoli = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.runningCannolis = {};
    this.createCannoliCommands = async () => {
      await new Promise((resolve) => setTimeout(resolve, 500));
      const cannoliFiles = this.app.vault.getFiles().filter((file) => {
        return file.name.includes(".cno.canvas");
      });
      cannoliFiles.forEach((file) => {
        this.createCannoliCommandForFile(file);
      });
    };
    this.createCannoliCommandForFile = async (file) => {
      this.addCommand({
        id: `run-cannoli-${file.path}`,
        name: `Run ${file.basename.slice(0, -4)}`,
        callback: async () => {
          this.startCannoli(file);
        },
        icon: "cannoli"
      });
    };
    this.createStartCommand = () => {
      this.addCommand({
        id: "start",
        name: "Start/stop cannoli",
        checkCallback: this.startCannoliCommand,
        icon: "cannoli"
      });
    };
    this.startActiveCannoliCommand = () => {
      this.startCannoliCommand(false);
    };
    this.startCannoliCommand = (checking) => {
      const activeFile = this.app.workspace.getActiveFile();
      const isMDFile = activeFile == null ? void 0 : activeFile.path.endsWith(".md");
      const isCanvasFile = activeFile == null ? void 0 : activeFile.path.endsWith(".canvas");
      if (!activeFile)
        return false;
      if (isMDFile) {
        if (checking)
          return true;
        this.app.fileManager.processFrontMatter(
          activeFile,
          (frontmatter) => {
            if (frontmatter.cannoli) {
              const filename = frontmatter.cannoli.replace("[[", "").replace("]]", "").split("|")[0];
              const file = this.app.metadataCache.getFirstLinkpathDest(
                filename,
                ""
              );
              if (!file) {
                return null;
              }
              this.startOrStopCannoli(file);
            }
          }
        );
      } else if (isCanvasFile) {
        if (checking)
          return true;
        this.startOrStopCannoli(activeFile);
      } else {
        return false;
      }
    };
    this.startOrStopCannoli = async (cannoli) => {
      if (!cannoli || !cannoli.path.endsWith(".canvas")) {
        new import_obsidian3.Notice("This file is not a canvas");
        return;
      }
      if (this.runningCannolis[cannoli.basename]) {
        this.runningCannolis[cannoli.basename].stop();
        delete this.runningCannolis[cannoli.basename];
        return;
      }
      this.startCannoli(cannoli);
    };
    this.newAudioFile = async (audio) => {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || !activeFile.path.endsWith(".md")) {
        return;
      }
      this.app.fileManager.processFrontMatter(
        activeFile,
        async (frontmatter) => {
          if (frontmatter.cannoli) {
            const cannoliFilename = frontmatter.cannoli.replace("[[", "").replace("]]", "").split("|")[0];
            if (!cannoliFilename.endsWith(".canvas")) {
              return null;
            }
            const cannoliFile = this.app.metadataCache.getFirstLinkpathDest(
              cannoliFilename,
              ""
            );
            if (!cannoliFile) {
              return null;
            }
            await this.replaceAudioWithTranscript(activeFile, audio);
            this.startCannoli(cannoliFile);
          } else {
            return null;
          }
        }
      );
    };
    this.startCannoli = async (file) => {
      var _a2, _b, _c;
      if (this.settings.llmProvider === "openai" && this.settings.openaiAPIKey === DEFAULT_SETTINGS.openaiAPIKey) {
        new import_obsidian3.Notice(
          "Please enter your OpenAI API key in the Cannoli settings"
        );
        return;
      }
      let llm;
      switch (this.settings.llmProvider) {
        case "openai": {
          const openAiConfig = {
            apiKey: this.settings.openaiAPIKey,
            model: this.settings.defaultModel,
            temperature: this.settings.defaultTemperature,
            role: "user"
          };
          llm = new Llm({
            provider: "openai",
            openaiConfig: openAiConfig
          });
          break;
        }
        case "ollama": {
          const ollamaConfig = {
            baseURL: this.settings.ollamaBaseUrl,
            model: this.settings.ollamaModel
          };
          llm = new Llm({
            provider: "ollama",
            ollamaConfig
          });
          break;
        }
      }
      const name = file.basename.endsWith(".cno") ? file.basename.slice(0, -4) : file.basename;
      if (this.runningCannolis[file.basename]) {
        new import_obsidian3.Notice(`Cannoli: ${name} is already running`);
        return;
      }
      new import_obsidian3.Notice(`Started cannoli: ${name}`);
      await new Promise((resolve) => setTimeout(resolve, 1500));
      const canvas = new Canvas(file);
      await canvas.fetchData();
      const factory = new CannoliFactory(
        canvas.getCanvasData(),
        (_b = `[[${(_a2 = this.app.workspace.getActiveFile()) == null ? void 0 : _a2.basename}]]`) != null ? _b : "No active note",
        (_c = this.settings.contentIsColorless) != null ? _c : false
      );
      const graph = factory.getCannoliData();
      const shouldContinue = await this.validateCannoli(
        graph,
        file,
        name,
        canvas,
        llm
      );
      if (shouldContinue) {
        await this.runCannoli(graph, file, name, canvas, llm);
      }
    };
    this.validateCannoli = async (graph, file, name, canvas, llm, audioTranscription) => {
      return new Promise((resolve) => {
        const onFinish = (stoppage) => {
          delete this.runningCannolis[file.basename];
          if (stoppage.reason === "error") {
            new import_obsidian3.Notice(
              `Cannoli ${name} failed with the error:

${stoppage.message}`
            );
            resolve(false);
            return;
          }
          const onContinueCallback = () => {
            resolve(true);
          };
          const onCancelCallback = () => {
            resolve(false);
          };
          if (stoppage.totalCost > this.settings.costThreshold) {
            new RunPriceAlertModal(
              this.app,
              stoppage.usage,
              onContinueCallback,
              onCancelCallback
            ).open();
          } else {
            onContinueCallback();
          }
        };
        const validationGraph = new CannoliGraph2(
          JSON.parse(JSON.stringify(graph))
        );
        const validationRun = new Run({
          graph: validationGraph.graph,
          isMock: true,
          canvas,
          onFinish,
          cannoli: this,
          llm
        });
        validationRun.start();
      });
    };
    this.runCannoli = async (graph, file, name, canvas, llm) => {
      return new Promise((resolve) => {
        const onFinish = (stoppage) => {
          delete this.runningCannolis[file.basename];
          let costString = "";
          if (stoppage.totalCost > 0.01) {
            costString = `
$${stoppage.totalCost.toFixed(2)}`;
          }
          if (stoppage.reason === "error") {
            new import_obsidian3.Notice(
              `Cannoli ${name} failed with the error:

${stoppage.message}${costString}`
            );
          } else if (stoppage.reason === "complete") {
            new import_obsidian3.Notice(`Cannoli complete: ${name}${costString}`);
          } else {
            new import_obsidian3.Notice(`Cannoli stopped: ${name}${costString}`);
          }
          resolve();
        };
        const liveGraph = new CannoliGraph2(
          JSON.parse(JSON.stringify(graph))
        );
        const run = new Run({
          graph: liveGraph.graph,
          llm,
          isMock: false,
          canvas,
          onFinish,
          cannoli: this
        });
        this.runningCannolis[file.basename] = run;
        run.start();
      });
    };
    this.addSampleFolder = async () => {
      try {
        await this.app.vault.createFolder("Cannoli College");
      } catch (error) {
        new import_obsidian3.Notice("Cannoli College folder already exists");
        return;
      }
      for (const [key, value] of Object.entries(cannoliCollege)) {
        await this.app.vault.createFolder("Cannoli College/" + key);
        for (const item of value) {
          const { name, content } = item;
          await this.app.vault.create(
            "Cannoli College/" + key + "/" + name,
            content
          );
        }
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        if (file.name.includes(".cno.canvas")) {
          this.createCannoliCommandForFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file.name.includes(".cno.canvas")) {
          this.createCannoliCommandForFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (
          // flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
          this.settings.enableAudioTriggeredCannolis && (file.name.includes(".flac") || file.name.includes(".mp3") || file.name.includes(".mp4") || file.name.includes(".mpeg") || file.name.includes(".mpga") || file.name.includes(".m4a") || file.name.includes(".ogg") || file.name.includes(".wav") || file.name.includes(".webm"))
        ) {
          this.newAudioFile(file);
        }
      })
    );
    (0, import_obsidian3.addIcon)("cannoli", cannoliIcon);
    this.createStartCommand();
    this.createCannoliCommands();
    this.addRibbonIcon(
      "cannoli",
      "Start/stop cannoli",
      this.startActiveCannoliCommand
    );
    this.addSettingTab(new CannoliSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async replaceAudioWithTranscript(file, audio) {
    const transcript = await this.generateTranscript(audio);
    if (!transcript) {
      return;
    }
    const maxAttempts = 50;
    const delay = 100;
    let attempts = 0;
    const checkReferenceExists = async () => {
      let exists = false;
      await this.app.vault.process(file, (content) => {
        exists = content.includes(`![[${audio.name}]]`);
        return content;
      });
      return exists;
    };
    while (attempts < maxAttempts) {
      if (await checkReferenceExists()) {
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, delay));
      attempts++;
    }
    if (attempts === maxAttempts) {
      return;
    }
    await this.app.vault.process(file, (content) => {
      const newContent = content.replace(
        `
![[${audio.name}]]
`,
        transcript
      );
      return newContent;
    });
    if (this.settings.deleteAudioFilesAfterAudioTriggeredCannolis) {
      this.app.vault.delete(audio);
    }
  }
  async generateTranscript(file) {
    new import_obsidian3.Notice("Transcribing audio");
    if (!file) {
      console.error("File not found");
      return;
    }
    const audioBuffer = await this.app.vault.readBinary(file);
    const N = 16;
    const randomBoundryString = "WebKitFormBoundary" + Array(N + 1).join(
      (Math.random().toString(36) + "00000000000000000").slice(
        2,
        18
      )
    ).slice(0, N);
    const pre_string = `------${randomBoundryString}\r
Content-Disposition: form-data; name="file"; filename="audio.${file.extension}"\r
Content-Type: "application/octet-stream"\r
\r
`;
    let post_string = `\r
------${randomBoundryString}\r
Content-Disposition: form-data; name="model"\r
\r
whisper-1`;
    if (this.settings.transcriptionPrompt) {
      post_string += `\r
------${randomBoundryString}\r
Content-Disposition: form-data; name="prompt"\r
\r
${this.settings.transcriptionPrompt}`;
    }
    post_string += `\r
------${randomBoundryString}--\r
`;
    const pre_string_encoded = new TextEncoder().encode(pre_string);
    const post_string_encoded = new TextEncoder().encode(post_string);
    const concatenated = await new Blob([
      pre_string_encoded,
      audioBuffer,
      post_string_encoded
    ]).arrayBuffer();
    const options = {
      url: "https://api.openai.com/v1/audio/transcriptions",
      method: "POST",
      headers: {
        "Content-Type": `multipart/form-data; boundary=----${randomBoundryString}`,
        Authorization: "Bearer " + this.settings.openaiAPIKey
      },
      body: concatenated
    };
    try {
      const response = await (0, import_obsidian3.requestUrl)(options);
      if ("text" in response.json)
        return response.json.text;
      else
        throw new Error("Error. " + JSON.stringify(response.json));
    } catch (error) {
      console.error(error);
    }
  }
};
var RunPriceAlertModal = class extends import_obsidian3.Modal {
  constructor(app, usage, onContinue, onCancel) {
    super(app);
    this.usage = Object.values(usage);
    this.onContinue = onContinue;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    let totalCost = 0;
    for (const usageItem of this.usage) {
      totalCost += usageItem.modelUsage.totalCost;
    }
    contentEl.createEl("h1", { text: "Run cost alert" });
    contentEl.createEl("p", {
      text: "Check the cost of your run before continuing"
    });
    this.usage.forEach((usage) => {
      contentEl.createEl("h2", { text: `Model: ${usage.model.name}` });
      contentEl.createEl("p", {
        text: `		Estimated prompt tokens: ${usage.modelUsage.promptTokens}`
      }).addClass("whitespace");
      contentEl.createEl("p", {
        text: `		Number of API calls: ${usage.modelUsage.apiCalls}`
      }).addClass("whitespace");
      contentEl.createEl("p", {
        text: `		Cost: $${(usage.modelUsage.promptTokens * usage.model.promptTokenPrice).toFixed(2)}`
      }).addClass("whitespace");
    });
    contentEl.createEl("h2", {
      text: `Total cost: $${totalCost.toFixed(2)}`
    });
    const panel = new import_obsidian3.Setting(contentEl);
    panel.addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
        this.onCancel();
      })
    );
    panel.addButton(
      (btn) => btn.setButtonText("Continue").setCta().onClick(() => {
        this.close();
        this.onContinue();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var HttpTemplateEditorModal = class extends import_obsidian3.Modal {
  constructor(app, template, onSave, onCancel) {
    super(app);
    this.template = template;
    this.onSave = onSave;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("http-template-editor");
    contentEl.createEl("h1", { text: "Edit action node template" });
    const createInputGroup = (labelText, inputElement, id) => {
      const div = contentEl.createEl("div", {
        cls: "http-template-group"
      });
      const label = div.createEl("label", { text: labelText });
      label.htmlFor = id;
      inputElement.setAttribute("id", id);
      div.appendChild(inputElement);
    };
    const createDescription = (text) => {
      const p = contentEl.createEl("p", {
        cls: "http-template-description"
      });
      p.textContent = text;
      return p;
    };
    const nameInput = contentEl.createEl("input", {
      type: "text",
      value: this.template.name || ""
    });
    nameInput.setAttribute("id", "name-input");
    createInputGroup("Name:", nameInput, "name-input");
    const urlInput = contentEl.createEl("input", {
      type: "text",
      value: this.template.url || ""
    });
    urlInput.setAttribute("id", "url-input");
    createInputGroup("URL:", urlInput, "url-input");
    const methodSelect = contentEl.createEl("select");
    const methods = ["GET", "POST", "PUT", "DELETE"];
    methods.forEach((method) => {
      const option = methodSelect.createEl("option", {
        text: method,
        value: method
      });
      if (this.template.method === method) {
        option.selected = true;
      }
    });
    createInputGroup("Method:", methodSelect, "method-select");
    const headersValue = this.template.headers && Object.keys(this.template.headers).length > 0 ? JSON.stringify(this.template.headers, null, 2) : JSON.stringify(
      { "Content-Type": "application/json" },
      null,
      2
      // eslint-disable-next-line no-mixed-spaces-and-tabs
    );
    const headersInput = contentEl.createEl("textarea", {
      placeholder: `{ "Content-Type": "application/json" }`
    });
    headersInput.value = headersValue;
    headersInput.setAttribute("rows", "3");
    createInputGroup("Headers:", headersInput, "headers-input");
    const bodyTemplateInput = contentEl.createEl("textarea", {
      placeholder: "Enter body template. Use {{variableName}} for variables."
    });
    const formattedBody = this.formatBody(this.template.bodyTemplate || "");
    bodyTemplateInput.value = formattedBody;
    bodyTemplateInput.setAttribute("rows", "3");
    bodyTemplateInput.setAttribute(
      "placeholder",
      "Enter body template. Use {{variableName}} for variables."
    );
    createInputGroup(
      "Body template: (optional)",
      bodyTemplateInput,
      "body-template-input"
    );
    createDescription(
      "You can use the optional body template to predefine the structure of the request body. Use {{variableName}} syntax to insert variables into the body template. If there's only one variable, it will be replaced with whatever is written to the action node. If there are multiple variables, the action node will look for the variables in the available named arrows."
    );
    const panel = new import_obsidian3.Setting(contentEl);
    panel.addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
        this.onCancel();
      })
    );
    panel.addButton(
      (btn) => btn.setButtonText("Save").setCta().onClick(() => {
        let headers = {};
        try {
          headers = JSON.parse(headersInput.value || "{}");
        } catch (error) {
          alert(
            "Invalid JSON format for headers. Please correct and try again."
          );
          return;
        }
        this.template.name = nameInput.value;
        this.template.url = urlInput.value;
        this.template.headers = headers;
        this.template.method = methodSelect.value;
        this.template.bodyTemplate = bodyTemplateInput.value;
        this.close();
        this.onSave(this.template);
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  formatBody(body) {
    try {
      const parsedBody = JSON.parse(body);
      return JSON.stringify(parsedBody, null, 2);
    } catch (error) {
      return body;
    }
  }
};
var CannoliSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Add Cannoli College").setDesc(
      "Add a folder of sample cannolis to your vault to walk you through the basics of Cannoli. (Delete and re-add this folder to get the latest version after an update.)"
    ).addButton(
      (button) => button.setButtonText("Add").onClick(() => {
        this.plugin.addSampleFolder();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("AI provider").setDesc(
      "Select the AI provider you'd like to use for your cannolis."
    ).addDropdown((dropdown) => {
      var _a2;
      dropdown.addOption("openai", "OpenAI");
      dropdown.addOption("ollama", "Ollama");
      dropdown.setValue(
        (_a2 = this.plugin.settings.llmProvider) != null ? _a2 : DEFAULT_SETTINGS.llmProvider
      );
      dropdown.onChange(async (value) => {
        this.plugin.settings.llmProvider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    containerEl.createEl("h1", { text: "LLM" });
    if (this.plugin.settings.llmProvider === "openai") {
      new import_obsidian3.Setting(containerEl).setName("OpenAI API key").setDesc(
        "This key will be used to make all openai LLM calls. Be aware that complex cannolis, especially those with many GPT-4 calls, can be expensive to run."
      ).addText(
        (text) => text.setValue(this.plugin.settings.openaiAPIKey).setPlaceholder("sk-...").onChange(async (value) => {
          this.plugin.settings.openaiAPIKey = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian3.Setting(containerEl).setName("Cost threshold").setDesc(
        "If the cannoli you are about to run is estimated to cost more than this amount (USD$), you will be alerted before running it."
      ).addText(
        (text) => text.setValue(
          !isNaN(this.plugin.settings.costThreshold) ? this.plugin.settings.costThreshold.toString() : DEFAULT_SETTINGS.costThreshold.toString()
        ).onChange(async (value) => {
          if (!isNaN(parseFloat(value))) {
            this.plugin.settings.costThreshold = parseFloat(value);
            await this.plugin.saveSettings();
          } else {
            this.plugin.settings.costThreshold = DEFAULT_SETTINGS.costThreshold;
            await this.plugin.saveSettings();
          }
        })
      );
      new import_obsidian3.Setting(containerEl).setName("Default LLM model").setDesc(
        "This model will be used for all LLM nodes unless overridden with a config arrow. (Note that special arrow types rely on function calling, which is not available in all models.)"
      ).addText(
        (text) => text.setValue(this.plugin.settings.defaultModel).onChange(async (value) => {
          this.plugin.settings.defaultModel = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian3.Setting(containerEl).setName("Default LLM temperature").setDesc(
        "This temperature will be used for all LLM nodes unless overridden with a config arrow."
      ).addText(
        (text) => text.setValue(
          !isNaN(this.plugin.settings.defaultTemperature) && this.plugin.settings.defaultTemperature ? this.plugin.settings.defaultTemperature.toString() : DEFAULT_SETTINGS.defaultTemperature.toString()
        ).onChange(async (value) => {
          if (!isNaN(parseFloat(value))) {
            this.plugin.settings.defaultTemperature = parseFloat(value);
            await this.plugin.saveSettings();
          } else {
            this.plugin.settings.defaultTemperature = DEFAULT_SETTINGS.defaultTemperature;
            await this.plugin.saveSettings();
          }
        })
      );
    } else if (this.plugin.settings.llmProvider === "ollama") {
      new import_obsidian3.Setting(containerEl).setName("Ollama base url").setDesc(
        "This url will be used to make all ollama LLM calls. Be aware that ollama models have different features and capabilities that may not be compatible with all features of cannoli."
      ).addText(
        (text) => text.setValue(this.plugin.settings.ollamaBaseUrl).setPlaceholder("https://ollama.com").onChange(async (value) => {
          this.plugin.settings.ollamaBaseUrl = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian3.Setting(containerEl).setName("Ollama model").setDesc(
        "This model will be used for all LLM nodes unless overridden with a config arrow. (Note that special arrow types rely on function calling, which is not available in all models.)"
      ).addText(
        (text) => text.setValue(this.plugin.settings.ollamaModel).onChange(async (value) => {
          this.plugin.settings.ollamaModel = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian3.Setting(containerEl).setName("LLM call concurrency limit (pLimit)").setDesc(
      "The maximum number of LLM calls that can be made at once. Decrease this if you are running into rate limiting issues."
    ).addText(
      (text) => text.setValue(
        Number.isInteger(this.plugin.settings.pLimit) ? this.plugin.settings.pLimit.toString() : DEFAULT_SETTINGS.pLimit.toString()
      ).onChange(async (value) => {
        if (!isNaN(parseInt(value)) && parseInt(value) > 0) {
          this.plugin.settings.pLimit = parseInt(value);
          await this.plugin.saveSettings();
        } else {
          this.plugin.settings.pLimit = DEFAULT_SETTINGS.pLimit;
          await this.plugin.saveSettings();
        }
      })
    );
    containerEl.createEl("h1", { text: "Canvas preferences" });
    new import_obsidian3.Setting(containerEl).setName("Parse colorless nodes as content nodes").setDesc(
      "Toggle this if you'd like colorless (grey) nodes to be interpreted as content nodes rather than call nodes. Purple nodes will then be interpreted as call nodes."
    ).addToggle(
      (toggle) => {
        var _a2;
        return toggle.setValue(
          (_a2 = this.plugin.settings.contentIsColorless) != null ? _a2 : DEFAULT_SETTINGS.contentIsColorless
        ).onChange(async (value) => {
          this.plugin.settings.contentIsColorless = value;
          await this.plugin.saveSettings();
        });
      }
    );
    containerEl.createEl("h1", { text: "Note extraction" });
    new import_obsidian3.Setting(containerEl).setName(
      "Include filenames as headers in extracted notes by default"
    ).setDesc(
      `When extracting a note in a cannoli, include the filename as a top-level header. This default can be overridden by adding "#" or "!#" after the note link in a reference like this: {{[[Stuff]]#}} or {{[[Stuff]]!#}}.`
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.includeFilenameAsHeader || false
      ).onChange(async (value) => {
        this.plugin.settings.includeFilenameAsHeader = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName(
      "Include properties when extracting or editing notes by default"
    ).setDesc(
      `When extracting or editing a note in a cannoli, include the note's properties (YAML frontmatter). This default can be overridden by adding "^" or "!^" after the note link in a reference like this: {{[[Stuff]]^}} or {{[[Stuff]]!^}}.`
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.includePropertiesInExtractedNotes || false
      ).onChange(async (value) => {
        this.plugin.settings.includePropertiesInExtractedNotes = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h1", { text: "Chat cannolis" });
    new import_obsidian3.Setting(containerEl).setName("Chat format string").setDesc(
      "This string will be used to format chat messages when using chat arrows. This string must contain the placeholders {{role}} and {{content}}, which will be replaced with the role and content of the message, respectively."
    ).addTextArea(
      (text) => text.setValue(this.plugin.settings.chatFormatString).onChange(async (value) => {
        const rolePlaceholder = "{{role}}";
        const contentPlaceholder = "{{content}}";
        if (!value.includes(rolePlaceholder) || !value.includes(contentPlaceholder)) {
          alert(
            `Invalid format string. Please include both ${rolePlaceholder} and ${contentPlaceholder}.`
          );
          return;
        }
        this.plugin.settings.chatFormatString = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Auto-scroll with token stream").setDesc(
      "Move the cursor forward every time a token is streamed in from a chat arrow. This will lock the scroll position to the bottom of the note."
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.autoScrollWithTokenStream || false
      ).onChange(async (value) => {
        this.plugin.settings.autoScrollWithTokenStream = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h1", { text: "Transcription" });
    new import_obsidian3.Setting(containerEl).setName("Enable audio recorder triggered cannolis").setDesc(
      `Enable cannolis to be triggered by audio recordings. When you make a recording in a note with a cannoli property: (1) The audio file will be transcribed using Whisper. (2) The file reference will be replaced with the transcript. (3) The cannoli defined in the property will run.`
    ).addToggle(
      (toggle) => toggle.setValue(
        this.plugin.settings.enableAudioTriggeredCannolis || false
      ).onChange(async (value) => {
        this.plugin.settings.enableAudioTriggeredCannolis = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.enableAudioTriggeredCannolis) {
      new import_obsidian3.Setting(containerEl).addTextArea(
        (text) => text.setPlaceholder(
          "Enter prompt to improve transcription accuracy"
        ).setValue(
          this.plugin.settings.transcriptionPrompt || ""
        ).onChange(async (value) => {
          this.plugin.settings.transcriptionPrompt = value;
          await this.plugin.saveSettings();
        })
      ).setName("Transcription prompt").setDesc(
        "Use this prompt to guide the style and vocabulary of the transcription. (i.e. the level of punctuation, format and spelling of uncommon words in the prompt will be mimicked in the transcription)"
      );
      new import_obsidian3.Setting(containerEl).setName("Delete audio files after transcription").setDesc(
        "After a recording is transcribed, delete the audio file."
      ).addToggle(
        (toggle) => toggle.setValue(
          this.plugin.settings.deleteAudioFilesAfterAudioTriggeredCannolis || false
          // eslint-disable-next-line no-mixed-spaces-and-tabs
        ).onChange(async (value) => {
          this.plugin.settings.deleteAudioFilesAfterAudioTriggeredCannolis = value;
          await this.plugin.saveSettings();
        })
      );
    }
    containerEl.createEl("h1", { text: "Action nodes" });
    new import_obsidian3.Setting(containerEl).setName("Action node templates").setDesc("Manage default HTTP templates for action nodes.").addButton(
      (button) => button.setButtonText("+ Template").onClick(() => {
        const newCommand = {
          name: "",
          url: "",
          headers: {},
          id: "",
          method: "GET"
        };
        new HttpTemplateEditorModal(
          this.app,
          newCommand,
          (command) => {
            this.plugin.settings.httpTemplates.push(command);
            this.plugin.saveSettings();
            this.display();
          },
          () => {
          }
        ).open();
      })
    );
    for (const template of this.plugin.settings.httpTemplates) {
      new import_obsidian3.Setting(containerEl).setName(template.name).addButton(
        (button) => button.setButtonText("Edit").onClick(() => {
          new HttpTemplateEditorModal(
            this.app,
            template,
            (updatedTemplate) => {
              Object.assign(template, updatedTemplate);
              this.plugin.saveSettings();
              this.display();
            },
            () => {
            }
          ).open();
        })
      ).addButton(
        (button) => button.setButtonText("Delete").onClick(() => {
          const index = this.plugin.settings.httpTemplates.indexOf(
            template
          );
          if (index > -1) {
            this.plugin.settings.httpTemplates.splice(index, 1);
            this.plugin.saveSettings();
            this.display();
          }
        })
      );
    }
  }
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
